var pd = Object.defineProperty,
  md = Object.defineProperties;
var xd = Object.getOwnPropertyDescriptors;
var fl = Object.getOwnPropertySymbols;
var gd = Object.prototype.hasOwnProperty,
  _d = Object.prototype.propertyIsEnumerable;
var Li = (i, e) => ((e = Symbol[i]) ? e : Symbol.for("Symbol." + i)),
  vd = (i) => {
    throw TypeError(i);
  };
var hl = (i, e, t) =>
    e in i
      ? pd(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (i[e] = t),
  Xn = (i, e) => {
    for (var t in e || (e = {})) gd.call(e, t) && hl(i, t, e[t]);
    if (fl) for (var t of fl(e)) _d.call(e, t) && hl(i, t, e[t]);
    return i;
  },
  dl = (i, e) => md(i, xd(e));
var li = function (i, e) {
    (this[0] = i), (this[1] = e);
  },
  Ga = (i, e, t) => {
    var n = (a, o, l, c) => {
        try {
          var u = t[a](o),
            h = (o = u.value) instanceof li,
            f = u.done;
          Promise.resolve(h ? o[0] : o)
            .then((m) =>
              h
                ? n(
                    a === "return" ? a : "next",
                    o[1] ? { done: m.done, value: m.value } : m,
                    l,
                    c,
                  )
                : l({ value: m, done: f }),
            )
            .catch((m) => n("throw", m, l, c));
        } catch (m) {
          c(m);
        }
      },
      r = (a) => (s[a] = (o) => new Promise((l, c) => n(a, o, l, c))),
      s = {};
    return (
      (t = t.apply(i, e)),
      (s[Li("asyncIterator")] = () => s),
      r("next"),
      r("throw"),
      r("return"),
      s
    );
  },
  Wa = (i) => {
    var e = i[Li("asyncIterator")],
      t = !1,
      n,
      r = {};
    return (
      e == null
        ? ((e = i[Li("iterator")]()), (n = (s) => (r[s] = (a) => e[s](a))))
        : ((e = e.call(i)),
          (n = (s) =>
            (r[s] = (a) => {
              if (t) {
                if (((t = !1), s === "throw")) throw a;
                return a;
              }
              return (
                (t = !0),
                {
                  done: !1,
                  value: new li(
                    new Promise((o) => {
                      var l = e[s](a);
                      l instanceof Object || vd("Object expected"), o(l);
                    }),
                    1,
                  ),
                }
              );
            }))),
      (r[Li("iterator")] = () => r),
      n("next"),
      "throw" in e
        ? n("throw")
        : (r.throw = (s) => {
            throw s;
          }),
      "return" in e && n("return"),
      r
    );
  },
  pl = (i, e, t) =>
    (e = i[Li("asyncIterator")])
      ? e.call(i)
      : ((i = i[Li("iterator")]()),
        (e = {}),
        (t = (n, r) =>
          (r = i[n]) &&
          (e[n] = (s) =>
            new Promise(
              (a, o, l) => (
                (s = r.call(i, s)),
                (l = s.done),
                Promise.resolve(s.value).then(
                  (c) => a({ value: c, done: l }),
                  o,
                )
              ),
            ))),
        t("next"),
        t("return"),
        e);
var Xa =
  typeof globalThis != "undefined"
    ? globalThis
    : typeof window != "undefined"
      ? window
      : typeof global != "undefined"
        ? global
        : typeof self != "undefined"
          ? self
          : {};
function Ed(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default")
    ? i.default
    : i;
}
function yd(i) {
  if (Object.prototype.hasOwnProperty.call(i, "__esModule")) return i;
  var e = i.default;
  if (typeof e == "function") {
    var t = function n() {
      return this instanceof n
        ? Reflect.construct(e, arguments, this.constructor)
        : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return (
    Object.defineProperty(t, "__esModule", { value: !0 }),
    Object.keys(i).forEach(function (n) {
      var r = Object.getOwnPropertyDescriptor(i, n);
      Object.defineProperty(
        t,
        n,
        r.get
          ? r
          : {
              enumerable: !0,
              get: function () {
                return i[n];
              },
            },
      );
    }),
    t
  );
}
/**
 * @remix-run/router v1.23.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function Rt() {
  return (
    (Rt = Object.assign
      ? Object.assign.bind()
      : function (i) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var n in t)
              Object.prototype.hasOwnProperty.call(t, n) && (i[n] = t[n]);
          }
          return i;
        }),
    Rt.apply(this, arguments)
  );
}
var It;
(function (i) {
  (i.Pop = "POP"), (i.Push = "PUSH"), (i.Replace = "REPLACE");
})(It || (It = {}));
const ml = "popstate";
function fS(i) {
  i === void 0 && (i = {});
  function e(n, r) {
    let { pathname: s, search: a, hash: o } = n.location;
    return Or(
      "",
      { pathname: s, search: a, hash: o },
      (r.state && r.state.usr) || null,
      (r.state && r.state.key) || "default",
    );
  }
  function t(n, r) {
    return typeof r == "string" ? r : Hr(r);
  }
  return Md(e, t, null, i);
}
function At(i, e) {
  if (i === !1 || i === null || typeof i == "undefined") throw new Error(e);
}
function or(i, e) {
  if (!i) {
    typeof console != "undefined" && console.warn(e);
    try {
      throw new Error(e);
    } catch (t) {}
  }
}
function Sd() {
  return Math.random().toString(36).substr(2, 8);
}
function xl(i, e) {
  return { usr: i.state, key: i.key, idx: e };
}
function Or(i, e, t, n) {
  return (
    t === void 0 && (t = null),
    Rt(
      { pathname: typeof i == "string" ? i : i.pathname, search: "", hash: "" },
      typeof e == "string" ? Ri(e) : e,
      { state: t, key: (e && e.key) || n || Sd() },
    )
  );
}
function Hr(i) {
  let { pathname: e = "/", search: t = "", hash: n = "" } = i;
  return (
    t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t),
    n && n !== "#" && (e += n.charAt(0) === "#" ? n : "#" + n),
    e
  );
}
function Ri(i) {
  let e = {};
  if (i) {
    let t = i.indexOf("#");
    t >= 0 && ((e.hash = i.substr(t)), (i = i.substr(0, t)));
    let n = i.indexOf("?");
    n >= 0 && ((e.search = i.substr(n)), (i = i.substr(0, n))),
      i && (e.pathname = i);
  }
  return e;
}
function Md(i, e, t, n) {
  n === void 0 && (n = {});
  let { window: r = document.defaultView, v5Compat: s = !1 } = n,
    a = r.history,
    o = It.Pop,
    l = null,
    c = u();
  c == null && ((c = 0), a.replaceState(Rt({}, a.state, { idx: c }), ""));
  function u() {
    return (a.state || { idx: null }).idx;
  }
  function h() {
    o = It.Pop;
    let d = u(),
      p = d == null ? null : d - c;
    (c = d), l && l({ action: o, location: g.location, delta: p });
  }
  function f(d, p) {
    o = It.Push;
    let y = Or(g.location, d, p);
    c = u() + 1;
    let E = xl(y, c),
      v = g.createHref(y);
    try {
      a.pushState(E, "", v);
    } catch (C) {
      if (C instanceof DOMException && C.name === "DataCloneError") throw C;
      r.location.assign(v);
    }
    s && l && l({ action: o, location: g.location, delta: 1 });
  }
  function m(d, p) {
    o = It.Replace;
    let y = Or(g.location, d, p);
    c = u();
    let E = xl(y, c),
      v = g.createHref(y);
    a.replaceState(E, "", v),
      s && l && l({ action: o, location: g.location, delta: 0 });
  }
  function x(d) {
    let p = r.location.origin !== "null" ? r.location.origin : r.location.href,
      y = typeof d == "string" ? d : Hr(d);
    return (
      (y = y.replace(/ $/, "%20")),
      At(
        p,
        "No window.location.(origin|href) available to create URL for href: " +
          y,
      ),
      new URL(y, p)
    );
  }
  let g = {
    get action() {
      return o;
    },
    get location() {
      return i(r, a);
    },
    listen(d) {
      if (l) throw new Error("A history only accepts one active listener");
      return (
        r.addEventListener(ml, h),
        (l = d),
        () => {
          r.removeEventListener(ml, h), (l = null);
        }
      );
    },
    createHref(d) {
      return e(r, d);
    },
    createURL: x,
    encodeLocation(d) {
      let p = x(d);
      return { pathname: p.pathname, search: p.search, hash: p.hash };
    },
    push: f,
    replace: m,
    go(d) {
      return a.go(d);
    },
  };
  return g;
}
var xt;
(function (i) {
  (i.data = "data"),
    (i.deferred = "deferred"),
    (i.redirect = "redirect"),
    (i.error = "error");
})(xt || (xt = {}));
const Ad = new Set([
  "lazy",
  "caseSensitive",
  "path",
  "id",
  "index",
  "children",
]);
function bd(i) {
  return i.index === !0;
}
function Ma(i, e, t, n) {
  return (
    t === void 0 && (t = []),
    n === void 0 && (n = {}),
    i.map((r, s) => {
      let a = [...t, String(s)],
        o = typeof r.id == "string" ? r.id : a.join("-");
      if (
        (At(
          r.index !== !0 || !r.children,
          "Cannot specify children on an index route",
        ),
        At(
          !n[o],
          'Found a route id collision on id "' +
            o +
            `".  Route id's must be globally unique within Data Router usages`,
        ),
        bd(r))
      ) {
        let l = Rt({}, r, e(r), { id: o });
        return (n[o] = l), l;
      } else {
        let l = Rt({}, r, e(r), { id: o, children: void 0 });
        return (
          (n[o] = l), r.children && (l.children = Ma(r.children, e, a, n)), l
        );
      }
    })
  );
}
function er(i, e, t) {
  return t === void 0 && (t = "/"), Cs(i, e, t, !1);
}
function Cs(i, e, t, n) {
  let r = typeof e == "string" ? Ri(e) : e,
    s = Ra(r.pathname || "/", t);
  if (s == null) return null;
  let a = Of(i);
  Cd(a);
  let o = null;
  for (let l = 0; o == null && l < a.length; ++l) {
    let c = Od(s);
    o = Id(a[l], c, n);
  }
  return o;
}
function Td(i, e) {
  let { route: t, pathname: n, params: r } = i;
  return { id: t.id, pathname: n, params: r, data: e[t.id], handle: t.handle };
}
function Of(i, e, t, n) {
  e === void 0 && (e = []), t === void 0 && (t = []), n === void 0 && (n = "");
  let r = (s, a, o) => {
    let l = {
      relativePath: o === void 0 ? s.path || "" : o,
      caseSensitive: s.caseSensitive === !0,
      childrenIndex: a,
      route: s,
    };
    l.relativePath.startsWith("/") &&
      (At(
        l.relativePath.startsWith(n),
        'Absolute route path "' +
          l.relativePath +
          '" nested under path ' +
          ('"' + n + '" is not valid. An absolute child route path ') +
          "must start with the combined path of all its parent routes.",
      ),
      (l.relativePath = l.relativePath.slice(n.length)));
    let c = Nr([n, l.relativePath]),
      u = t.concat(l);
    s.children &&
      s.children.length > 0 &&
      (At(
        s.index !== !0,
        "Index routes must not have child routes. Please remove " +
          ('all child routes from route path "' + c + '".'),
      ),
      Of(s.children, e, u, c)),
      !(s.path == null && !s.index) &&
        e.push({ path: c, score: Ld(c, s.index), routesMeta: u });
  };
  return (
    i.forEach((s, a) => {
      var o;
      if (s.path === "" || !((o = s.path) != null && o.includes("?"))) r(s, a);
      else for (let l of zf(s.path)) r(s, a, l);
    }),
    e
  );
}
function zf(i) {
  let e = i.split("/");
  if (e.length === 0) return [];
  let [t, ...n] = e,
    r = t.endsWith("?"),
    s = t.replace(/\?$/, "");
  if (n.length === 0) return r ? [s, ""] : [s];
  let a = zf(n.join("/")),
    o = [];
  return (
    o.push(...a.map((l) => (l === "" ? s : [s, l].join("/")))),
    r && o.push(...a),
    o.map((l) => (i.startsWith("/") && l === "" ? "/" : l))
  );
}
function Cd(i) {
  i.sort((e, t) =>
    e.score !== t.score
      ? t.score - e.score
      : Ud(
          e.routesMeta.map((n) => n.childrenIndex),
          t.routesMeta.map((n) => n.childrenIndex),
        ),
  );
}
const wd = /^:[\w-]+$/,
  Rd = 3,
  Dd = 2,
  Pd = 1,
  Fd = 10,
  Bd = -2,
  gl = (i) => i === "*";
function Ld(i, e) {
  let t = i.split("/"),
    n = t.length;
  return (
    t.some(gl) && (n += Bd),
    e && (n += Dd),
    t
      .filter((r) => !gl(r))
      .reduce((r, s) => r + (wd.test(s) ? Rd : s === "" ? Pd : Fd), n)
  );
}
function Ud(i, e) {
  return i.length === e.length && i.slice(0, -1).every((n, r) => n === e[r])
    ? i[i.length - 1] - e[e.length - 1]
    : 0;
}
function Id(i, e, t) {
  t === void 0 && (t = !1);
  let { routesMeta: n } = i,
    r = {},
    s = "/",
    a = [];
  for (let o = 0; o < n.length; ++o) {
    let l = n[o],
      c = o === n.length - 1,
      u = s === "/" ? e : e.slice(s.length) || "/",
      h = _l(
        { path: l.relativePath, caseSensitive: l.caseSensitive, end: c },
        u,
      ),
      f = l.route;
    if (
      (!h &&
        c &&
        t &&
        !n[n.length - 1].route.index &&
        (h = _l(
          { path: l.relativePath, caseSensitive: l.caseSensitive, end: !1 },
          u,
        )),
      !h)
    )
      return null;
    Object.assign(r, h.params),
      a.push({
        params: r,
        pathname: Nr([s, h.pathname]),
        pathnameBase: Gd(Nr([s, h.pathnameBase])),
        route: f,
      }),
      h.pathnameBase !== "/" && (s = Nr([s, h.pathnameBase]));
  }
  return a;
}
function _l(i, e) {
  typeof i == "string" && (i = { path: i, caseSensitive: !1, end: !0 });
  let [t, n] = Nd(i.path, i.caseSensitive, i.end),
    r = e.match(t);
  if (!r) return null;
  let s = r[0],
    a = s.replace(/(.)\/+$/, "$1"),
    o = r.slice(1);
  return {
    params: n.reduce((c, u, h) => {
      let { paramName: f, isOptional: m } = u;
      if (f === "*") {
        let g = o[h] || "";
        a = s.slice(0, s.length - g.length).replace(/(.)\/+$/, "$1");
      }
      const x = o[h];
      return (
        m && !x ? (c[f] = void 0) : (c[f] = (x || "").replace(/%2F/g, "/")), c
      );
    }, {}),
    pathname: s,
    pathnameBase: a,
    pattern: i,
  };
}
function Nd(i, e, t) {
  e === void 0 && (e = !1),
    t === void 0 && (t = !0),
    or(
      i === "*" || !i.endsWith("*") || i.endsWith("/*"),
      'Route path "' +
        i +
        '" will be treated as if it were ' +
        ('"' + i.replace(/\*$/, "/*") + '" because the `*` character must ') +
        "always follow a `/` in the pattern. To get rid of this warning, " +
        ('please change the route path to "' + i.replace(/\*$/, "/*") + '".'),
    );
  let n = [],
    r =
      "^" +
      i
        .replace(/\/*\*?$/, "")
        .replace(/^\/*/, "/")
        .replace(/[\\.*+^${}|()[\]]/g, "\\$&")
        .replace(
          /\/:([\w-]+)(\?)?/g,
          (a, o, l) => (
            n.push({ paramName: o, isOptional: l != null }),
            l ? "/?([^\\/]+)?" : "/([^\\/]+)"
          ),
        );
  return (
    i.endsWith("*")
      ? (n.push({ paramName: "*" }),
        (r += i === "*" || i === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$"))
      : t
        ? (r += "\\/*$")
        : i !== "" && i !== "/" && (r += "(?:(?=\\/|$))"),
    [new RegExp(r, e ? void 0 : "i"), n]
  );
}
function Od(i) {
  try {
    return i
      .split("/")
      .map((e) => decodeURIComponent(e).replace(/\//g, "%2F"))
      .join("/");
  } catch (e) {
    return (
      or(
        !1,
        'The URL path "' +
          i +
          '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' +
          ("encoding (" + e + ")."),
      ),
      i
    );
  }
}
function Ra(i, e) {
  if (e === "/") return i;
  if (!i.toLowerCase().startsWith(e.toLowerCase())) return null;
  let t = e.endsWith("/") ? e.length - 1 : e.length,
    n = i.charAt(t);
  return n && n !== "/" ? null : i.slice(t) || "/";
}
function zd(i, e) {
  e === void 0 && (e = "/");
  let {
    pathname: t,
    search: n = "",
    hash: r = "",
  } = typeof i == "string" ? Ri(i) : i;
  return {
    pathname: t ? (t.startsWith("/") ? t : kd(t, e)) : e,
    search: Wd(n),
    hash: Xd(r),
  };
}
function kd(i, e) {
  let t = e.replace(/\/+$/, "").split("/");
  return (
    i.split("/").forEach((r) => {
      r === ".." ? t.length > 1 && t.pop() : r !== "." && t.push(r);
    }),
    t.length > 1 ? t.join("/") : "/"
  );
}
function qa(i, e, t, n) {
  return (
    "Cannot include a '" +
    i +
    "' character in a manually specified " +
    ("`to." +
      e +
      "` field [" +
      JSON.stringify(n) +
      "].  Please separate it out to the ") +
    ("`to." + t + "` field. Alternatively you may provide the full path as ") +
    'a string in <Link to="..."> and the router will parse it for you.'
  );
}
function kf(i) {
  return i.filter(
    (e, t) => t === 0 || (e.route.path && e.route.path.length > 0),
  );
}
function Hd(i, e) {
  let t = kf(i);
  return e
    ? t.map((n, r) => (r === t.length - 1 ? n.pathname : n.pathnameBase))
    : t.map((n) => n.pathnameBase);
}
function Vd(i, e, t, n) {
  n === void 0 && (n = !1);
  let r;
  typeof i == "string"
    ? (r = Ri(i))
    : ((r = Rt({}, i)),
      At(
        !r.pathname || !r.pathname.includes("?"),
        qa("?", "pathname", "search", r),
      ),
      At(
        !r.pathname || !r.pathname.includes("#"),
        qa("#", "pathname", "hash", r),
      ),
      At(!r.search || !r.search.includes("#"), qa("#", "search", "hash", r)));
  let s = i === "" || r.pathname === "",
    a = s ? "/" : r.pathname,
    o;
  if (a == null) o = t;
  else {
    let h = e.length - 1;
    if (!n && a.startsWith("..")) {
      let f = a.split("/");
      for (; f[0] === ".."; ) f.shift(), (h -= 1);
      r.pathname = f.join("/");
    }
    o = h >= 0 ? e[h] : "/";
  }
  let l = zd(r, o),
    c = a && a !== "/" && a.endsWith("/"),
    u = (s || a === ".") && t.endsWith("/");
  return !l.pathname.endsWith("/") && (c || u) && (l.pathname += "/"), l;
}
const Nr = (i) => i.join("/").replace(/\/\/+/g, "/"),
  Gd = (i) => i.replace(/\/+$/, "").replace(/^\/*/, "/"),
  Wd = (i) => (!i || i === "?" ? "" : i.startsWith("?") ? i : "?" + i),
  Xd = (i) => (!i || i === "#" ? "" : i.startsWith("#") ? i : "#" + i);
class Io {
  constructor(e, t, n, r) {
    r === void 0 && (r = !1),
      (this.status = e),
      (this.statusText = t || ""),
      (this.internal = r),
      n instanceof Error
        ? ((this.data = n.toString()), (this.error = n))
        : (this.data = n);
  }
}
function Aa(i) {
  return (
    i != null &&
    typeof i.status == "number" &&
    typeof i.statusText == "string" &&
    typeof i.internal == "boolean" &&
    "data" in i
  );
}
const Hf = ["post", "put", "patch", "delete"],
  qd = new Set(Hf),
  Yd = ["get", ...Hf],
  $d = new Set(Yd),
  jd = new Set([301, 302, 303, 307, 308]),
  Kd = new Set([307, 308]),
  Ya = {
    state: "idle",
    location: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
  },
  Zd = {
    state: "idle",
    data: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
  },
  Sr = { state: "unblocked", proceed: void 0, reset: void 0, location: void 0 },
  zc = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  Jd = (i) => ({ hasErrorBoundary: !!i.hasErrorBoundary }),
  Vf = "remix-router-transitions";
function hS(i) {
  const e = i.window
      ? i.window
      : typeof window != "undefined"
        ? window
        : void 0,
    t =
      typeof e != "undefined" &&
      typeof e.document != "undefined" &&
      typeof e.document.createElement != "undefined",
    n = !t;
  At(
    i.routes.length > 0,
    "You must provide a non-empty routes array to createRouter",
  );
  let r;
  if (i.mapRouteProperties) r = i.mapRouteProperties;
  else if (i.detectErrorBoundary) {
    let U = i.detectErrorBoundary;
    r = (O) => ({ hasErrorBoundary: U(O) });
  } else r = Jd;
  let s = {},
    a = Ma(i.routes, r, void 0, s),
    o,
    l = i.basename || "/",
    c = i.dataStrategy || n0,
    u = i.patchRoutesOnNavigation,
    h = Rt(
      {
        v7_fetcherPersist: !1,
        v7_normalizeFormMethod: !1,
        v7_partialHydration: !1,
        v7_prependBasename: !1,
        v7_relativeSplatPath: !1,
        v7_skipActionErrorRevalidation: !1,
      },
      i.future,
    ),
    f = null,
    m = new Set(),
    x = null,
    g = null,
    d = null,
    p = i.hydrationData != null,
    y = er(a, i.history.location, l),
    E = !1,
    v = null;
  if (y == null && !u) {
    let U = Jt(404, { pathname: i.history.location.pathname }),
      { matches: O, route: Y } = Rl(a);
    (y = O), (v = { [Y.id]: U });
  }
  y &&
    !i.hydrationData &&
    Dt(y, a, i.history.location.pathname).active &&
    (y = null);
  let C;
  if (y)
    if (y.some((U) => U.route.lazy)) C = !1;
    else if (!y.some((U) => U.route.loader)) C = !0;
    else if (h.v7_partialHydration) {
      let U = i.hydrationData ? i.hydrationData.loaderData : null,
        O = i.hydrationData ? i.hydrationData.errors : null;
      if (O) {
        let Y = y.findIndex((oe) => O[oe.route.id] !== void 0);
        C = y.slice(0, Y + 1).every((oe) => !Oo(oe.route, U, O));
      } else C = y.every((Y) => !Oo(Y.route, U, O));
    } else C = i.hydrationData != null;
  else if (((C = !1), (y = []), h.v7_partialHydration)) {
    let U = Dt(null, a, i.history.location.pathname);
    U.active && U.matches && ((E = !0), (y = U.matches));
  }
  let A,
    S = {
      historyAction: i.history.action,
      location: i.history.location,
      matches: y,
      initialized: C,
      navigation: Ya,
      restoreScrollPosition: i.hydrationData != null ? !1 : null,
      preventScrollReset: !1,
      revalidation: "idle",
      loaderData: (i.hydrationData && i.hydrationData.loaderData) || {},
      actionData: (i.hydrationData && i.hydrationData.actionData) || null,
      errors: (i.hydrationData && i.hydrationData.errors) || v,
      fetchers: new Map(),
      blockers: new Map(),
    },
    R = It.Pop,
    M = !1,
    _,
    T = !1,
    F = new Map(),
    P = null,
    I = !1,
    X = !1,
    V = [],
    ie = new Set(),
    k = new Map(),
    ae = 0,
    ce = -1,
    H = new Map(),
    K = new Set(),
    Q = new Map(),
    B = new Map(),
    te = new Set(),
    fe = new Map(),
    he = new Map(),
    de;
  function Qe() {
    if (
      ((f = i.history.listen((U) => {
        let { action: O, location: Y, delta: oe } = U;
        if (de) {
          de(), (de = void 0);
          return;
        }
        or(
          he.size === 0 || oe != null,
          "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.",
        );
        let me = ge({
          currentLocation: S.location,
          nextLocation: Y,
          historyAction: O,
        });
        if (me && oe != null) {
          let Ne = new Promise((He) => {
            de = He;
          });
          i.history.go(oe * -1),
            N(me, {
              state: "blocked",
              location: Y,
              proceed() {
                N(me, {
                  state: "proceeding",
                  proceed: void 0,
                  reset: void 0,
                  location: Y,
                }),
                  Ne.then(() => i.history.go(oe));
              },
              reset() {
                let He = new Map(S.blockers);
                He.set(me, Sr), Xe({ blockers: He });
              },
            });
          return;
        }
        return We(O, Y);
      })),
      t)
    ) {
      x0(e, F);
      let U = () => g0(e, F);
      e.addEventListener("pagehide", U),
        (P = () => e.removeEventListener("pagehide", U));
    }
    return S.initialized || We(It.Pop, S.location, { initialHydration: !0 }), A;
  }
  function Oe() {
    f && f(),
      P && P(),
      m.clear(),
      _ && _.abort(),
      S.fetchers.forEach((U, O) => le(O)),
      S.blockers.forEach((U, O) => dt(O));
  }
  function St(U) {
    return m.add(U), () => m.delete(U);
  }
  function Xe(U, O) {
    O === void 0 && (O = {}), (S = Rt({}, S, U));
    let Y = [],
      oe = [];
    h.v7_fetcherPersist &&
      S.fetchers.forEach((me, Ne) => {
        me.state === "idle" && (te.has(Ne) ? oe.push(Ne) : Y.push(Ne));
      }),
      te.forEach((me) => {
        !S.fetchers.has(me) && !k.has(me) && oe.push(me);
      }),
      [...m].forEach((me) =>
        me(S, {
          deletedFetchers: oe,
          viewTransitionOpts: O.viewTransitionOpts,
          flushSync: O.flushSync === !0,
        }),
      ),
      h.v7_fetcherPersist
        ? (Y.forEach((me) => S.fetchers.delete(me)), oe.forEach((me) => le(me)))
        : oe.forEach((me) => te.delete(me));
  }
  function ze(U, O, Y) {
    var oe, me;
    let { flushSync: Ne } = Y === void 0 ? {} : Y,
      He =
        S.actionData != null &&
        S.navigation.formMethod != null &&
        En(S.navigation.formMethod) &&
        S.navigation.state === "loading" &&
        ((oe = U.state) == null ? void 0 : oe._isRedirect) !== !0,
      De;
    O.actionData
      ? Object.keys(O.actionData).length > 0
        ? (De = O.actionData)
        : (De = null)
      : He
        ? (De = S.actionData)
        : (De = null);
    let Pe = O.loaderData
        ? Cl(S.loaderData, O.loaderData, O.matches || [], O.errors)
        : S.loaderData,
      Ce = S.blockers;
    Ce.size > 0 && ((Ce = new Map(Ce)), Ce.forEach((st, Ut) => Ce.set(Ut, Sr)));
    let Ue =
      M === !0 ||
      (S.navigation.formMethod != null &&
        En(S.navigation.formMethod) &&
        ((me = U.state) == null ? void 0 : me._isRedirect) !== !0);
    o && ((a = o), (o = void 0)),
      I ||
        R === It.Pop ||
        (R === It.Push
          ? i.history.push(U, U.state)
          : R === It.Replace && i.history.replace(U, U.state));
    let $e;
    if (R === It.Pop) {
      let st = F.get(S.location.pathname);
      st && st.has(U.pathname)
        ? ($e = { currentLocation: S.location, nextLocation: U })
        : F.has(U.pathname) &&
          ($e = { currentLocation: U, nextLocation: S.location });
    } else if (T) {
      let st = F.get(S.location.pathname);
      st
        ? st.add(U.pathname)
        : ((st = new Set([U.pathname])), F.set(S.location.pathname, st)),
        ($e = { currentLocation: S.location, nextLocation: U });
    }
    Xe(
      Rt({}, O, {
        actionData: De,
        loaderData: Pe,
        historyAction: R,
        location: U,
        initialized: !0,
        navigation: Ya,
        revalidation: "idle",
        restoreScrollPosition: gt(U, O.matches || S.matches),
        preventScrollReset: Ue,
        blockers: Ce,
      }),
      { viewTransitionOpts: $e, flushSync: Ne === !0 },
    ),
      (R = It.Pop),
      (M = !1),
      (T = !1),
      (I = !1),
      (X = !1),
      (V = []);
  }
  async function L(U, O) {
    if (typeof U == "number") {
      i.history.go(U);
      return;
    }
    let Y = No(
        S.location,
        S.matches,
        l,
        h.v7_prependBasename,
        U,
        h.v7_relativeSplatPath,
        O == null ? void 0 : O.fromRouteId,
        O == null ? void 0 : O.relative,
      ),
      {
        path: oe,
        submission: me,
        error: Ne,
      } = vl(h.v7_normalizeFormMethod, !1, Y, O),
      He = S.location,
      De = Or(S.location, oe, O && O.state);
    De = Rt({}, De, i.history.encodeLocation(De));
    let Pe = O && O.replace != null ? O.replace : void 0,
      Ce = It.Push;
    Pe === !0
      ? (Ce = It.Replace)
      : Pe === !1 ||
        (me != null &&
          En(me.formMethod) &&
          me.formAction === S.location.pathname + S.location.search &&
          (Ce = It.Replace));
    let Ue =
        O && "preventScrollReset" in O ? O.preventScrollReset === !0 : void 0,
      $e = (O && O.flushSync) === !0,
      st = ge({ currentLocation: He, nextLocation: De, historyAction: Ce });
    if (st) {
      N(st, {
        state: "blocked",
        location: De,
        proceed() {
          N(st, {
            state: "proceeding",
            proceed: void 0,
            reset: void 0,
            location: De,
          }),
            L(U, O);
        },
        reset() {
          let Ut = new Map(S.blockers);
          Ut.set(st, Sr), Xe({ blockers: Ut });
        },
      });
      return;
    }
    return await We(Ce, De, {
      submission: me,
      pendingError: Ne,
      preventScrollReset: Ue,
      replace: O && O.replace,
      enableViewTransition: O && O.viewTransition,
      flushSync: $e,
    });
  }
  function Lt() {
    if (
      (Re(),
      Xe({ revalidation: "loading" }),
      S.navigation.state !== "submitting")
    ) {
      if (S.navigation.state === "idle") {
        We(S.historyAction, S.location, { startUninterruptedRevalidation: !0 });
        return;
      }
      We(R || S.historyAction, S.navigation.location, {
        overrideNavigation: S.navigation,
        enableViewTransition: T === !0,
      });
    }
  }
  async function We(U, O, Y) {
    _ && _.abort(),
      (_ = null),
      (R = U),
      (I = (Y && Y.startUninterruptedRevalidation) === !0),
      qe(S.location, S.matches),
      (M = (Y && Y.preventScrollReset) === !0),
      (T = (Y && Y.enableViewTransition) === !0);
    let oe = o || a,
      me = Y && Y.overrideNavigation,
      Ne =
        Y != null &&
        Y.initialHydration &&
        S.matches &&
        S.matches.length > 0 &&
        !E
          ? S.matches
          : er(oe, O, l),
      He = (Y && Y.flushSync) === !0;
    if (
      Ne &&
      S.initialized &&
      !X &&
      c0(S.location, O) &&
      !(Y && Y.submission && En(Y.submission.formMethod))
    ) {
      ze(O, { matches: Ne }, { flushSync: He });
      return;
    }
    let De = Dt(Ne, oe, O.pathname);
    if ((De.active && De.matches && (Ne = De.matches), !Ne)) {
      let { error: _t, notFoundMatches: ft, route: Ct } = J(O.pathname);
      ze(
        O,
        { matches: ft, loaderData: {}, errors: { [Ct.id]: _t } },
        { flushSync: He },
      );
      return;
    }
    _ = new AbortController();
    let Pe = Ui(i.history, O, _.signal, Y && Y.submission),
      Ce;
    if (Y && Y.pendingError)
      Ce = [_i(Ne).route.id, { type: xt.error, error: Y.pendingError }];
    else if (Y && Y.submission && En(Y.submission.formMethod)) {
      let _t = await Ke(Pe, O, Y.submission, Ne, De.active, {
        replace: Y.replace,
        flushSync: He,
      });
      if (_t.shortCircuited) return;
      if (_t.pendingActionResult) {
        let [ft, Ct] = _t.pendingActionResult;
        if (on(Ct) && Aa(Ct.error) && Ct.error.status === 404) {
          (_ = null),
            ze(O, {
              matches: _t.matches,
              loaderData: {},
              errors: { [ft]: Ct.error },
            });
          return;
        }
      }
      (Ne = _t.matches || Ne),
        (Ce = _t.pendingActionResult),
        (me = $a(O, Y.submission)),
        (He = !1),
        (De.active = !1),
        (Pe = Ui(i.history, Pe.url, Pe.signal));
    }
    let {
      shortCircuited: Ue,
      matches: $e,
      loaderData: st,
      errors: Ut,
    } = await Be(
      Pe,
      O,
      Ne,
      De.active,
      me,
      Y && Y.submission,
      Y && Y.fetcherSubmission,
      Y && Y.replace,
      Y && Y.initialHydration === !0,
      He,
      Ce,
    );
    Ue ||
      ((_ = null),
      ze(O, Rt({ matches: $e || Ne }, wl(Ce), { loaderData: st, errors: Ut })));
  }
  async function Ke(U, O, Y, oe, me, Ne) {
    Ne === void 0 && (Ne = {}), Re();
    let He = p0(O, Y);
    if ((Xe({ navigation: He }, { flushSync: Ne.flushSync === !0 }), me)) {
      let Ce = await rt(oe, O.pathname, U.signal);
      if (Ce.type === "aborted") return { shortCircuited: !0 };
      if (Ce.type === "error") {
        let Ue = _i(Ce.partialMatches).route.id;
        return {
          matches: Ce.partialMatches,
          pendingActionResult: [Ue, { type: xt.error, error: Ce.error }],
        };
      } else if (Ce.matches) oe = Ce.matches;
      else {
        let { notFoundMatches: Ue, error: $e, route: st } = J(O.pathname);
        return {
          matches: Ue,
          pendingActionResult: [st.id, { type: xt.error, error: $e }],
        };
      }
    }
    let De,
      Pe = Lr(oe, O);
    if (!Pe.route.action && !Pe.route.lazy)
      De = {
        type: xt.error,
        error: Jt(405, {
          method: U.method,
          pathname: O.pathname,
          routeId: Pe.route.id,
        }),
      };
    else if (
      ((De = (await se("action", S, U, [Pe], oe, null))[Pe.route.id]),
      U.signal.aborted)
    )
      return { shortCircuited: !0 };
    if (yi(De)) {
      let Ce;
      return (
        Ne && Ne.replace != null
          ? (Ce = Ne.replace)
          : (Ce =
              Al(De.response.headers.get("Location"), new URL(U.url), l) ===
              S.location.pathname + S.location.search),
        await ne(U, De, !0, { submission: Y, replace: Ce }),
        { shortCircuited: !0 }
      );
    }
    if (ei(De)) throw Jt(400, { type: "defer-action" });
    if (on(De)) {
      let Ce = _i(oe, Pe.route.id);
      return (
        (Ne && Ne.replace) !== !0 && (R = It.Push),
        { matches: oe, pendingActionResult: [Ce.route.id, De] }
      );
    }
    return { matches: oe, pendingActionResult: [Pe.route.id, De] };
  }
  async function Be(U, O, Y, oe, me, Ne, He, De, Pe, Ce, Ue) {
    let $e = me || $a(O, Ne),
      st = Ne || He || Pl($e),
      Ut = !I && (!h.v7_partialHydration || !Pe);
    if (oe) {
      if (Ut) {
        let we = ht(Ue);
        Xe(Rt({ navigation: $e }, we !== void 0 ? { actionData: we } : {}), {
          flushSync: Ce,
        });
      }
      let _e = await rt(Y, O.pathname, U.signal);
      if (_e.type === "aborted") return { shortCircuited: !0 };
      if (_e.type === "error") {
        let we = _i(_e.partialMatches).route.id;
        return {
          matches: _e.partialMatches,
          loaderData: {},
          errors: { [we]: _e.error },
        };
      } else if (_e.matches) Y = _e.matches;
      else {
        let { error: we, notFoundMatches: Ie, route: nt } = J(O.pathname);
        return { matches: Ie, loaderData: {}, errors: { [nt.id]: we } };
      }
    }
    let _t = o || a,
      [ft, Ct] = yl(
        i.history,
        S,
        Y,
        st,
        O,
        h.v7_partialHydration && Pe === !0,
        h.v7_skipActionErrorRevalidation,
        X,
        V,
        ie,
        te,
        Q,
        K,
        _t,
        l,
        Ue,
      );
    if (
      (re(
        (_e) =>
          !(Y && Y.some((we) => we.route.id === _e)) ||
          (ft && ft.some((we) => we.route.id === _e)),
      ),
      (ce = ++ae),
      ft.length === 0 && Ct.length === 0)
    ) {
      let _e = be();
      return (
        ze(
          O,
          Rt(
            {
              matches: Y,
              loaderData: {},
              errors: Ue && on(Ue[1]) ? { [Ue[0]]: Ue[1].error } : null,
            },
            wl(Ue),
            _e ? { fetchers: new Map(S.fetchers) } : {},
          ),
          { flushSync: Ce },
        ),
        { shortCircuited: !0 }
      );
    }
    if (Ut) {
      let _e = {};
      if (!oe) {
        _e.navigation = $e;
        let we = ht(Ue);
        we !== void 0 && (_e.actionData = we);
      }
      Ct.length > 0 && (_e.fetchers = Fe(Ct)), Xe(_e, { flushSync: Ce });
    }
    Ct.forEach((_e) => {
      Le(_e.key), _e.controller && k.set(_e.key, _e.controller);
    });
    let w = () => Ct.forEach((_e) => Le(_e.key));
    _ && _.signal.addEventListener("abort", w);
    let { loaderResults: z, fetcherResults: $ } = await ee(S, Y, ft, Ct, U);
    if (U.signal.aborted) return { shortCircuited: !0 };
    _ && _.signal.removeEventListener("abort", w),
      Ct.forEach((_e) => k.delete(_e.key));
    let j = Kr(z);
    if (j)
      return await ne(U, j.result, !0, { replace: De }), { shortCircuited: !0 };
    if (((j = Kr($)), j))
      return (
        K.add(j.key),
        await ne(U, j.result, !0, { replace: De }),
        { shortCircuited: !0 }
      );
    let { loaderData: G, errors: ue } = Tl(S, Y, z, Ue, Ct, $, fe);
    fe.forEach((_e, we) => {
      _e.subscribe((Ie) => {
        (Ie || _e.done) && fe.delete(we);
      });
    }),
      h.v7_partialHydration && Pe && S.errors && (ue = Rt({}, S.errors, ue));
    let xe = be(),
      Ae = tt(ce),
      Te = xe || Ae || Ct.length > 0;
    return Rt(
      { matches: Y, loaderData: G, errors: ue },
      Te ? { fetchers: new Map(S.fetchers) } : {},
    );
  }
  function ht(U) {
    if (U && !on(U[1])) return { [U[0]]: U[1].data };
    if (S.actionData)
      return Object.keys(S.actionData).length === 0 ? null : S.actionData;
  }
  function Fe(U) {
    return (
      U.forEach((O) => {
        let Y = S.fetchers.get(O.key),
          oe = Mr(void 0, Y ? Y.data : void 0);
        S.fetchers.set(O.key, oe);
      }),
      new Map(S.fetchers)
    );
  }
  function D(U, O, Y, oe) {
    if (n)
      throw new Error(
        "router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.",
      );
    Le(U);
    let me = (oe && oe.flushSync) === !0,
      Ne = o || a,
      He = No(
        S.location,
        S.matches,
        l,
        h.v7_prependBasename,
        Y,
        h.v7_relativeSplatPath,
        O,
        oe == null ? void 0 : oe.relative,
      ),
      De = er(Ne, He, l),
      Pe = Dt(De, Ne, He);
    if ((Pe.active && Pe.matches && (De = Pe.matches), !De)) {
      ve(U, O, Jt(404, { pathname: He }), { flushSync: me });
      return;
    }
    let {
      path: Ce,
      submission: Ue,
      error: $e,
    } = vl(h.v7_normalizeFormMethod, !0, He, oe);
    if ($e) {
      ve(U, O, $e, { flushSync: me });
      return;
    }
    let st = Lr(De, Ce),
      Ut = (oe && oe.preventScrollReset) === !0;
    if (Ue && En(Ue.formMethod)) {
      b(U, O, Ce, st, De, Pe.active, me, Ut, Ue);
      return;
    }
    Q.set(U, { routeId: O, path: Ce }),
      q(U, O, Ce, st, De, Pe.active, me, Ut, Ue);
  }
  async function b(U, O, Y, oe, me, Ne, He, De, Pe) {
    Re(), Q.delete(U);
    function Ce(Ve) {
      if (!Ve.route.action && !Ve.route.lazy) {
        let Mt = Jt(405, { method: Pe.formMethod, pathname: Y, routeId: O });
        return ve(U, O, Mt, { flushSync: He }), !0;
      }
      return !1;
    }
    if (!Ne && Ce(oe)) return;
    let Ue = S.fetchers.get(U);
    pe(U, m0(Pe, Ue), { flushSync: He });
    let $e = new AbortController(),
      st = Ui(i.history, Y, $e.signal, Pe);
    if (Ne) {
      let Ve = await rt(me, new URL(st.url).pathname, st.signal, U);
      if (Ve.type === "aborted") return;
      if (Ve.type === "error") {
        ve(U, O, Ve.error, { flushSync: He });
        return;
      } else if (Ve.matches) {
        if (((me = Ve.matches), (oe = Lr(me, Y)), Ce(oe))) return;
      } else {
        ve(U, O, Jt(404, { pathname: Y }), { flushSync: He });
        return;
      }
    }
    k.set(U, $e);
    let Ut = ae,
      ft = (await se("action", S, st, [oe], me, U))[oe.route.id];
    if (st.signal.aborted) {
      k.get(U) === $e && k.delete(U);
      return;
    }
    if (h.v7_fetcherPersist && te.has(U)) {
      if (yi(ft) || on(ft)) {
        pe(U, Jn(void 0));
        return;
      }
    } else {
      if (yi(ft))
        if ((k.delete(U), ce > Ut)) {
          pe(U, Jn(void 0));
          return;
        } else
          return (
            K.add(U),
            pe(U, Mr(Pe)),
            ne(st, ft, !1, { fetcherSubmission: Pe, preventScrollReset: De })
          );
      if (on(ft)) {
        ve(U, O, ft.error);
        return;
      }
    }
    if (ei(ft)) throw Jt(400, { type: "defer-action" });
    let Ct = S.navigation.location || S.location,
      w = Ui(i.history, Ct, $e.signal),
      z = o || a,
      $ =
        S.navigation.state !== "idle"
          ? er(z, S.navigation.location, l)
          : S.matches;
    At($, "Didn't find any matches after fetcher action");
    let j = ++ae;
    H.set(U, j);
    let G = Mr(Pe, ft.data);
    S.fetchers.set(U, G);
    let [ue, xe] = yl(
      i.history,
      S,
      $,
      Pe,
      Ct,
      !1,
      h.v7_skipActionErrorRevalidation,
      X,
      V,
      ie,
      te,
      Q,
      K,
      z,
      l,
      [oe.route.id, ft],
    );
    xe
      .filter((Ve) => Ve.key !== U)
      .forEach((Ve) => {
        let Mt = Ve.key,
          bt = S.fetchers.get(Mt),
          lt = Mr(void 0, bt ? bt.data : void 0);
        S.fetchers.set(Mt, lt),
          Le(Mt),
          Ve.controller && k.set(Mt, Ve.controller);
      }),
      Xe({ fetchers: new Map(S.fetchers) });
    let Ae = () => xe.forEach((Ve) => Le(Ve.key));
    $e.signal.addEventListener("abort", Ae);
    let { loaderResults: Te, fetcherResults: _e } = await ee(S, $, ue, xe, w);
    if ($e.signal.aborted) return;
    $e.signal.removeEventListener("abort", Ae),
      H.delete(U),
      k.delete(U),
      xe.forEach((Ve) => k.delete(Ve.key));
    let we = Kr(Te);
    if (we) return ne(w, we.result, !1, { preventScrollReset: De });
    if (((we = Kr(_e)), we))
      return K.add(we.key), ne(w, we.result, !1, { preventScrollReset: De });
    let { loaderData: Ie, errors: nt } = Tl(S, $, Te, void 0, xe, _e, fe);
    if (S.fetchers.has(U)) {
      let Ve = Jn(ft.data);
      S.fetchers.set(U, Ve);
    }
    tt(j),
      S.navigation.state === "loading" && j > ce
        ? (At(R, "Expected pending action"),
          _ && _.abort(),
          ze(S.navigation.location, {
            matches: $,
            loaderData: Ie,
            errors: nt,
            fetchers: new Map(S.fetchers),
          }))
        : (Xe({
            errors: nt,
            loaderData: Cl(S.loaderData, Ie, $, nt),
            fetchers: new Map(S.fetchers),
          }),
          (X = !1));
  }
  async function q(U, O, Y, oe, me, Ne, He, De, Pe) {
    let Ce = S.fetchers.get(U);
    pe(U, Mr(Pe, Ce ? Ce.data : void 0), { flushSync: He });
    let Ue = new AbortController(),
      $e = Ui(i.history, Y, Ue.signal);
    if (Ne) {
      let ft = await rt(me, new URL($e.url).pathname, $e.signal, U);
      if (ft.type === "aborted") return;
      if (ft.type === "error") {
        ve(U, O, ft.error, { flushSync: He });
        return;
      } else if (ft.matches) (me = ft.matches), (oe = Lr(me, Y));
      else {
        ve(U, O, Jt(404, { pathname: Y }), { flushSync: He });
        return;
      }
    }
    k.set(U, Ue);
    let st = ae,
      _t = (await se("loader", S, $e, [oe], me, U))[oe.route.id];
    if (
      (ei(_t) && (_t = (await kc(_t, $e.signal, !0)) || _t),
      k.get(U) === Ue && k.delete(U),
      !$e.signal.aborted)
    ) {
      if (te.has(U)) {
        pe(U, Jn(void 0));
        return;
      }
      if (yi(_t))
        if (ce > st) {
          pe(U, Jn(void 0));
          return;
        } else {
          K.add(U), await ne($e, _t, !1, { preventScrollReset: De });
          return;
        }
      if (on(_t)) {
        ve(U, O, _t.error);
        return;
      }
      At(!ei(_t), "Unhandled fetcher deferred data"), pe(U, Jn(_t.data));
    }
  }
  async function ne(U, O, Y, oe) {
    let {
      submission: me,
      fetcherSubmission: Ne,
      preventScrollReset: He,
      replace: De,
    } = oe === void 0 ? {} : oe;
    O.response.headers.has("X-Remix-Revalidate") && (X = !0);
    let Pe = O.response.headers.get("Location");
    At(Pe, "Expected a Location header on the redirect Response"),
      (Pe = Al(Pe, new URL(U.url), l));
    let Ce = Or(S.location, Pe, { _isRedirect: !0 });
    if (t) {
      let ft = !1;
      if (O.response.headers.has("X-Remix-Reload-Document")) ft = !0;
      else if (zc.test(Pe)) {
        const Ct = i.history.createURL(Pe);
        ft = Ct.origin !== e.location.origin || Ra(Ct.pathname, l) == null;
      }
      if (ft) {
        De ? e.location.replace(Pe) : e.location.assign(Pe);
        return;
      }
    }
    _ = null;
    let Ue =
        De === !0 || O.response.headers.has("X-Remix-Replace")
          ? It.Replace
          : It.Push,
      { formMethod: $e, formAction: st, formEncType: Ut } = S.navigation;
    !me && !Ne && $e && st && Ut && (me = Pl(S.navigation));
    let _t = me || Ne;
    if (Kd.has(O.response.status) && _t && En(_t.formMethod))
      await We(Ue, Ce, {
        submission: Rt({}, _t, { formAction: Pe }),
        preventScrollReset: He || M,
        enableViewTransition: Y ? T : void 0,
      });
    else {
      let ft = $a(Ce, me);
      await We(Ue, Ce, {
        overrideNavigation: ft,
        fetcherSubmission: Ne,
        preventScrollReset: He || M,
        enableViewTransition: Y ? T : void 0,
      });
    }
  }
  async function se(U, O, Y, oe, me, Ne) {
    let He,
      De = {};
    try {
      He = await i0(c, U, O, Y, oe, me, Ne, s, r);
    } catch (Pe) {
      return (
        oe.forEach((Ce) => {
          De[Ce.route.id] = { type: xt.error, error: Pe };
        }),
        De
      );
    }
    for (let [Pe, Ce] of Object.entries(He))
      if (l0(Ce)) {
        let Ue = Ce.result;
        De[Pe] = {
          type: xt.redirect,
          response: a0(Ue, Y, Pe, me, l, h.v7_relativeSplatPath),
        };
      } else De[Pe] = await s0(Ce);
    return De;
  }
  async function ee(U, O, Y, oe, me) {
    let Ne = U.matches,
      He = se("loader", U, me, Y, O, null),
      De = Promise.all(
        oe.map(async (Ue) => {
          if (Ue.matches && Ue.match && Ue.controller) {
            let st = (
              await se(
                "loader",
                U,
                Ui(i.history, Ue.path, Ue.controller.signal),
                [Ue.match],
                Ue.matches,
                Ue.key,
              )
            )[Ue.match.route.id];
            return { [Ue.key]: st };
          } else
            return Promise.resolve({
              [Ue.key]: {
                type: xt.error,
                error: Jt(404, { pathname: Ue.path }),
              },
            });
        }),
      ),
      Pe = await He,
      Ce = (await De).reduce((Ue, $e) => Object.assign(Ue, $e), {});
    return (
      await Promise.all([
        h0(O, Pe, me.signal, Ne, U.loaderData),
        d0(O, Ce, oe),
      ]),
      { loaderResults: Pe, fetcherResults: Ce }
    );
  }
  function Re() {
    (X = !0),
      V.push(...re()),
      Q.forEach((U, O) => {
        k.has(O) && ie.add(O), Le(O);
      });
  }
  function pe(U, O, Y) {
    Y === void 0 && (Y = {}),
      S.fetchers.set(U, O),
      Xe(
        { fetchers: new Map(S.fetchers) },
        { flushSync: (Y && Y.flushSync) === !0 },
      );
  }
  function ve(U, O, Y, oe) {
    oe === void 0 && (oe = {});
    let me = _i(S.matches, O);
    le(U),
      Xe(
        { errors: { [me.route.id]: Y }, fetchers: new Map(S.fetchers) },
        { flushSync: (oe && oe.flushSync) === !0 },
      );
  }
  function et(U) {
    return (
      B.set(U, (B.get(U) || 0) + 1),
      te.has(U) && te.delete(U),
      S.fetchers.get(U) || Zd
    );
  }
  function le(U) {
    let O = S.fetchers.get(U);
    k.has(U) && !(O && O.state === "loading" && H.has(U)) && Le(U),
      Q.delete(U),
      H.delete(U),
      K.delete(U),
      h.v7_fetcherPersist && te.delete(U),
      ie.delete(U),
      S.fetchers.delete(U);
  }
  function Me(U) {
    let O = (B.get(U) || 0) - 1;
    O <= 0
      ? (B.delete(U), te.add(U), h.v7_fetcherPersist || le(U))
      : B.set(U, O),
      Xe({ fetchers: new Map(S.fetchers) });
  }
  function Le(U) {
    let O = k.get(U);
    O && (O.abort(), k.delete(U));
  }
  function ke(U) {
    for (let O of U) {
      let Y = et(O),
        oe = Jn(Y.data);
      S.fetchers.set(O, oe);
    }
  }
  function be() {
    let U = [],
      O = !1;
    for (let Y of K) {
      let oe = S.fetchers.get(Y);
      At(oe, "Expected fetcher: " + Y),
        oe.state === "loading" && (K.delete(Y), U.push(Y), (O = !0));
    }
    return ke(U), O;
  }
  function tt(U) {
    let O = [];
    for (let [Y, oe] of H)
      if (oe < U) {
        let me = S.fetchers.get(Y);
        At(me, "Expected fetcher: " + Y),
          me.state === "loading" && (Le(Y), H.delete(Y), O.push(Y));
      }
    return ke(O), O.length > 0;
  }
  function Ye(U, O) {
    let Y = S.blockers.get(U) || Sr;
    return he.get(U) !== O && he.set(U, O), Y;
  }
  function dt(U) {
    S.blockers.delete(U), he.delete(U);
  }
  function N(U, O) {
    let Y = S.blockers.get(U) || Sr;
    At(
      (Y.state === "unblocked" && O.state === "blocked") ||
        (Y.state === "blocked" && O.state === "blocked") ||
        (Y.state === "blocked" && O.state === "proceeding") ||
        (Y.state === "blocked" && O.state === "unblocked") ||
        (Y.state === "proceeding" && O.state === "unblocked"),
      "Invalid blocker state transition: " + Y.state + " -> " + O.state,
    );
    let oe = new Map(S.blockers);
    oe.set(U, O), Xe({ blockers: oe });
  }
  function ge(U) {
    let { currentLocation: O, nextLocation: Y, historyAction: oe } = U;
    if (he.size === 0) return;
    he.size > 1 && or(!1, "A router only supports one blocker at a time");
    let me = Array.from(he.entries()),
      [Ne, He] = me[me.length - 1],
      De = S.blockers.get(Ne);
    if (
      !(De && De.state === "proceeding") &&
      He({ currentLocation: O, nextLocation: Y, historyAction: oe })
    )
      return Ne;
  }
  function J(U) {
    let O = Jt(404, { pathname: U }),
      Y = o || a,
      { matches: oe, route: me } = Rl(Y);
    return re(), { notFoundMatches: oe, route: me, error: O };
  }
  function re(U) {
    let O = [];
    return (
      fe.forEach((Y, oe) => {
        (!U || U(oe)) && (Y.cancel(), O.push(oe), fe.delete(oe));
      }),
      O
    );
  }
  function Se(U, O, Y) {
    if (((x = U), (d = O), (g = Y || null), !p && S.navigation === Ya)) {
      p = !0;
      let oe = gt(S.location, S.matches);
      oe != null && Xe({ restoreScrollPosition: oe });
    }
    return () => {
      (x = null), (d = null), (g = null);
    };
  }
  function Ee(U, O) {
    return (
      (g &&
        g(
          U,
          O.map((oe) => Td(oe, S.loaderData)),
        )) ||
      U.key
    );
  }
  function qe(U, O) {
    if (x && d) {
      let Y = Ee(U, O);
      x[Y] = d();
    }
  }
  function gt(U, O) {
    if (x) {
      let Y = Ee(U, O),
        oe = x[Y];
      if (typeof oe == "number") return oe;
    }
    return null;
  }
  function Dt(U, O, Y) {
    if (u)
      if (U) {
        if (Object.keys(U[0].params).length > 0)
          return { active: !0, matches: Cs(O, Y, l, !0) };
      } else return { active: !0, matches: Cs(O, Y, l, !0) || [] };
    return { active: !1, matches: null };
  }
  async function rt(U, O, Y, oe) {
    if (!u) return { type: "success", matches: U };
    let me = U;
    for (;;) {
      let Ne = o == null,
        He = o || a,
        De = s;
      try {
        await u({
          signal: Y,
          path: O,
          matches: me,
          fetcherKey: oe,
          patch: (Ue, $e) => {
            Y.aborted || Ml(Ue, $e, He, De, r);
          },
        });
      } catch (Ue) {
        return { type: "error", error: Ue, partialMatches: me };
      } finally {
        Ne && !Y.aborted && (a = [...a]);
      }
      if (Y.aborted) return { type: "aborted" };
      let Pe = er(He, O, l);
      if (Pe) return { type: "success", matches: Pe };
      let Ce = Cs(He, O, l, !0);
      if (
        !Ce ||
        (me.length === Ce.length &&
          me.every((Ue, $e) => Ue.route.id === Ce[$e].route.id))
      )
        return { type: "success", matches: null };
      me = Ce;
    }
  }
  function Vt(U) {
    (s = {}), (o = Ma(U, r, void 0, s));
  }
  function nn(U, O) {
    let Y = o == null;
    Ml(U, O, o || a, s, r), Y && ((a = [...a]), Xe({}));
  }
  return (
    (A = {
      get basename() {
        return l;
      },
      get future() {
        return h;
      },
      get state() {
        return S;
      },
      get routes() {
        return a;
      },
      get window() {
        return e;
      },
      initialize: Qe,
      subscribe: St,
      enableScrollRestoration: Se,
      navigate: L,
      fetch: D,
      revalidate: Lt,
      createHref: (U) => i.history.createHref(U),
      encodeLocation: (U) => i.history.encodeLocation(U),
      getFetcher: et,
      deleteFetcher: Me,
      dispose: Oe,
      getBlocker: Ye,
      deleteBlocker: dt,
      patchRoutes: nn,
      _internalFetchControllers: k,
      _internalActiveDeferreds: fe,
      _internalSetRoutes: Vt,
    }),
    A
  );
}
function Qd(i) {
  return (
    i != null &&
    (("formData" in i && i.formData != null) ||
      ("body" in i && i.body !== void 0))
  );
}
function No(i, e, t, n, r, s, a, o) {
  let l, c;
  if (a) {
    l = [];
    for (let h of e)
      if ((l.push(h), h.route.id === a)) {
        c = h;
        break;
      }
  } else (l = e), (c = e[e.length - 1]);
  let u = Vd(r || ".", Hd(l, s), Ra(i.pathname, t) || i.pathname, o === "path");
  if (
    (r == null && ((u.search = i.search), (u.hash = i.hash)),
    (r == null || r === "" || r === ".") && c)
  ) {
    let h = Hc(u.search);
    if (c.route.index && !h)
      u.search = u.search ? u.search.replace(/^\?/, "?index&") : "?index";
    else if (!c.route.index && h) {
      let f = new URLSearchParams(u.search),
        m = f.getAll("index");
      f.delete("index"),
        m.filter((g) => g).forEach((g) => f.append("index", g));
      let x = f.toString();
      u.search = x ? "?" + x : "";
    }
  }
  return (
    n &&
      t !== "/" &&
      (u.pathname = u.pathname === "/" ? t : Nr([t, u.pathname])),
    Hr(u)
  );
}
function vl(i, e, t, n) {
  if (!n || !Qd(n)) return { path: t };
  if (n.formMethod && !f0(n.formMethod))
    return { path: t, error: Jt(405, { method: n.formMethod }) };
  let r = () => ({ path: t, error: Jt(400, { type: "invalid-body" }) }),
    s = n.formMethod || "get",
    a = i ? s.toUpperCase() : s.toLowerCase(),
    o = Xf(t);
  if (n.body !== void 0) {
    if (n.formEncType === "text/plain") {
      if (!En(a)) return r();
      let f =
        typeof n.body == "string"
          ? n.body
          : n.body instanceof FormData || n.body instanceof URLSearchParams
            ? Array.from(n.body.entries()).reduce((m, x) => {
                let [g, d] = x;
                return (
                  "" +
                  m +
                  g +
                  "=" +
                  d +
                  `
`
                );
              }, "")
            : String(n.body);
      return {
        path: t,
        submission: {
          formMethod: a,
          formAction: o,
          formEncType: n.formEncType,
          formData: void 0,
          json: void 0,
          text: f,
        },
      };
    } else if (n.formEncType === "application/json") {
      if (!En(a)) return r();
      try {
        let f = typeof n.body == "string" ? JSON.parse(n.body) : n.body;
        return {
          path: t,
          submission: {
            formMethod: a,
            formAction: o,
            formEncType: n.formEncType,
            formData: void 0,
            json: f,
            text: void 0,
          },
        };
      } catch (f) {
        return r();
      }
    }
  }
  At(
    typeof FormData == "function",
    "FormData is not available in this environment",
  );
  let l, c;
  if (n.formData) (l = zo(n.formData)), (c = n.formData);
  else if (n.body instanceof FormData) (l = zo(n.body)), (c = n.body);
  else if (n.body instanceof URLSearchParams) (l = n.body), (c = bl(l));
  else if (n.body == null) (l = new URLSearchParams()), (c = new FormData());
  else
    try {
      (l = new URLSearchParams(n.body)), (c = bl(l));
    } catch (f) {
      return r();
    }
  let u = {
    formMethod: a,
    formAction: o,
    formEncType: (n && n.formEncType) || "application/x-www-form-urlencoded",
    formData: c,
    json: void 0,
    text: void 0,
  };
  if (En(u.formMethod)) return { path: t, submission: u };
  let h = Ri(t);
  return (
    e && h.search && Hc(h.search) && l.append("index", ""),
    (h.search = "?" + l),
    { path: Hr(h), submission: u }
  );
}
function El(i, e, t) {
  t === void 0 && (t = !1);
  let n = i.findIndex((r) => r.route.id === e);
  return n >= 0 ? i.slice(0, t ? n + 1 : n) : i;
}
function yl(i, e, t, n, r, s, a, o, l, c, u, h, f, m, x, g) {
  let d = g ? (on(g[1]) ? g[1].error : g[1].data) : void 0,
    p = i.createURL(e.location),
    y = i.createURL(r),
    E = t;
  s && e.errors
    ? (E = El(t, Object.keys(e.errors)[0], !0))
    : g && on(g[1]) && (E = El(t, g[0]));
  let v = g ? g[1].statusCode : void 0,
    C = a && v && v >= 400,
    A = E.filter((R, M) => {
      let { route: _ } = R;
      if (_.lazy) return !0;
      if (_.loader == null) return !1;
      if (s) return Oo(_, e.loaderData, e.errors);
      if (e0(e.loaderData, e.matches[M], R) || l.some((P) => P === R.route.id))
        return !0;
      let T = e.matches[M],
        F = R;
      return Sl(
        R,
        Rt(
          {
            currentUrl: p,
            currentParams: T.params,
            nextUrl: y,
            nextParams: F.params,
          },
          n,
          {
            actionResult: d,
            actionStatus: v,
            defaultShouldRevalidate: C
              ? !1
              : o ||
                p.pathname + p.search === y.pathname + y.search ||
                p.search !== y.search ||
                Gf(T, F),
          },
        ),
      );
    }),
    S = [];
  return (
    h.forEach((R, M) => {
      if (s || !t.some((I) => I.route.id === R.routeId) || u.has(M)) return;
      let _ = er(m, R.path, x);
      if (!_) {
        S.push({
          key: M,
          routeId: R.routeId,
          path: R.path,
          matches: null,
          match: null,
          controller: null,
        });
        return;
      }
      let T = e.fetchers.get(M),
        F = Lr(_, R.path),
        P = !1;
      f.has(M)
        ? (P = !1)
        : c.has(M)
          ? (c.delete(M), (P = !0))
          : T && T.state !== "idle" && T.data === void 0
            ? (P = o)
            : (P = Sl(
                F,
                Rt(
                  {
                    currentUrl: p,
                    currentParams: e.matches[e.matches.length - 1].params,
                    nextUrl: y,
                    nextParams: t[t.length - 1].params,
                  },
                  n,
                  {
                    actionResult: d,
                    actionStatus: v,
                    defaultShouldRevalidate: C ? !1 : o,
                  },
                ),
              )),
        P &&
          S.push({
            key: M,
            routeId: R.routeId,
            path: R.path,
            matches: _,
            match: F,
            controller: new AbortController(),
          });
    }),
    [A, S]
  );
}
function Oo(i, e, t) {
  if (i.lazy) return !0;
  if (!i.loader) return !1;
  let n = e != null && e[i.id] !== void 0,
    r = t != null && t[i.id] !== void 0;
  return !n && r
    ? !1
    : typeof i.loader == "function" && i.loader.hydrate === !0
      ? !0
      : !n && !r;
}
function e0(i, e, t) {
  let n = !e || t.route.id !== e.route.id,
    r = i[t.route.id] === void 0;
  return n || r;
}
function Gf(i, e) {
  let t = i.route.path;
  return (
    i.pathname !== e.pathname ||
    (t != null && t.endsWith("*") && i.params["*"] !== e.params["*"])
  );
}
function Sl(i, e) {
  if (i.route.shouldRevalidate) {
    let t = i.route.shouldRevalidate(e);
    if (typeof t == "boolean") return t;
  }
  return e.defaultShouldRevalidate;
}
function Ml(i, e, t, n, r) {
  var s;
  let a;
  if (i) {
    let c = n[i];
    At(c, "No route found to patch children into: routeId = " + i),
      c.children || (c.children = []),
      (a = c.children);
  } else a = t;
  let o = e.filter((c) => !a.some((u) => Wf(c, u))),
    l = Ma(
      o,
      r,
      [i || "_", "patch", String(((s = a) == null ? void 0 : s.length) || "0")],
      n,
    );
  a.push(...l);
}
function Wf(i, e) {
  return "id" in i && "id" in e && i.id === e.id
    ? !0
    : i.index === e.index &&
        i.path === e.path &&
        i.caseSensitive === e.caseSensitive
      ? (!i.children || i.children.length === 0) &&
        (!e.children || e.children.length === 0)
        ? !0
        : i.children.every((t, n) => {
            var r;
            return (r = e.children) == null ? void 0 : r.some((s) => Wf(t, s));
          })
      : !1;
}
async function t0(i, e, t) {
  if (!i.lazy) return;
  let n = await i.lazy();
  if (!i.lazy) return;
  let r = t[i.id];
  At(r, "No route found in manifest");
  let s = {};
  for (let a in n) {
    let l = r[a] !== void 0 && a !== "hasErrorBoundary";
    or(
      !l,
      'Route "' +
        r.id +
        '" has a static property "' +
        a +
        '" defined but its lazy function is also returning a value for this property. ' +
        ('The lazy route property "' + a + '" will be ignored.'),
    ),
      !l && !Ad.has(a) && (s[a] = n[a]);
  }
  Object.assign(r, s), Object.assign(r, Rt({}, e(r), { lazy: void 0 }));
}
async function n0(i) {
  let { matches: e } = i,
    t = e.filter((r) => r.shouldLoad);
  return (await Promise.all(t.map((r) => r.resolve()))).reduce(
    (r, s, a) => Object.assign(r, { [t[a].route.id]: s }),
    {},
  );
}
async function i0(i, e, t, n, r, s, a, o, l, c) {
  let u = s.map((m) => (m.route.lazy ? t0(m.route, l, o) : void 0)),
    h = s.map((m, x) => {
      let g = u[x],
        d = r.some((y) => y.route.id === m.route.id);
      return Rt({}, m, {
        shouldLoad: d,
        resolve: async (y) => (
          y &&
            n.method === "GET" &&
            (m.route.lazy || m.route.loader) &&
            (d = !0),
          d
            ? r0(e, n, m, g, y, c)
            : Promise.resolve({ type: xt.data, result: void 0 })
        ),
      });
    }),
    f = await i({
      matches: h,
      request: n,
      params: s[0].params,
      fetcherKey: a,
      context: c,
    });
  try {
    await Promise.all(u);
  } catch (m) {}
  return f;
}
async function r0(i, e, t, n, r, s) {
  let a,
    o,
    l = (c) => {
      let u,
        h = new Promise((x, g) => (u = g));
      (o = () => u()), e.signal.addEventListener("abort", o);
      let f = (x) =>
          typeof c != "function"
            ? Promise.reject(
                new Error(
                  "You cannot call the handler for a route which defines a boolean " +
                    ('"' + i + '" [routeId: ' + t.route.id + "]"),
                ),
              )
            : c(
                { request: e, params: t.params, context: s },
                ...(x !== void 0 ? [x] : []),
              ),
        m = (async () => {
          try {
            return { type: "data", result: await (r ? r((g) => f(g)) : f()) };
          } catch (x) {
            return { type: "error", result: x };
          }
        })();
      return Promise.race([m, h]);
    };
  try {
    let c = t.route[i];
    if (n)
      if (c) {
        let u,
          [h] = await Promise.all([
            l(c).catch((f) => {
              u = f;
            }),
            n,
          ]);
        if (u !== void 0) throw u;
        a = h;
      } else if ((await n, (c = t.route[i]), c)) a = await l(c);
      else if (i === "action") {
        let u = new URL(e.url),
          h = u.pathname + u.search;
        throw Jt(405, { method: e.method, pathname: h, routeId: t.route.id });
      } else return { type: xt.data, result: void 0 };
    else if (c) a = await l(c);
    else {
      let u = new URL(e.url),
        h = u.pathname + u.search;
      throw Jt(404, { pathname: h });
    }
    At(
      a.result !== void 0,
      "You defined " +
        (i === "action" ? "an action" : "a loader") +
        " for route " +
        ('"' +
          t.route.id +
          "\" but didn't return anything from your `" +
          i +
          "` ") +
        "function. Please return a value or `null`.",
    );
  } catch (c) {
    return { type: xt.error, result: c };
  } finally {
    o && e.signal.removeEventListener("abort", o);
  }
  return a;
}
async function s0(i) {
  let { result: e, type: t } = i;
  if (qf(e)) {
    let h;
    try {
      let f = e.headers.get("Content-Type");
      f && /\bapplication\/json\b/.test(f)
        ? e.body == null
          ? (h = null)
          : (h = await e.json())
        : (h = await e.text());
    } catch (f) {
      return { type: xt.error, error: f };
    }
    return t === xt.error
      ? {
          type: xt.error,
          error: new Io(e.status, e.statusText, h),
          statusCode: e.status,
          headers: e.headers,
        }
      : { type: xt.data, data: h, statusCode: e.status, headers: e.headers };
  }
  if (t === xt.error) {
    if (Dl(e)) {
      var n, r;
      if (e.data instanceof Error) {
        var s, a;
        return {
          type: xt.error,
          error: e.data,
          statusCode: (s = e.init) == null ? void 0 : s.status,
          headers:
            (a = e.init) != null && a.headers
              ? new Headers(e.init.headers)
              : void 0,
        };
      }
      return {
        type: xt.error,
        error: new Io(
          ((n = e.init) == null ? void 0 : n.status) || 500,
          void 0,
          e.data,
        ),
        statusCode: Aa(e) ? e.status : void 0,
        headers:
          (r = e.init) != null && r.headers
            ? new Headers(e.init.headers)
            : void 0,
      };
    }
    return { type: xt.error, error: e, statusCode: Aa(e) ? e.status : void 0 };
  }
  if (u0(e)) {
    var o, l;
    return {
      type: xt.deferred,
      deferredData: e,
      statusCode: (o = e.init) == null ? void 0 : o.status,
      headers:
        ((l = e.init) == null ? void 0 : l.headers) &&
        new Headers(e.init.headers),
    };
  }
  if (Dl(e)) {
    var c, u;
    return {
      type: xt.data,
      data: e.data,
      statusCode: (c = e.init) == null ? void 0 : c.status,
      headers:
        (u = e.init) != null && u.headers
          ? new Headers(e.init.headers)
          : void 0,
    };
  }
  return { type: xt.data, data: e };
}
function a0(i, e, t, n, r, s) {
  let a = i.headers.get("Location");
  if (
    (At(
      a,
      "Redirects returned/thrown from loaders/actions must have a Location header",
    ),
    !zc.test(a))
  ) {
    let o = n.slice(0, n.findIndex((l) => l.route.id === t) + 1);
    (a = No(new URL(e.url), o, r, !0, a, s)), i.headers.set("Location", a);
  }
  return i;
}
function Al(i, e, t) {
  if (zc.test(i)) {
    let n = i,
      r = n.startsWith("//") ? new URL(e.protocol + n) : new URL(n),
      s = Ra(r.pathname, t) != null;
    if (r.origin === e.origin && s) return r.pathname + r.search + r.hash;
  }
  return i;
}
function Ui(i, e, t, n) {
  let r = i.createURL(Xf(e)).toString(),
    s = { signal: t };
  if (n && En(n.formMethod)) {
    let { formMethod: a, formEncType: o } = n;
    (s.method = a.toUpperCase()),
      o === "application/json"
        ? ((s.headers = new Headers({ "Content-Type": o })),
          (s.body = JSON.stringify(n.json)))
        : o === "text/plain"
          ? (s.body = n.text)
          : o === "application/x-www-form-urlencoded" && n.formData
            ? (s.body = zo(n.formData))
            : (s.body = n.formData);
  }
  return new Request(r, s);
}
function zo(i) {
  let e = new URLSearchParams();
  for (let [t, n] of i.entries())
    e.append(t, typeof n == "string" ? n : n.name);
  return e;
}
function bl(i) {
  let e = new FormData();
  for (let [t, n] of i.entries()) e.append(t, n);
  return e;
}
function o0(i, e, t, n, r) {
  let s = {},
    a = null,
    o,
    l = !1,
    c = {},
    u = t && on(t[1]) ? t[1].error : void 0;
  return (
    i.forEach((h) => {
      if (!(h.route.id in e)) return;
      let f = h.route.id,
        m = e[f];
      if (
        (At(!yi(m), "Cannot handle redirect results in processLoaderData"),
        on(m))
      ) {
        let x = m.error;
        u !== void 0 && ((x = u), (u = void 0)), (a = a || {});
        {
          let g = _i(i, f);
          a[g.route.id] == null && (a[g.route.id] = x);
        }
        (s[f] = void 0),
          l || ((l = !0), (o = Aa(m.error) ? m.error.status : 500)),
          m.headers && (c[f] = m.headers);
      } else
        ei(m)
          ? (n.set(f, m.deferredData),
            (s[f] = m.deferredData.data),
            m.statusCode != null &&
              m.statusCode !== 200 &&
              !l &&
              (o = m.statusCode),
            m.headers && (c[f] = m.headers))
          : ((s[f] = m.data),
            m.statusCode && m.statusCode !== 200 && !l && (o = m.statusCode),
            m.headers && (c[f] = m.headers));
    }),
    u !== void 0 && t && ((a = { [t[0]]: u }), (s[t[0]] = void 0)),
    { loaderData: s, errors: a, statusCode: o || 200, loaderHeaders: c }
  );
}
function Tl(i, e, t, n, r, s, a) {
  let { loaderData: o, errors: l } = o0(e, t, n, a);
  return (
    r.forEach((c) => {
      let { key: u, match: h, controller: f } = c,
        m = s[u];
      if (
        (At(m, "Did not find corresponding fetcher result"),
        !(f && f.signal.aborted))
      )
        if (on(m)) {
          let x = _i(i.matches, h == null ? void 0 : h.route.id);
          (l && l[x.route.id]) || (l = Rt({}, l, { [x.route.id]: m.error })),
            i.fetchers.delete(u);
        } else if (yi(m)) At(!1, "Unhandled fetcher revalidation redirect");
        else if (ei(m)) At(!1, "Unhandled fetcher deferred data");
        else {
          let x = Jn(m.data);
          i.fetchers.set(u, x);
        }
    }),
    { loaderData: o, errors: l }
  );
}
function Cl(i, e, t, n) {
  let r = Rt({}, e);
  for (let s of t) {
    let a = s.route.id;
    if (
      (e.hasOwnProperty(a)
        ? e[a] !== void 0 && (r[a] = e[a])
        : i[a] !== void 0 && s.route.loader && (r[a] = i[a]),
      n && n.hasOwnProperty(a))
    )
      break;
  }
  return r;
}
function wl(i) {
  return i
    ? on(i[1])
      ? { actionData: {} }
      : { actionData: { [i[0]]: i[1].data } }
    : {};
}
function _i(i, e) {
  return (
    (e ? i.slice(0, i.findIndex((n) => n.route.id === e) + 1) : [...i])
      .reverse()
      .find((n) => n.route.hasErrorBoundary === !0) || i[0]
  );
}
function Rl(i) {
  let e =
    i.length === 1
      ? i[0]
      : i.find((t) => t.index || !t.path || t.path === "/") || {
          id: "__shim-error-route__",
        };
  return {
    matches: [{ params: {}, pathname: "", pathnameBase: "", route: e }],
    route: e,
  };
}
function Jt(i, e) {
  let {
      pathname: t,
      routeId: n,
      method: r,
      type: s,
      message: a,
    } = e === void 0 ? {} : e,
    o = "Unknown Server Error",
    l = "Unknown @remix-run/router error";
  return (
    i === 400
      ? ((o = "Bad Request"),
        r && t && n
          ? (l =
              "You made a " +
              r +
              ' request to "' +
              t +
              '" but ' +
              ('did not provide a `loader` for route "' + n + '", ') +
              "so there is no way to handle the request.")
          : s === "defer-action"
            ? (l = "defer() is not supported in actions")
            : s === "invalid-body" && (l = "Unable to encode submission body"))
      : i === 403
        ? ((o = "Forbidden"),
          (l = 'Route "' + n + '" does not match URL "' + t + '"'))
        : i === 404
          ? ((o = "Not Found"), (l = 'No route matches URL "' + t + '"'))
          : i === 405 &&
            ((o = "Method Not Allowed"),
            r && t && n
              ? (l =
                  "You made a " +
                  r.toUpperCase() +
                  ' request to "' +
                  t +
                  '" but ' +
                  ('did not provide an `action` for route "' + n + '", ') +
                  "so there is no way to handle the request.")
              : r && (l = 'Invalid request method "' + r.toUpperCase() + '"')),
    new Io(i || 500, o, new Error(l), !0)
  );
}
function Kr(i) {
  let e = Object.entries(i);
  for (let t = e.length - 1; t >= 0; t--) {
    let [n, r] = e[t];
    if (yi(r)) return { key: n, result: r };
  }
}
function Xf(i) {
  let e = typeof i == "string" ? Ri(i) : i;
  return Hr(Rt({}, e, { hash: "" }));
}
function c0(i, e) {
  return i.pathname !== e.pathname || i.search !== e.search
    ? !1
    : i.hash === ""
      ? e.hash !== ""
      : i.hash === e.hash
        ? !0
        : e.hash !== "";
}
function l0(i) {
  return qf(i.result) && jd.has(i.result.status);
}
function ei(i) {
  return i.type === xt.deferred;
}
function on(i) {
  return i.type === xt.error;
}
function yi(i) {
  return (i && i.type) === xt.redirect;
}
function Dl(i) {
  return (
    typeof i == "object" &&
    i != null &&
    "type" in i &&
    "data" in i &&
    "init" in i &&
    i.type === "DataWithResponseInit"
  );
}
function u0(i) {
  let e = i;
  return (
    e &&
    typeof e == "object" &&
    typeof e.data == "object" &&
    typeof e.subscribe == "function" &&
    typeof e.cancel == "function" &&
    typeof e.resolveData == "function"
  );
}
function qf(i) {
  return (
    i != null &&
    typeof i.status == "number" &&
    typeof i.statusText == "string" &&
    typeof i.headers == "object" &&
    typeof i.body != "undefined"
  );
}
function f0(i) {
  return $d.has(i.toLowerCase());
}
function En(i) {
  return qd.has(i.toLowerCase());
}
async function h0(i, e, t, n, r) {
  let s = Object.entries(e);
  for (let a = 0; a < s.length; a++) {
    let [o, l] = s[a],
      c = i.find((f) => (f == null ? void 0 : f.route.id) === o);
    if (!c) continue;
    let u = n.find((f) => f.route.id === c.route.id),
      h = u != null && !Gf(u, c) && (r && r[c.route.id]) !== void 0;
    ei(l) &&
      h &&
      (await kc(l, t, !1).then((f) => {
        f && (e[o] = f);
      }));
  }
}
async function d0(i, e, t) {
  for (let n = 0; n < t.length; n++) {
    let { key: r, routeId: s, controller: a } = t[n],
      o = e[r];
    i.find((c) => (c == null ? void 0 : c.route.id) === s) &&
      ei(o) &&
      (At(
        a,
        "Expected an AbortController for revalidating fetcher deferred result",
      ),
      await kc(o, a.signal, !0).then((c) => {
        c && (e[r] = c);
      }));
  }
}
async function kc(i, e, t) {
  if ((t === void 0 && (t = !1), !(await i.deferredData.resolveData(e)))) {
    if (t)
      try {
        return { type: xt.data, data: i.deferredData.unwrappedData };
      } catch (r) {
        return { type: xt.error, error: r };
      }
    return { type: xt.data, data: i.deferredData.data };
  }
}
function Hc(i) {
  return new URLSearchParams(i).getAll("index").some((e) => e === "");
}
function Lr(i, e) {
  let t = typeof e == "string" ? Ri(e).search : e.search;
  if (i[i.length - 1].route.index && Hc(t || "")) return i[i.length - 1];
  let n = kf(i);
  return n[n.length - 1];
}
function Pl(i) {
  let {
    formMethod: e,
    formAction: t,
    formEncType: n,
    text: r,
    formData: s,
    json: a,
  } = i;
  if (!(!e || !t || !n)) {
    if (r != null)
      return {
        formMethod: e,
        formAction: t,
        formEncType: n,
        formData: void 0,
        json: void 0,
        text: r,
      };
    if (s != null)
      return {
        formMethod: e,
        formAction: t,
        formEncType: n,
        formData: s,
        json: void 0,
        text: void 0,
      };
    if (a !== void 0)
      return {
        formMethod: e,
        formAction: t,
        formEncType: n,
        formData: void 0,
        json: a,
        text: void 0,
      };
  }
}
function $a(i, e) {
  return e
    ? {
        state: "loading",
        location: i,
        formMethod: e.formMethod,
        formAction: e.formAction,
        formEncType: e.formEncType,
        formData: e.formData,
        json: e.json,
        text: e.text,
      }
    : {
        state: "loading",
        location: i,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
      };
}
function p0(i, e) {
  return {
    state: "submitting",
    location: i,
    formMethod: e.formMethod,
    formAction: e.formAction,
    formEncType: e.formEncType,
    formData: e.formData,
    json: e.json,
    text: e.text,
  };
}
function Mr(i, e) {
  return i
    ? {
        state: "loading",
        formMethod: i.formMethod,
        formAction: i.formAction,
        formEncType: i.formEncType,
        formData: i.formData,
        json: i.json,
        text: i.text,
        data: e,
      }
    : {
        state: "loading",
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
        data: e,
      };
}
function m0(i, e) {
  return {
    state: "submitting",
    formMethod: i.formMethod,
    formAction: i.formAction,
    formEncType: i.formEncType,
    formData: i.formData,
    json: i.json,
    text: i.text,
    data: e ? e.data : void 0,
  };
}
function Jn(i) {
  return {
    state: "idle",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: i,
  };
}
function x0(i, e) {
  try {
    let t = i.sessionStorage.getItem(Vf);
    if (t) {
      let n = JSON.parse(t);
      for (let [r, s] of Object.entries(n || {}))
        s && Array.isArray(s) && e.set(r, new Set(s || []));
    }
  } catch (t) {}
}
function g0(i, e) {
  if (e.size > 0) {
    let t = {};
    for (let [n, r] of e) t[n] = [...r];
    try {
      i.sessionStorage.setItem(Vf, JSON.stringify(t));
    } catch (n) {
      or(
        !1,
        "Failed to save applied view transitions in sessionStorage (" +
          n +
          ").",
      );
    }
  }
}
var ws = { exports: {} };
function _0(i) {
  throw new Error(
    'Could not dynamically require "' +
      i +
      '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.',
  );
}
var Rs = { exports: {} };
const v0 = {},
  E0 = Object.freeze(
    Object.defineProperty(
      { __proto__: null, default: v0 },
      Symbol.toStringTag,
      { value: "Module" },
    ),
  ),
  y0 = yd(E0);
var S0 = Rs.exports,
  Fl;
function ct() {
  return (
    Fl ||
      ((Fl = 1),
      (function (i, e) {
        (function (t, n) {
          i.exports = n();
        })(S0, function () {
          var t =
            t ||
            (function (n, r) {
              var s;
              if (
                (typeof window != "undefined" &&
                  window.crypto &&
                  (s = window.crypto),
                typeof self != "undefined" && self.crypto && (s = self.crypto),
                typeof globalThis != "undefined" &&
                  globalThis.crypto &&
                  (s = globalThis.crypto),
                !s &&
                  typeof window != "undefined" &&
                  window.msCrypto &&
                  (s = window.msCrypto),
                !s && typeof Xa != "undefined" && Xa.crypto && (s = Xa.crypto),
                !s && typeof _0 == "function")
              )
                try {
                  s = y0;
                } catch (y) {}
              var a = function () {
                  if (s) {
                    if (typeof s.getRandomValues == "function")
                      try {
                        return s.getRandomValues(new Uint32Array(1))[0];
                      } catch (y) {}
                    if (typeof s.randomBytes == "function")
                      try {
                        return s.randomBytes(4).readInt32LE();
                      } catch (y) {}
                  }
                  throw new Error(
                    "Native crypto module could not be used to get secure random number.",
                  );
                },
                o =
                  Object.create ||
                  (function () {
                    function y() {}
                    return function (E) {
                      var v;
                      return (
                        (y.prototype = E),
                        (v = new y()),
                        (y.prototype = null),
                        v
                      );
                    };
                  })(),
                l = {},
                c = (l.lib = {}),
                u = (c.Base = (function () {
                  return {
                    extend: function (y) {
                      var E = o(this);
                      return (
                        y && E.mixIn(y),
                        (!E.hasOwnProperty("init") || this.init === E.init) &&
                          (E.init = function () {
                            E.$super.init.apply(this, arguments);
                          }),
                        (E.init.prototype = E),
                        (E.$super = this),
                        E
                      );
                    },
                    create: function () {
                      var y = this.extend();
                      return y.init.apply(y, arguments), y;
                    },
                    init: function () {},
                    mixIn: function (y) {
                      for (var E in y) y.hasOwnProperty(E) && (this[E] = y[E]);
                      y.hasOwnProperty("toString") &&
                        (this.toString = y.toString);
                    },
                    clone: function () {
                      return this.init.prototype.extend(this);
                    },
                  };
                })()),
                h = (c.WordArray = u.extend({
                  init: function (y, E) {
                    (y = this.words = y || []),
                      E != r
                        ? (this.sigBytes = E)
                        : (this.sigBytes = y.length * 4);
                  },
                  toString: function (y) {
                    return (y || m).stringify(this);
                  },
                  concat: function (y) {
                    var E = this.words,
                      v = y.words,
                      C = this.sigBytes,
                      A = y.sigBytes;
                    if ((this.clamp(), C % 4))
                      for (var S = 0; S < A; S++) {
                        var R = (v[S >>> 2] >>> (24 - (S % 4) * 8)) & 255;
                        E[(C + S) >>> 2] |= R << (24 - ((C + S) % 4) * 8);
                      }
                    else
                      for (var M = 0; M < A; M += 4)
                        E[(C + M) >>> 2] = v[M >>> 2];
                    return (this.sigBytes += A), this;
                  },
                  clamp: function () {
                    var y = this.words,
                      E = this.sigBytes;
                    (y[E >>> 2] &= 4294967295 << (32 - (E % 4) * 8)),
                      (y.length = n.ceil(E / 4));
                  },
                  clone: function () {
                    var y = u.clone.call(this);
                    return (y.words = this.words.slice(0)), y;
                  },
                  random: function (y) {
                    for (var E = [], v = 0; v < y; v += 4) E.push(a());
                    return new h.init(E, y);
                  },
                })),
                f = (l.enc = {}),
                m = (f.Hex = {
                  stringify: function (y) {
                    for (
                      var E = y.words, v = y.sigBytes, C = [], A = 0;
                      A < v;
                      A++
                    ) {
                      var S = (E[A >>> 2] >>> (24 - (A % 4) * 8)) & 255;
                      C.push((S >>> 4).toString(16)),
                        C.push((S & 15).toString(16));
                    }
                    return C.join("");
                  },
                  parse: function (y) {
                    for (var E = y.length, v = [], C = 0; C < E; C += 2)
                      v[C >>> 3] |=
                        parseInt(y.substr(C, 2), 16) << (24 - (C % 8) * 4);
                    return new h.init(v, E / 2);
                  },
                }),
                x = (f.Latin1 = {
                  stringify: function (y) {
                    for (
                      var E = y.words, v = y.sigBytes, C = [], A = 0;
                      A < v;
                      A++
                    ) {
                      var S = (E[A >>> 2] >>> (24 - (A % 4) * 8)) & 255;
                      C.push(String.fromCharCode(S));
                    }
                    return C.join("");
                  },
                  parse: function (y) {
                    for (var E = y.length, v = [], C = 0; C < E; C++)
                      v[C >>> 2] |=
                        (y.charCodeAt(C) & 255) << (24 - (C % 4) * 8);
                    return new h.init(v, E);
                  },
                }),
                g = (f.Utf8 = {
                  stringify: function (y) {
                    try {
                      return decodeURIComponent(escape(x.stringify(y)));
                    } catch (E) {
                      throw new Error("Malformed UTF-8 data");
                    }
                  },
                  parse: function (y) {
                    return x.parse(unescape(encodeURIComponent(y)));
                  },
                }),
                d = (c.BufferedBlockAlgorithm = u.extend({
                  reset: function () {
                    (this._data = new h.init()), (this._nDataBytes = 0);
                  },
                  _append: function (y) {
                    typeof y == "string" && (y = g.parse(y)),
                      this._data.concat(y),
                      (this._nDataBytes += y.sigBytes);
                  },
                  _process: function (y) {
                    var E,
                      v = this._data,
                      C = v.words,
                      A = v.sigBytes,
                      S = this.blockSize,
                      R = S * 4,
                      M = A / R;
                    y
                      ? (M = n.ceil(M))
                      : (M = n.max((M | 0) - this._minBufferSize, 0));
                    var _ = M * S,
                      T = n.min(_ * 4, A);
                    if (_) {
                      for (var F = 0; F < _; F += S) this._doProcessBlock(C, F);
                      (E = C.splice(0, _)), (v.sigBytes -= T);
                    }
                    return new h.init(E, T);
                  },
                  clone: function () {
                    var y = u.clone.call(this);
                    return (y._data = this._data.clone()), y;
                  },
                  _minBufferSize: 0,
                }));
              c.Hasher = d.extend({
                cfg: u.extend(),
                init: function (y) {
                  (this.cfg = this.cfg.extend(y)), this.reset();
                },
                reset: function () {
                  d.reset.call(this), this._doReset();
                },
                update: function (y) {
                  return this._append(y), this._process(), this;
                },
                finalize: function (y) {
                  y && this._append(y);
                  var E = this._doFinalize();
                  return E;
                },
                blockSize: 16,
                _createHelper: function (y) {
                  return function (E, v) {
                    return new y.init(v).finalize(E);
                  };
                },
                _createHmacHelper: function (y) {
                  return function (E, v) {
                    return new p.HMAC.init(y, v).finalize(E);
                  };
                },
              });
              var p = (l.algo = {});
              return l;
            })(Math);
          return t;
        });
      })(Rs)),
    Rs.exports
  );
}
var Ds = { exports: {} },
  M0 = Ds.exports,
  Bl;
function Da() {
  return (
    Bl ||
      ((Bl = 1),
      (function (i, e) {
        (function (t, n) {
          i.exports = n(ct());
        })(M0, function (t) {
          return (
            (function (n) {
              var r = t,
                s = r.lib,
                a = s.Base,
                o = s.WordArray,
                l = (r.x64 = {});
              (l.Word = a.extend({
                init: function (c, u) {
                  (this.high = c), (this.low = u);
                },
              })),
                (l.WordArray = a.extend({
                  init: function (c, u) {
                    (c = this.words = c || []),
                      u != n
                        ? (this.sigBytes = u)
                        : (this.sigBytes = c.length * 8);
                  },
                  toX32: function () {
                    for (
                      var c = this.words, u = c.length, h = [], f = 0;
                      f < u;
                      f++
                    ) {
                      var m = c[f];
                      h.push(m.high), h.push(m.low);
                    }
                    return o.create(h, this.sigBytes);
                  },
                  clone: function () {
                    for (
                      var c = a.clone.call(this),
                        u = (c.words = this.words.slice(0)),
                        h = u.length,
                        f = 0;
                      f < h;
                      f++
                    )
                      u[f] = u[f].clone();
                    return c;
                  },
                }));
            })(),
            t
          );
        });
      })(Ds)),
    Ds.exports
  );
}
var Ps = { exports: {} },
  A0 = Ps.exports,
  Ll;
function b0() {
  return (
    Ll ||
      ((Ll = 1),
      (function (i, e) {
        (function (t, n) {
          i.exports = n(ct());
        })(A0, function (t) {
          return (
            (function () {
              if (typeof ArrayBuffer == "function") {
                var n = t,
                  r = n.lib,
                  s = r.WordArray,
                  a = s.init,
                  o = (s.init = function (l) {
                    if (
                      (l instanceof ArrayBuffer && (l = new Uint8Array(l)),
                      (l instanceof Int8Array ||
                        (typeof Uint8ClampedArray != "undefined" &&
                          l instanceof Uint8ClampedArray) ||
                        l instanceof Int16Array ||
                        l instanceof Uint16Array ||
                        l instanceof Int32Array ||
                        l instanceof Uint32Array ||
                        l instanceof Float32Array ||
                        l instanceof Float64Array) &&
                        (l = new Uint8Array(
                          l.buffer,
                          l.byteOffset,
                          l.byteLength,
                        )),
                      l instanceof Uint8Array)
                    ) {
                      for (var c = l.byteLength, u = [], h = 0; h < c; h++)
                        u[h >>> 2] |= l[h] << (24 - (h % 4) * 8);
                      a.call(this, u, c);
                    } else a.apply(this, arguments);
                  });
                o.prototype = s;
              }
            })(),
            t.lib.WordArray
          );
        });
      })(Ps)),
    Ps.exports
  );
}
var Fs = { exports: {} },
  T0 = Fs.exports,
  Ul;
function C0() {
  return (
    Ul ||
      ((Ul = 1),
      (function (i, e) {
        (function (t, n) {
          i.exports = n(ct());
        })(T0, function (t) {
          return (
            (function () {
              var n = t,
                r = n.lib,
                s = r.WordArray,
                a = n.enc;
              (a.Utf16 = a.Utf16BE =
                {
                  stringify: function (l) {
                    for (
                      var c = l.words, u = l.sigBytes, h = [], f = 0;
                      f < u;
                      f += 2
                    ) {
                      var m = (c[f >>> 2] >>> (16 - (f % 4) * 8)) & 65535;
                      h.push(String.fromCharCode(m));
                    }
                    return h.join("");
                  },
                  parse: function (l) {
                    for (var c = l.length, u = [], h = 0; h < c; h++)
                      u[h >>> 1] |= l.charCodeAt(h) << (16 - (h % 2) * 16);
                    return s.create(u, c * 2);
                  },
                }),
                (a.Utf16LE = {
                  stringify: function (l) {
                    for (
                      var c = l.words, u = l.sigBytes, h = [], f = 0;
                      f < u;
                      f += 2
                    ) {
                      var m = o((c[f >>> 2] >>> (16 - (f % 4) * 8)) & 65535);
                      h.push(String.fromCharCode(m));
                    }
                    return h.join("");
                  },
                  parse: function (l) {
                    for (var c = l.length, u = [], h = 0; h < c; h++)
                      u[h >>> 1] |= o(l.charCodeAt(h) << (16 - (h % 2) * 16));
                    return s.create(u, c * 2);
                  },
                });
              function o(l) {
                return ((l << 8) & 4278255360) | ((l >>> 8) & 16711935);
              }
            })(),
            t.enc.Utf16
          );
        });
      })(Fs)),
    Fs.exports
  );
}
var Bs = { exports: {} },
  w0 = Bs.exports,
  Il;
function Di() {
  return (
    Il ||
      ((Il = 1),
      (function (i, e) {
        (function (t, n) {
          i.exports = n(ct());
        })(w0, function (t) {
          return (
            (function () {
              var n = t,
                r = n.lib,
                s = r.WordArray,
                a = n.enc;
              a.Base64 = {
                stringify: function (l) {
                  var c = l.words,
                    u = l.sigBytes,
                    h = this._map;
                  l.clamp();
                  for (var f = [], m = 0; m < u; m += 3)
                    for (
                      var x = (c[m >>> 2] >>> (24 - (m % 4) * 8)) & 255,
                        g =
                          (c[(m + 1) >>> 2] >>> (24 - ((m + 1) % 4) * 8)) & 255,
                        d =
                          (c[(m + 2) >>> 2] >>> (24 - ((m + 2) % 4) * 8)) & 255,
                        p = (x << 16) | (g << 8) | d,
                        y = 0;
                      y < 4 && m + y * 0.75 < u;
                      y++
                    )
                      f.push(h.charAt((p >>> (6 * (3 - y))) & 63));
                  var E = h.charAt(64);
                  if (E) for (; f.length % 4; ) f.push(E);
                  return f.join("");
                },
                parse: function (l) {
                  var c = l.length,
                    u = this._map,
                    h = this._reverseMap;
                  if (!h) {
                    h = this._reverseMap = [];
                    for (var f = 0; f < u.length; f++) h[u.charCodeAt(f)] = f;
                  }
                  var m = u.charAt(64);
                  if (m) {
                    var x = l.indexOf(m);
                    x !== -1 && (c = x);
                  }
                  return o(l, c, h);
                },
                _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
              };
              function o(l, c, u) {
                for (var h = [], f = 0, m = 0; m < c; m++)
                  if (m % 4) {
                    var x = u[l.charCodeAt(m - 1)] << ((m % 4) * 2),
                      g = u[l.charCodeAt(m)] >>> (6 - (m % 4) * 2),
                      d = x | g;
                    (h[f >>> 2] |= d << (24 - (f % 4) * 8)), f++;
                  }
                return s.create(h, f);
              }
            })(),
            t.enc.Base64
          );
        });
      })(Bs)),
    Bs.exports
  );
}
var Ls = { exports: {} },
  R0 = Ls.exports,
  Nl;
function D0() {
  return (
    Nl ||
      ((Nl = 1),
      (function (i, e) {
        (function (t, n) {
          i.exports = n(ct());
        })(R0, function (t) {
          return (
            (function () {
              var n = t,
                r = n.lib,
                s = r.WordArray,
                a = n.enc;
              a.Base64url = {
                stringify: function (l, c) {
                  c === void 0 && (c = !0);
                  var u = l.words,
                    h = l.sigBytes,
                    f = c ? this._safe_map : this._map;
                  l.clamp();
                  for (var m = [], x = 0; x < h; x += 3)
                    for (
                      var g = (u[x >>> 2] >>> (24 - (x % 4) * 8)) & 255,
                        d =
                          (u[(x + 1) >>> 2] >>> (24 - ((x + 1) % 4) * 8)) & 255,
                        p =
                          (u[(x + 2) >>> 2] >>> (24 - ((x + 2) % 4) * 8)) & 255,
                        y = (g << 16) | (d << 8) | p,
                        E = 0;
                      E < 4 && x + E * 0.75 < h;
                      E++
                    )
                      m.push(f.charAt((y >>> (6 * (3 - E))) & 63));
                  var v = f.charAt(64);
                  if (v) for (; m.length % 4; ) m.push(v);
                  return m.join("");
                },
                parse: function (l, c) {
                  c === void 0 && (c = !0);
                  var u = l.length,
                    h = c ? this._safe_map : this._map,
                    f = this._reverseMap;
                  if (!f) {
                    f = this._reverseMap = [];
                    for (var m = 0; m < h.length; m++) f[h.charCodeAt(m)] = m;
                  }
                  var x = h.charAt(64);
                  if (x) {
                    var g = l.indexOf(x);
                    g !== -1 && (u = g);
                  }
                  return o(l, u, f);
                },
                _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                _safe_map:
                  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
              };
              function o(l, c, u) {
                for (var h = [], f = 0, m = 0; m < c; m++)
                  if (m % 4) {
                    var x = u[l.charCodeAt(m - 1)] << ((m % 4) * 2),
                      g = u[l.charCodeAt(m)] >>> (6 - (m % 4) * 2),
                      d = x | g;
                    (h[f >>> 2] |= d << (24 - (f % 4) * 8)), f++;
                  }
                return s.create(h, f);
              }
            })(),
            t.enc.Base64url
          );
        });
      })(Ls)),
    Ls.exports
  );
}
var Us = { exports: {} },
  P0 = Us.exports,
  Ol;
function Pi() {
  return (
    Ol ||
      ((Ol = 1),
      (function (i, e) {
        (function (t, n) {
          i.exports = n(ct());
        })(P0, function (t) {
          return (
            (function (n) {
              var r = t,
                s = r.lib,
                a = s.WordArray,
                o = s.Hasher,
                l = r.algo,
                c = [];
              (function () {
                for (var g = 0; g < 64; g++)
                  c[g] = (n.abs(n.sin(g + 1)) * 4294967296) | 0;
              })();
              var u = (l.MD5 = o.extend({
                _doReset: function () {
                  this._hash = new a.init([
                    1732584193, 4023233417, 2562383102, 271733878,
                  ]);
                },
                _doProcessBlock: function (g, d) {
                  for (var p = 0; p < 16; p++) {
                    var y = d + p,
                      E = g[y];
                    g[y] =
                      (((E << 8) | (E >>> 24)) & 16711935) |
                      (((E << 24) | (E >>> 8)) & 4278255360);
                  }
                  var v = this._hash.words,
                    C = g[d + 0],
                    A = g[d + 1],
                    S = g[d + 2],
                    R = g[d + 3],
                    M = g[d + 4],
                    _ = g[d + 5],
                    T = g[d + 6],
                    F = g[d + 7],
                    P = g[d + 8],
                    I = g[d + 9],
                    X = g[d + 10],
                    V = g[d + 11],
                    ie = g[d + 12],
                    k = g[d + 13],
                    ae = g[d + 14],
                    ce = g[d + 15],
                    H = v[0],
                    K = v[1],
                    Q = v[2],
                    B = v[3];
                  (H = h(H, K, Q, B, C, 7, c[0])),
                    (B = h(B, H, K, Q, A, 12, c[1])),
                    (Q = h(Q, B, H, K, S, 17, c[2])),
                    (K = h(K, Q, B, H, R, 22, c[3])),
                    (H = h(H, K, Q, B, M, 7, c[4])),
                    (B = h(B, H, K, Q, _, 12, c[5])),
                    (Q = h(Q, B, H, K, T, 17, c[6])),
                    (K = h(K, Q, B, H, F, 22, c[7])),
                    (H = h(H, K, Q, B, P, 7, c[8])),
                    (B = h(B, H, K, Q, I, 12, c[9])),
                    (Q = h(Q, B, H, K, X, 17, c[10])),
                    (K = h(K, Q, B, H, V, 22, c[11])),
                    (H = h(H, K, Q, B, ie, 7, c[12])),
                    (B = h(B, H, K, Q, k, 12, c[13])),
                    (Q = h(Q, B, H, K, ae, 17, c[14])),
                    (K = h(K, Q, B, H, ce, 22, c[15])),
                    (H = f(H, K, Q, B, A, 5, c[16])),
                    (B = f(B, H, K, Q, T, 9, c[17])),
                    (Q = f(Q, B, H, K, V, 14, c[18])),
                    (K = f(K, Q, B, H, C, 20, c[19])),
                    (H = f(H, K, Q, B, _, 5, c[20])),
                    (B = f(B, H, K, Q, X, 9, c[21])),
                    (Q = f(Q, B, H, K, ce, 14, c[22])),
                    (K = f(K, Q, B, H, M, 20, c[23])),
                    (H = f(H, K, Q, B, I, 5, c[24])),
                    (B = f(B, H, K, Q, ae, 9, c[25])),
                    (Q = f(Q, B, H, K, R, 14, c[26])),
                    (K = f(K, Q, B, H, P, 20, c[27])),
                    (H = f(H, K, Q, B, k, 5, c[28])),
                    (B = f(B, H, K, Q, S, 9, c[29])),
                    (Q = f(Q, B, H, K, F, 14, c[30])),
                    (K = f(K, Q, B, H, ie, 20, c[31])),
                    (H = m(H, K, Q, B, _, 4, c[32])),
                    (B = m(B, H, K, Q, P, 11, c[33])),
                    (Q = m(Q, B, H, K, V, 16, c[34])),
                    (K = m(K, Q, B, H, ae, 23, c[35])),
                    (H = m(H, K, Q, B, A, 4, c[36])),
                    (B = m(B, H, K, Q, M, 11, c[37])),
                    (Q = m(Q, B, H, K, F, 16, c[38])),
                    (K = m(K, Q, B, H, X, 23, c[39])),
                    (H = m(H, K, Q, B, k, 4, c[40])),
                    (B = m(B, H, K, Q, C, 11, c[41])),
                    (Q = m(Q, B, H, K, R, 16, c[42])),
                    (K = m(K, Q, B, H, T, 23, c[43])),
                    (H = m(H, K, Q, B, I, 4, c[44])),
                    (B = m(B, H, K, Q, ie, 11, c[45])),
                    (Q = m(Q, B, H, K, ce, 16, c[46])),
                    (K = m(K, Q, B, H, S, 23, c[47])),
                    (H = x(H, K, Q, B, C, 6, c[48])),
                    (B = x(B, H, K, Q, F, 10, c[49])),
                    (Q = x(Q, B, H, K, ae, 15, c[50])),
                    (K = x(K, Q, B, H, _, 21, c[51])),
                    (H = x(H, K, Q, B, ie, 6, c[52])),
                    (B = x(B, H, K, Q, R, 10, c[53])),
                    (Q = x(Q, B, H, K, X, 15, c[54])),
                    (K = x(K, Q, B, H, A, 21, c[55])),
                    (H = x(H, K, Q, B, P, 6, c[56])),
                    (B = x(B, H, K, Q, ce, 10, c[57])),
                    (Q = x(Q, B, H, K, T, 15, c[58])),
                    (K = x(K, Q, B, H, k, 21, c[59])),
                    (H = x(H, K, Q, B, M, 6, c[60])),
                    (B = x(B, H, K, Q, V, 10, c[61])),
                    (Q = x(Q, B, H, K, S, 15, c[62])),
                    (K = x(K, Q, B, H, I, 21, c[63])),
                    (v[0] = (v[0] + H) | 0),
                    (v[1] = (v[1] + K) | 0),
                    (v[2] = (v[2] + Q) | 0),
                    (v[3] = (v[3] + B) | 0);
                },
                _doFinalize: function () {
                  var g = this._data,
                    d = g.words,
                    p = this._nDataBytes * 8,
                    y = g.sigBytes * 8;
                  d[y >>> 5] |= 128 << (24 - (y % 32));
                  var E = n.floor(p / 4294967296),
                    v = p;
                  (d[(((y + 64) >>> 9) << 4) + 15] =
                    (((E << 8) | (E >>> 24)) & 16711935) |
                    (((E << 24) | (E >>> 8)) & 4278255360)),
                    (d[(((y + 64) >>> 9) << 4) + 14] =
                      (((v << 8) | (v >>> 24)) & 16711935) |
                      (((v << 24) | (v >>> 8)) & 4278255360)),
                    (g.sigBytes = (d.length + 1) * 4),
                    this._process();
                  for (var C = this._hash, A = C.words, S = 0; S < 4; S++) {
                    var R = A[S];
                    A[S] =
                      (((R << 8) | (R >>> 24)) & 16711935) |
                      (((R << 24) | (R >>> 8)) & 4278255360);
                  }
                  return C;
                },
                clone: function () {
                  var g = o.clone.call(this);
                  return (g._hash = this._hash.clone()), g;
                },
              }));
              function h(g, d, p, y, E, v, C) {
                var A = g + ((d & p) | (~d & y)) + E + C;
                return ((A << v) | (A >>> (32 - v))) + d;
              }
              function f(g, d, p, y, E, v, C) {
                var A = g + ((d & y) | (p & ~y)) + E + C;
                return ((A << v) | (A >>> (32 - v))) + d;
              }
              function m(g, d, p, y, E, v, C) {
                var A = g + (d ^ p ^ y) + E + C;
                return ((A << v) | (A >>> (32 - v))) + d;
              }
              function x(g, d, p, y, E, v, C) {
                var A = g + (p ^ (d | ~y)) + E + C;
                return ((A << v) | (A >>> (32 - v))) + d;
              }
              (r.MD5 = o._createHelper(u)),
                (r.HmacMD5 = o._createHmacHelper(u));
            })(Math),
            t.MD5
          );
        });
      })(Us)),
    Us.exports
  );
}
var Is = { exports: {} },
  F0 = Is.exports,
  zl;
function Yf() {
  return (
    zl ||
      ((zl = 1),
      (function (i, e) {
        (function (t, n) {
          i.exports = n(ct());
        })(F0, function (t) {
          return (
            (function () {
              var n = t,
                r = n.lib,
                s = r.WordArray,
                a = r.Hasher,
                o = n.algo,
                l = [],
                c = (o.SHA1 = a.extend({
                  _doReset: function () {
                    this._hash = new s.init([
                      1732584193, 4023233417, 2562383102, 271733878, 3285377520,
                    ]);
                  },
                  _doProcessBlock: function (u, h) {
                    for (
                      var f = this._hash.words,
                        m = f[0],
                        x = f[1],
                        g = f[2],
                        d = f[3],
                        p = f[4],
                        y = 0;
                      y < 80;
                      y++
                    ) {
                      if (y < 16) l[y] = u[h + y] | 0;
                      else {
                        var E = l[y - 3] ^ l[y - 8] ^ l[y - 14] ^ l[y - 16];
                        l[y] = (E << 1) | (E >>> 31);
                      }
                      var v = ((m << 5) | (m >>> 27)) + p + l[y];
                      y < 20
                        ? (v += ((x & g) | (~x & d)) + 1518500249)
                        : y < 40
                          ? (v += (x ^ g ^ d) + 1859775393)
                          : y < 60
                            ? (v += ((x & g) | (x & d) | (g & d)) - 1894007588)
                            : (v += (x ^ g ^ d) - 899497514),
                        (p = d),
                        (d = g),
                        (g = (x << 30) | (x >>> 2)),
                        (x = m),
                        (m = v);
                    }
                    (f[0] = (f[0] + m) | 0),
                      (f[1] = (f[1] + x) | 0),
                      (f[2] = (f[2] + g) | 0),
                      (f[3] = (f[3] + d) | 0),
                      (f[4] = (f[4] + p) | 0);
                  },
                  _doFinalize: function () {
                    var u = this._data,
                      h = u.words,
                      f = this._nDataBytes * 8,
                      m = u.sigBytes * 8;
                    return (
                      (h[m >>> 5] |= 128 << (24 - (m % 32))),
                      (h[(((m + 64) >>> 9) << 4) + 14] = Math.floor(
                        f / 4294967296,
                      )),
                      (h[(((m + 64) >>> 9) << 4) + 15] = f),
                      (u.sigBytes = h.length * 4),
                      this._process(),
                      this._hash
                    );
                  },
                  clone: function () {
                    var u = a.clone.call(this);
                    return (u._hash = this._hash.clone()), u;
                  },
                }));
              (n.SHA1 = a._createHelper(c)),
                (n.HmacSHA1 = a._createHmacHelper(c));
            })(),
            t.SHA1
          );
        });
      })(Is)),
    Is.exports
  );
}
var Ns = { exports: {} },
  B0 = Ns.exports,
  kl;
function Vc() {
  return (
    kl ||
      ((kl = 1),
      (function (i, e) {
        (function (t, n) {
          i.exports = n(ct());
        })(B0, function (t) {
          return (
            (function (n) {
              var r = t,
                s = r.lib,
                a = s.WordArray,
                o = s.Hasher,
                l = r.algo,
                c = [],
                u = [];
              (function () {
                function m(p) {
                  for (var y = n.sqrt(p), E = 2; E <= y; E++)
                    if (!(p % E)) return !1;
                  return !0;
                }
                function x(p) {
                  return ((p - (p | 0)) * 4294967296) | 0;
                }
                for (var g = 2, d = 0; d < 64; )
                  m(g) &&
                    (d < 8 && (c[d] = x(n.pow(g, 1 / 2))),
                    (u[d] = x(n.pow(g, 1 / 3))),
                    d++),
                    g++;
              })();
              var h = [],
                f = (l.SHA256 = o.extend({
                  _doReset: function () {
                    this._hash = new a.init(c.slice(0));
                  },
                  _doProcessBlock: function (m, x) {
                    for (
                      var g = this._hash.words,
                        d = g[0],
                        p = g[1],
                        y = g[2],
                        E = g[3],
                        v = g[4],
                        C = g[5],
                        A = g[6],
                        S = g[7],
                        R = 0;
                      R < 64;
                      R++
                    ) {
                      if (R < 16) h[R] = m[x + R] | 0;
                      else {
                        var M = h[R - 15],
                          _ =
                            ((M << 25) | (M >>> 7)) ^
                            ((M << 14) | (M >>> 18)) ^
                            (M >>> 3),
                          T = h[R - 2],
                          F =
                            ((T << 15) | (T >>> 17)) ^
                            ((T << 13) | (T >>> 19)) ^
                            (T >>> 10);
                        h[R] = _ + h[R - 7] + F + h[R - 16];
                      }
                      var P = (v & C) ^ (~v & A),
                        I = (d & p) ^ (d & y) ^ (p & y),
                        X =
                          ((d << 30) | (d >>> 2)) ^
                          ((d << 19) | (d >>> 13)) ^
                          ((d << 10) | (d >>> 22)),
                        V =
                          ((v << 26) | (v >>> 6)) ^
                          ((v << 21) | (v >>> 11)) ^
                          ((v << 7) | (v >>> 25)),
                        ie = S + V + P + u[R] + h[R],
                        k = X + I;
                      (S = A),
                        (A = C),
                        (C = v),
                        (v = (E + ie) | 0),
                        (E = y),
                        (y = p),
                        (p = d),
                        (d = (ie + k) | 0);
                    }
                    (g[0] = (g[0] + d) | 0),
                      (g[1] = (g[1] + p) | 0),
                      (g[2] = (g[2] + y) | 0),
                      (g[3] = (g[3] + E) | 0),
                      (g[4] = (g[4] + v) | 0),
                      (g[5] = (g[5] + C) | 0),
                      (g[6] = (g[6] + A) | 0),
                      (g[7] = (g[7] + S) | 0);
                  },
                  _doFinalize: function () {
                    var m = this._data,
                      x = m.words,
                      g = this._nDataBytes * 8,
                      d = m.sigBytes * 8;
                    return (
                      (x[d >>> 5] |= 128 << (24 - (d % 32))),
                      (x[(((d + 64) >>> 9) << 4) + 14] = n.floor(
                        g / 4294967296,
                      )),
                      (x[(((d + 64) >>> 9) << 4) + 15] = g),
                      (m.sigBytes = x.length * 4),
                      this._process(),
                      this._hash
                    );
                  },
                  clone: function () {
                    var m = o.clone.call(this);
                    return (m._hash = this._hash.clone()), m;
                  },
                }));
              (r.SHA256 = o._createHelper(f)),
                (r.HmacSHA256 = o._createHmacHelper(f));
            })(Math),
            t.SHA256
          );
        });
      })(Ns)),
    Ns.exports
  );
}
var Os = { exports: {} },
  L0 = Os.exports,
  Hl;
function U0() {
  return (
    Hl ||
      ((Hl = 1),
      (function (i, e) {
        (function (t, n, r) {
          i.exports = n(ct(), Vc());
        })(L0, function (t) {
          return (
            (function () {
              var n = t,
                r = n.lib,
                s = r.WordArray,
                a = n.algo,
                o = a.SHA256,
                l = (a.SHA224 = o.extend({
                  _doReset: function () {
                    this._hash = new s.init([
                      3238371032, 914150663, 812702999, 4144912697, 4290775857,
                      1750603025, 1694076839, 3204075428,
                    ]);
                  },
                  _doFinalize: function () {
                    var c = o._doFinalize.call(this);
                    return (c.sigBytes -= 4), c;
                  },
                }));
              (n.SHA224 = o._createHelper(l)),
                (n.HmacSHA224 = o._createHmacHelper(l));
            })(),
            t.SHA224
          );
        });
      })(Os)),
    Os.exports
  );
}
var zs = { exports: {} },
  I0 = zs.exports,
  Vl;
function $f() {
  return (
    Vl ||
      ((Vl = 1),
      (function (i, e) {
        (function (t, n, r) {
          i.exports = n(ct(), Da());
        })(I0, function (t) {
          return (
            (function () {
              var n = t,
                r = n.lib,
                s = r.Hasher,
                a = n.x64,
                o = a.Word,
                l = a.WordArray,
                c = n.algo;
              function u() {
                return o.create.apply(o, arguments);
              }
              var h = [
                  u(1116352408, 3609767458),
                  u(1899447441, 602891725),
                  u(3049323471, 3964484399),
                  u(3921009573, 2173295548),
                  u(961987163, 4081628472),
                  u(1508970993, 3053834265),
                  u(2453635748, 2937671579),
                  u(2870763221, 3664609560),
                  u(3624381080, 2734883394),
                  u(310598401, 1164996542),
                  u(607225278, 1323610764),
                  u(1426881987, 3590304994),
                  u(1925078388, 4068182383),
                  u(2162078206, 991336113),
                  u(2614888103, 633803317),
                  u(3248222580, 3479774868),
                  u(3835390401, 2666613458),
                  u(4022224774, 944711139),
                  u(264347078, 2341262773),
                  u(604807628, 2007800933),
                  u(770255983, 1495990901),
                  u(1249150122, 1856431235),
                  u(1555081692, 3175218132),
                  u(1996064986, 2198950837),
                  u(2554220882, 3999719339),
                  u(2821834349, 766784016),
                  u(2952996808, 2566594879),
                  u(3210313671, 3203337956),
                  u(3336571891, 1034457026),
                  u(3584528711, 2466948901),
                  u(113926993, 3758326383),
                  u(338241895, 168717936),
                  u(666307205, 1188179964),
                  u(773529912, 1546045734),
                  u(1294757372, 1522805485),
                  u(1396182291, 2643833823),
                  u(1695183700, 2343527390),
                  u(1986661051, 1014477480),
                  u(2177026350, 1206759142),
                  u(2456956037, 344077627),
                  u(2730485921, 1290863460),
                  u(2820302411, 3158454273),
                  u(3259730800, 3505952657),
                  u(3345764771, 106217008),
                  u(3516065817, 3606008344),
                  u(3600352804, 1432725776),
                  u(4094571909, 1467031594),
                  u(275423344, 851169720),
                  u(430227734, 3100823752),
                  u(506948616, 1363258195),
                  u(659060556, 3750685593),
                  u(883997877, 3785050280),
                  u(958139571, 3318307427),
                  u(1322822218, 3812723403),
                  u(1537002063, 2003034995),
                  u(1747873779, 3602036899),
                  u(1955562222, 1575990012),
                  u(2024104815, 1125592928),
                  u(2227730452, 2716904306),
                  u(2361852424, 442776044),
                  u(2428436474, 593698344),
                  u(2756734187, 3733110249),
                  u(3204031479, 2999351573),
                  u(3329325298, 3815920427),
                  u(3391569614, 3928383900),
                  u(3515267271, 566280711),
                  u(3940187606, 3454069534),
                  u(4118630271, 4000239992),
                  u(116418474, 1914138554),
                  u(174292421, 2731055270),
                  u(289380356, 3203993006),
                  u(460393269, 320620315),
                  u(685471733, 587496836),
                  u(852142971, 1086792851),
                  u(1017036298, 365543100),
                  u(1126000580, 2618297676),
                  u(1288033470, 3409855158),
                  u(1501505948, 4234509866),
                  u(1607167915, 987167468),
                  u(1816402316, 1246189591),
                ],
                f = [];
              (function () {
                for (var x = 0; x < 80; x++) f[x] = u();
              })();
              var m = (c.SHA512 = s.extend({
                _doReset: function () {
                  this._hash = new l.init([
                    new o.init(1779033703, 4089235720),
                    new o.init(3144134277, 2227873595),
                    new o.init(1013904242, 4271175723),
                    new o.init(2773480762, 1595750129),
                    new o.init(1359893119, 2917565137),
                    new o.init(2600822924, 725511199),
                    new o.init(528734635, 4215389547),
                    new o.init(1541459225, 327033209),
                  ]);
                },
                _doProcessBlock: function (x, g) {
                  for (
                    var d = this._hash.words,
                      p = d[0],
                      y = d[1],
                      E = d[2],
                      v = d[3],
                      C = d[4],
                      A = d[5],
                      S = d[6],
                      R = d[7],
                      M = p.high,
                      _ = p.low,
                      T = y.high,
                      F = y.low,
                      P = E.high,
                      I = E.low,
                      X = v.high,
                      V = v.low,
                      ie = C.high,
                      k = C.low,
                      ae = A.high,
                      ce = A.low,
                      H = S.high,
                      K = S.low,
                      Q = R.high,
                      B = R.low,
                      te = M,
                      fe = _,
                      he = T,
                      de = F,
                      Qe = P,
                      Oe = I,
                      St = X,
                      Xe = V,
                      ze = ie,
                      L = k,
                      Lt = ae,
                      We = ce,
                      Ke = H,
                      Be = K,
                      ht = Q,
                      Fe = B,
                      D = 0;
                    D < 80;
                    D++
                  ) {
                    var b,
                      q,
                      ne = f[D];
                    if (D < 16)
                      (q = ne.high = x[g + D * 2] | 0),
                        (b = ne.low = x[g + D * 2 + 1] | 0);
                    else {
                      var se = f[D - 15],
                        ee = se.high,
                        Re = se.low,
                        pe =
                          ((ee >>> 1) | (Re << 31)) ^
                          ((ee >>> 8) | (Re << 24)) ^
                          (ee >>> 7),
                        ve =
                          ((Re >>> 1) | (ee << 31)) ^
                          ((Re >>> 8) | (ee << 24)) ^
                          ((Re >>> 7) | (ee << 25)),
                        et = f[D - 2],
                        le = et.high,
                        Me = et.low,
                        Le =
                          ((le >>> 19) | (Me << 13)) ^
                          ((le << 3) | (Me >>> 29)) ^
                          (le >>> 6),
                        ke =
                          ((Me >>> 19) | (le << 13)) ^
                          ((Me << 3) | (le >>> 29)) ^
                          ((Me >>> 6) | (le << 26)),
                        be = f[D - 7],
                        tt = be.high,
                        Ye = be.low,
                        dt = f[D - 16],
                        N = dt.high,
                        ge = dt.low;
                      (b = ve + Ye),
                        (q = pe + tt + (b >>> 0 < ve >>> 0 ? 1 : 0)),
                        (b = b + ke),
                        (q = q + Le + (b >>> 0 < ke >>> 0 ? 1 : 0)),
                        (b = b + ge),
                        (q = q + N + (b >>> 0 < ge >>> 0 ? 1 : 0)),
                        (ne.high = q),
                        (ne.low = b);
                    }
                    var J = (ze & Lt) ^ (~ze & Ke),
                      re = (L & We) ^ (~L & Be),
                      Se = (te & he) ^ (te & Qe) ^ (he & Qe),
                      Ee = (fe & de) ^ (fe & Oe) ^ (de & Oe),
                      qe =
                        ((te >>> 28) | (fe << 4)) ^
                        ((te << 30) | (fe >>> 2)) ^
                        ((te << 25) | (fe >>> 7)),
                      gt =
                        ((fe >>> 28) | (te << 4)) ^
                        ((fe << 30) | (te >>> 2)) ^
                        ((fe << 25) | (te >>> 7)),
                      Dt =
                        ((ze >>> 14) | (L << 18)) ^
                        ((ze >>> 18) | (L << 14)) ^
                        ((ze << 23) | (L >>> 9)),
                      rt =
                        ((L >>> 14) | (ze << 18)) ^
                        ((L >>> 18) | (ze << 14)) ^
                        ((L << 23) | (ze >>> 9)),
                      Vt = h[D],
                      nn = Vt.high,
                      U = Vt.low,
                      O = Fe + rt,
                      Y = ht + Dt + (O >>> 0 < Fe >>> 0 ? 1 : 0),
                      O = O + re,
                      Y = Y + J + (O >>> 0 < re >>> 0 ? 1 : 0),
                      O = O + U,
                      Y = Y + nn + (O >>> 0 < U >>> 0 ? 1 : 0),
                      O = O + b,
                      Y = Y + q + (O >>> 0 < b >>> 0 ? 1 : 0),
                      oe = gt + Ee,
                      me = qe + Se + (oe >>> 0 < gt >>> 0 ? 1 : 0);
                    (ht = Ke),
                      (Fe = Be),
                      (Ke = Lt),
                      (Be = We),
                      (Lt = ze),
                      (We = L),
                      (L = (Xe + O) | 0),
                      (ze = (St + Y + (L >>> 0 < Xe >>> 0 ? 1 : 0)) | 0),
                      (St = Qe),
                      (Xe = Oe),
                      (Qe = he),
                      (Oe = de),
                      (he = te),
                      (de = fe),
                      (fe = (O + oe) | 0),
                      (te = (Y + me + (fe >>> 0 < O >>> 0 ? 1 : 0)) | 0);
                  }
                  (_ = p.low = _ + fe),
                    (p.high = M + te + (_ >>> 0 < fe >>> 0 ? 1 : 0)),
                    (F = y.low = F + de),
                    (y.high = T + he + (F >>> 0 < de >>> 0 ? 1 : 0)),
                    (I = E.low = I + Oe),
                    (E.high = P + Qe + (I >>> 0 < Oe >>> 0 ? 1 : 0)),
                    (V = v.low = V + Xe),
                    (v.high = X + St + (V >>> 0 < Xe >>> 0 ? 1 : 0)),
                    (k = C.low = k + L),
                    (C.high = ie + ze + (k >>> 0 < L >>> 0 ? 1 : 0)),
                    (ce = A.low = ce + We),
                    (A.high = ae + Lt + (ce >>> 0 < We >>> 0 ? 1 : 0)),
                    (K = S.low = K + Be),
                    (S.high = H + Ke + (K >>> 0 < Be >>> 0 ? 1 : 0)),
                    (B = R.low = B + Fe),
                    (R.high = Q + ht + (B >>> 0 < Fe >>> 0 ? 1 : 0));
                },
                _doFinalize: function () {
                  var x = this._data,
                    g = x.words,
                    d = this._nDataBytes * 8,
                    p = x.sigBytes * 8;
                  (g[p >>> 5] |= 128 << (24 - (p % 32))),
                    (g[(((p + 128) >>> 10) << 5) + 30] = Math.floor(
                      d / 4294967296,
                    )),
                    (g[(((p + 128) >>> 10) << 5) + 31] = d),
                    (x.sigBytes = g.length * 4),
                    this._process();
                  var y = this._hash.toX32();
                  return y;
                },
                clone: function () {
                  var x = s.clone.call(this);
                  return (x._hash = this._hash.clone()), x;
                },
                blockSize: 1024 / 32,
              }));
              (n.SHA512 = s._createHelper(m)),
                (n.HmacSHA512 = s._createHmacHelper(m));
            })(),
            t.SHA512
          );
        });
      })(zs)),
    zs.exports
  );
}
var ks = { exports: {} },
  N0 = ks.exports,
  Gl;
function O0() {
  return (
    Gl ||
      ((Gl = 1),
      (function (i, e) {
        (function (t, n, r) {
          i.exports = n(ct(), Da(), $f());
        })(N0, function (t) {
          return (
            (function () {
              var n = t,
                r = n.x64,
                s = r.Word,
                a = r.WordArray,
                o = n.algo,
                l = o.SHA512,
                c = (o.SHA384 = l.extend({
                  _doReset: function () {
                    this._hash = new a.init([
                      new s.init(3418070365, 3238371032),
                      new s.init(1654270250, 914150663),
                      new s.init(2438529370, 812702999),
                      new s.init(355462360, 4144912697),
                      new s.init(1731405415, 4290775857),
                      new s.init(2394180231, 1750603025),
                      new s.init(3675008525, 1694076839),
                      new s.init(1203062813, 3204075428),
                    ]);
                  },
                  _doFinalize: function () {
                    var u = l._doFinalize.call(this);
                    return (u.sigBytes -= 16), u;
                  },
                }));
              (n.SHA384 = l._createHelper(c)),
                (n.HmacSHA384 = l._createHmacHelper(c));
            })(),
            t.SHA384
          );
        });
      })(ks)),
    ks.exports
  );
}
var Hs = { exports: {} },
  z0 = Hs.exports,
  Wl;
function k0() {
  return (
    Wl ||
      ((Wl = 1),
      (function (i, e) {
        (function (t, n, r) {
          i.exports = n(ct(), Da());
        })(z0, function (t) {
          return (
            (function (n) {
              var r = t,
                s = r.lib,
                a = s.WordArray,
                o = s.Hasher,
                l = r.x64,
                c = l.Word,
                u = r.algo,
                h = [],
                f = [],
                m = [];
              (function () {
                for (var d = 1, p = 0, y = 0; y < 24; y++) {
                  h[d + 5 * p] = (((y + 1) * (y + 2)) / 2) % 64;
                  var E = p % 5,
                    v = (2 * d + 3 * p) % 5;
                  (d = E), (p = v);
                }
                for (var d = 0; d < 5; d++)
                  for (var p = 0; p < 5; p++)
                    f[d + 5 * p] = p + ((2 * d + 3 * p) % 5) * 5;
                for (var C = 1, A = 0; A < 24; A++) {
                  for (var S = 0, R = 0, M = 0; M < 7; M++) {
                    if (C & 1) {
                      var _ = (1 << M) - 1;
                      _ < 32 ? (R ^= 1 << _) : (S ^= 1 << (_ - 32));
                    }
                    C & 128 ? (C = (C << 1) ^ 113) : (C <<= 1);
                  }
                  m[A] = c.create(S, R);
                }
              })();
              var x = [];
              (function () {
                for (var d = 0; d < 25; d++) x[d] = c.create();
              })();
              var g = (u.SHA3 = o.extend({
                cfg: o.cfg.extend({ outputLength: 512 }),
                _doReset: function () {
                  for (var d = (this._state = []), p = 0; p < 25; p++)
                    d[p] = new c.init();
                  this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
                },
                _doProcessBlock: function (d, p) {
                  for (
                    var y = this._state, E = this.blockSize / 2, v = 0;
                    v < E;
                    v++
                  ) {
                    var C = d[p + 2 * v],
                      A = d[p + 2 * v + 1];
                    (C =
                      (((C << 8) | (C >>> 24)) & 16711935) |
                      (((C << 24) | (C >>> 8)) & 4278255360)),
                      (A =
                        (((A << 8) | (A >>> 24)) & 16711935) |
                        (((A << 24) | (A >>> 8)) & 4278255360));
                    var S = y[v];
                    (S.high ^= A), (S.low ^= C);
                  }
                  for (var R = 0; R < 24; R++) {
                    for (var M = 0; M < 5; M++) {
                      for (var _ = 0, T = 0, F = 0; F < 5; F++) {
                        var S = y[M + 5 * F];
                        (_ ^= S.high), (T ^= S.low);
                      }
                      var P = x[M];
                      (P.high = _), (P.low = T);
                    }
                    for (var M = 0; M < 5; M++)
                      for (
                        var I = x[(M + 4) % 5],
                          X = x[(M + 1) % 5],
                          V = X.high,
                          ie = X.low,
                          _ = I.high ^ ((V << 1) | (ie >>> 31)),
                          T = I.low ^ ((ie << 1) | (V >>> 31)),
                          F = 0;
                        F < 5;
                        F++
                      ) {
                        var S = y[M + 5 * F];
                        (S.high ^= _), (S.low ^= T);
                      }
                    for (var k = 1; k < 25; k++) {
                      var _,
                        T,
                        S = y[k],
                        ae = S.high,
                        ce = S.low,
                        H = h[k];
                      H < 32
                        ? ((_ = (ae << H) | (ce >>> (32 - H))),
                          (T = (ce << H) | (ae >>> (32 - H))))
                        : ((_ = (ce << (H - 32)) | (ae >>> (64 - H))),
                          (T = (ae << (H - 32)) | (ce >>> (64 - H))));
                      var K = x[f[k]];
                      (K.high = _), (K.low = T);
                    }
                    var Q = x[0],
                      B = y[0];
                    (Q.high = B.high), (Q.low = B.low);
                    for (var M = 0; M < 5; M++)
                      for (var F = 0; F < 5; F++) {
                        var k = M + 5 * F,
                          S = y[k],
                          te = x[k],
                          fe = x[((M + 1) % 5) + 5 * F],
                          he = x[((M + 2) % 5) + 5 * F];
                        (S.high = te.high ^ (~fe.high & he.high)),
                          (S.low = te.low ^ (~fe.low & he.low));
                      }
                    var S = y[0],
                      de = m[R];
                    (S.high ^= de.high), (S.low ^= de.low);
                  }
                },
                _doFinalize: function () {
                  var d = this._data,
                    p = d.words;
                  this._nDataBytes * 8;
                  var y = d.sigBytes * 8,
                    E = this.blockSize * 32;
                  (p[y >>> 5] |= 1 << (24 - (y % 32))),
                    (p[((n.ceil((y + 1) / E) * E) >>> 5) - 1] |= 128),
                    (d.sigBytes = p.length * 4),
                    this._process();
                  for (
                    var v = this._state,
                      C = this.cfg.outputLength / 8,
                      A = C / 8,
                      S = [],
                      R = 0;
                    R < A;
                    R++
                  ) {
                    var M = v[R],
                      _ = M.high,
                      T = M.low;
                    (_ =
                      (((_ << 8) | (_ >>> 24)) & 16711935) |
                      (((_ << 24) | (_ >>> 8)) & 4278255360)),
                      (T =
                        (((T << 8) | (T >>> 24)) & 16711935) |
                        (((T << 24) | (T >>> 8)) & 4278255360)),
                      S.push(T),
                      S.push(_);
                  }
                  return new a.init(S, C);
                },
                clone: function () {
                  for (
                    var d = o.clone.call(this),
                      p = (d._state = this._state.slice(0)),
                      y = 0;
                    y < 25;
                    y++
                  )
                    p[y] = p[y].clone();
                  return d;
                },
              }));
              (r.SHA3 = o._createHelper(g)),
                (r.HmacSHA3 = o._createHmacHelper(g));
            })(Math),
            t.SHA3
          );
        });
      })(Hs)),
    Hs.exports
  );
}
var Vs = { exports: {} },
  H0 = Vs.exports,
  Xl;
function V0() {
  return (
    Xl ||
      ((Xl = 1),
      (function (i, e) {
        (function (t, n) {
          i.exports = n(ct());
        })(H0, function (t) {
          /** @preserve
			(c) 2012 by Cdric Mesnil. All rights reserved.

			Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

			    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
			    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

			THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
			*/ return (
            (function (n) {
              var r = t,
                s = r.lib,
                a = s.WordArray,
                o = s.Hasher,
                l = r.algo,
                c = a.create([
                  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4,
                  13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4,
                  9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8,
                  12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10,
                  14, 1, 3, 8, 11, 6, 15, 13,
                ]),
                u = a.create([
                  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11,
                  3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7,
                  14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15,
                  0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6,
                  2, 13, 14, 0, 3, 9, 11,
                ]),
                h = a.create([
                  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6,
                  8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6,
                  7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15,
                  14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8,
                  13, 12, 5, 12, 13, 14, 11, 8, 5, 6,
                ]),
                f = a.create([
                  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13,
                  15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11,
                  8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14,
                  14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14,
                  6, 8, 13, 6, 5, 15, 13, 11, 11,
                ]),
                m = a.create([
                  0, 1518500249, 1859775393, 2400959708, 2840853838,
                ]),
                x = a.create([
                  1352829926, 1548603684, 1836072691, 2053994217, 0,
                ]),
                g = (l.RIPEMD160 = o.extend({
                  _doReset: function () {
                    this._hash = a.create([
                      1732584193, 4023233417, 2562383102, 271733878, 3285377520,
                    ]);
                  },
                  _doProcessBlock: function (A, S) {
                    for (var R = 0; R < 16; R++) {
                      var M = S + R,
                        _ = A[M];
                      A[M] =
                        (((_ << 8) | (_ >>> 24)) & 16711935) |
                        (((_ << 24) | (_ >>> 8)) & 4278255360);
                    }
                    var T = this._hash.words,
                      F = m.words,
                      P = x.words,
                      I = c.words,
                      X = u.words,
                      V = h.words,
                      ie = f.words,
                      k,
                      ae,
                      ce,
                      H,
                      K,
                      Q,
                      B,
                      te,
                      fe,
                      he;
                    (Q = k = T[0]),
                      (B = ae = T[1]),
                      (te = ce = T[2]),
                      (fe = H = T[3]),
                      (he = K = T[4]);
                    for (var de, R = 0; R < 80; R += 1)
                      (de = (k + A[S + I[R]]) | 0),
                        R < 16
                          ? (de += d(ae, ce, H) + F[0])
                          : R < 32
                            ? (de += p(ae, ce, H) + F[1])
                            : R < 48
                              ? (de += y(ae, ce, H) + F[2])
                              : R < 64
                                ? (de += E(ae, ce, H) + F[3])
                                : (de += v(ae, ce, H) + F[4]),
                        (de = de | 0),
                        (de = C(de, V[R])),
                        (de = (de + K) | 0),
                        (k = K),
                        (K = H),
                        (H = C(ce, 10)),
                        (ce = ae),
                        (ae = de),
                        (de = (Q + A[S + X[R]]) | 0),
                        R < 16
                          ? (de += v(B, te, fe) + P[0])
                          : R < 32
                            ? (de += E(B, te, fe) + P[1])
                            : R < 48
                              ? (de += y(B, te, fe) + P[2])
                              : R < 64
                                ? (de += p(B, te, fe) + P[3])
                                : (de += d(B, te, fe) + P[4]),
                        (de = de | 0),
                        (de = C(de, ie[R])),
                        (de = (de + he) | 0),
                        (Q = he),
                        (he = fe),
                        (fe = C(te, 10)),
                        (te = B),
                        (B = de);
                    (de = (T[1] + ce + fe) | 0),
                      (T[1] = (T[2] + H + he) | 0),
                      (T[2] = (T[3] + K + Q) | 0),
                      (T[3] = (T[4] + k + B) | 0),
                      (T[4] = (T[0] + ae + te) | 0),
                      (T[0] = de);
                  },
                  _doFinalize: function () {
                    var A = this._data,
                      S = A.words,
                      R = this._nDataBytes * 8,
                      M = A.sigBytes * 8;
                    (S[M >>> 5] |= 128 << (24 - (M % 32))),
                      (S[(((M + 64) >>> 9) << 4) + 14] =
                        (((R << 8) | (R >>> 24)) & 16711935) |
                        (((R << 24) | (R >>> 8)) & 4278255360)),
                      (A.sigBytes = (S.length + 1) * 4),
                      this._process();
                    for (var _ = this._hash, T = _.words, F = 0; F < 5; F++) {
                      var P = T[F];
                      T[F] =
                        (((P << 8) | (P >>> 24)) & 16711935) |
                        (((P << 24) | (P >>> 8)) & 4278255360);
                    }
                    return _;
                  },
                  clone: function () {
                    var A = o.clone.call(this);
                    return (A._hash = this._hash.clone()), A;
                  },
                }));
              function d(A, S, R) {
                return A ^ S ^ R;
              }
              function p(A, S, R) {
                return (A & S) | (~A & R);
              }
              function y(A, S, R) {
                return (A | ~S) ^ R;
              }
              function E(A, S, R) {
                return (A & R) | (S & ~R);
              }
              function v(A, S, R) {
                return A ^ (S | ~R);
              }
              function C(A, S) {
                return (A << S) | (A >>> (32 - S));
              }
              (r.RIPEMD160 = o._createHelper(g)),
                (r.HmacRIPEMD160 = o._createHmacHelper(g));
            })(),
            t.RIPEMD160
          );
        });
      })(Vs)),
    Vs.exports
  );
}
var Gs = { exports: {} },
  G0 = Gs.exports,
  ql;
function Gc() {
  return (
    ql ||
      ((ql = 1),
      (function (i, e) {
        (function (t, n) {
          i.exports = n(ct());
        })(G0, function (t) {
          (function () {
            var n = t,
              r = n.lib,
              s = r.Base,
              a = n.enc,
              o = a.Utf8,
              l = n.algo;
            l.HMAC = s.extend({
              init: function (c, u) {
                (c = this._hasher = new c.init()),
                  typeof u == "string" && (u = o.parse(u));
                var h = c.blockSize,
                  f = h * 4;
                u.sigBytes > f && (u = c.finalize(u)), u.clamp();
                for (
                  var m = (this._oKey = u.clone()),
                    x = (this._iKey = u.clone()),
                    g = m.words,
                    d = x.words,
                    p = 0;
                  p < h;
                  p++
                )
                  (g[p] ^= 1549556828), (d[p] ^= 909522486);
                (m.sigBytes = x.sigBytes = f), this.reset();
              },
              reset: function () {
                var c = this._hasher;
                c.reset(), c.update(this._iKey);
              },
              update: function (c) {
                return this._hasher.update(c), this;
              },
              finalize: function (c) {
                var u = this._hasher,
                  h = u.finalize(c);
                u.reset();
                var f = u.finalize(this._oKey.clone().concat(h));
                return f;
              },
            });
          })();
        });
      })(Gs)),
    Gs.exports
  );
}
var Ws = { exports: {} },
  W0 = Ws.exports,
  Yl;
function X0() {
  return (
    Yl ||
      ((Yl = 1),
      (function (i, e) {
        (function (t, n, r) {
          i.exports = n(ct(), Vc(), Gc());
        })(W0, function (t) {
          return (
            (function () {
              var n = t,
                r = n.lib,
                s = r.Base,
                a = r.WordArray,
                o = n.algo,
                l = o.SHA256,
                c = o.HMAC,
                u = (o.PBKDF2 = s.extend({
                  cfg: s.extend({
                    keySize: 128 / 32,
                    hasher: l,
                    iterations: 25e4,
                  }),
                  init: function (h) {
                    this.cfg = this.cfg.extend(h);
                  },
                  compute: function (h, f) {
                    for (
                      var m = this.cfg,
                        x = c.create(m.hasher, h),
                        g = a.create(),
                        d = a.create([1]),
                        p = g.words,
                        y = d.words,
                        E = m.keySize,
                        v = m.iterations;
                      p.length < E;

                    ) {
                      var C = x.update(f).finalize(d);
                      x.reset();
                      for (
                        var A = C.words, S = A.length, R = C, M = 1;
                        M < v;
                        M++
                      ) {
                        (R = x.finalize(R)), x.reset();
                        for (var _ = R.words, T = 0; T < S; T++) A[T] ^= _[T];
                      }
                      g.concat(C), y[0]++;
                    }
                    return (g.sigBytes = E * 4), g;
                  },
                }));
              n.PBKDF2 = function (h, f, m) {
                return u.create(m).compute(h, f);
              };
            })(),
            t.PBKDF2
          );
        });
      })(Ws)),
    Ws.exports
  );
}
var Xs = { exports: {} },
  q0 = Xs.exports,
  $l;
function oi() {
  return (
    $l ||
      (($l = 1),
      (function (i, e) {
        (function (t, n, r) {
          i.exports = n(ct(), Yf(), Gc());
        })(q0, function (t) {
          return (
            (function () {
              var n = t,
                r = n.lib,
                s = r.Base,
                a = r.WordArray,
                o = n.algo,
                l = o.MD5,
                c = (o.EvpKDF = s.extend({
                  cfg: s.extend({
                    keySize: 128 / 32,
                    hasher: l,
                    iterations: 1,
                  }),
                  init: function (u) {
                    this.cfg = this.cfg.extend(u);
                  },
                  compute: function (u, h) {
                    for (
                      var f,
                        m = this.cfg,
                        x = m.hasher.create(),
                        g = a.create(),
                        d = g.words,
                        p = m.keySize,
                        y = m.iterations;
                      d.length < p;

                    ) {
                      f && x.update(f),
                        (f = x.update(u).finalize(h)),
                        x.reset();
                      for (var E = 1; E < y; E++)
                        (f = x.finalize(f)), x.reset();
                      g.concat(f);
                    }
                    return (g.sigBytes = p * 4), g;
                  },
                }));
              n.EvpKDF = function (u, h, f) {
                return c.create(f).compute(u, h);
              };
            })(),
            t.EvpKDF
          );
        });
      })(Xs)),
    Xs.exports
  );
}
var qs = { exports: {} },
  Y0 = qs.exports,
  jl;
function kt() {
  return (
    jl ||
      ((jl = 1),
      (function (i, e) {
        (function (t, n, r) {
          i.exports = n(ct(), oi());
        })(Y0, function (t) {
          t.lib.Cipher ||
            (function (n) {
              var r = t,
                s = r.lib,
                a = s.Base,
                o = s.WordArray,
                l = s.BufferedBlockAlgorithm,
                c = r.enc;
              c.Utf8;
              var u = c.Base64,
                h = r.algo,
                f = h.EvpKDF,
                m = (s.Cipher = l.extend({
                  cfg: a.extend(),
                  createEncryptor: function (_, T) {
                    return this.create(this._ENC_XFORM_MODE, _, T);
                  },
                  createDecryptor: function (_, T) {
                    return this.create(this._DEC_XFORM_MODE, _, T);
                  },
                  init: function (_, T, F) {
                    (this.cfg = this.cfg.extend(F)),
                      (this._xformMode = _),
                      (this._key = T),
                      this.reset();
                  },
                  reset: function () {
                    l.reset.call(this), this._doReset();
                  },
                  process: function (_) {
                    return this._append(_), this._process();
                  },
                  finalize: function (_) {
                    _ && this._append(_);
                    var T = this._doFinalize();
                    return T;
                  },
                  keySize: 128 / 32,
                  ivSize: 128 / 32,
                  _ENC_XFORM_MODE: 1,
                  _DEC_XFORM_MODE: 2,
                  _createHelper: (function () {
                    function _(T) {
                      return typeof T == "string" ? M : A;
                    }
                    return function (T) {
                      return {
                        encrypt: function (F, P, I) {
                          return _(P).encrypt(T, F, P, I);
                        },
                        decrypt: function (F, P, I) {
                          return _(P).decrypt(T, F, P, I);
                        },
                      };
                    };
                  })(),
                }));
              s.StreamCipher = m.extend({
                _doFinalize: function () {
                  var _ = this._process(!0);
                  return _;
                },
                blockSize: 1,
              });
              var x = (r.mode = {}),
                g = (s.BlockCipherMode = a.extend({
                  createEncryptor: function (_, T) {
                    return this.Encryptor.create(_, T);
                  },
                  createDecryptor: function (_, T) {
                    return this.Decryptor.create(_, T);
                  },
                  init: function (_, T) {
                    (this._cipher = _), (this._iv = T);
                  },
                })),
                d = (x.CBC = (function () {
                  var _ = g.extend();
                  (_.Encryptor = _.extend({
                    processBlock: function (F, P) {
                      var I = this._cipher,
                        X = I.blockSize;
                      T.call(this, F, P, X),
                        I.encryptBlock(F, P),
                        (this._prevBlock = F.slice(P, P + X));
                    },
                  })),
                    (_.Decryptor = _.extend({
                      processBlock: function (F, P) {
                        var I = this._cipher,
                          X = I.blockSize,
                          V = F.slice(P, P + X);
                        I.decryptBlock(F, P),
                          T.call(this, F, P, X),
                          (this._prevBlock = V);
                      },
                    }));
                  function T(F, P, I) {
                    var X,
                      V = this._iv;
                    V ? ((X = V), (this._iv = n)) : (X = this._prevBlock);
                    for (var ie = 0; ie < I; ie++) F[P + ie] ^= X[ie];
                  }
                  return _;
                })()),
                p = (r.pad = {}),
                y = (p.Pkcs7 = {
                  pad: function (_, T) {
                    for (
                      var F = T * 4,
                        P = F - (_.sigBytes % F),
                        I = (P << 24) | (P << 16) | (P << 8) | P,
                        X = [],
                        V = 0;
                      V < P;
                      V += 4
                    )
                      X.push(I);
                    var ie = o.create(X, P);
                    _.concat(ie);
                  },
                  unpad: function (_) {
                    var T = _.words[(_.sigBytes - 1) >>> 2] & 255;
                    _.sigBytes -= T;
                  },
                });
              s.BlockCipher = m.extend({
                cfg: m.cfg.extend({ mode: d, padding: y }),
                reset: function () {
                  var _;
                  m.reset.call(this);
                  var T = this.cfg,
                    F = T.iv,
                    P = T.mode;
                  this._xformMode == this._ENC_XFORM_MODE
                    ? (_ = P.createEncryptor)
                    : ((_ = P.createDecryptor), (this._minBufferSize = 1)),
                    this._mode && this._mode.__creator == _
                      ? this._mode.init(this, F && F.words)
                      : ((this._mode = _.call(P, this, F && F.words)),
                        (this._mode.__creator = _));
                },
                _doProcessBlock: function (_, T) {
                  this._mode.processBlock(_, T);
                },
                _doFinalize: function () {
                  var _,
                    T = this.cfg.padding;
                  return (
                    this._xformMode == this._ENC_XFORM_MODE
                      ? (T.pad(this._data, this.blockSize),
                        (_ = this._process(!0)))
                      : ((_ = this._process(!0)), T.unpad(_)),
                    _
                  );
                },
                blockSize: 128 / 32,
              });
              var E = (s.CipherParams = a.extend({
                  init: function (_) {
                    this.mixIn(_);
                  },
                  toString: function (_) {
                    return (_ || this.formatter).stringify(this);
                  },
                })),
                v = (r.format = {}),
                C = (v.OpenSSL = {
                  stringify: function (_) {
                    var T,
                      F = _.ciphertext,
                      P = _.salt;
                    return (
                      P
                        ? (T = o
                            .create([1398893684, 1701076831])
                            .concat(P)
                            .concat(F))
                        : (T = F),
                      T.toString(u)
                    );
                  },
                  parse: function (_) {
                    var T,
                      F = u.parse(_),
                      P = F.words;
                    return (
                      P[0] == 1398893684 &&
                        P[1] == 1701076831 &&
                        ((T = o.create(P.slice(2, 4))),
                        P.splice(0, 4),
                        (F.sigBytes -= 16)),
                      E.create({ ciphertext: F, salt: T })
                    );
                  },
                }),
                A = (s.SerializableCipher = a.extend({
                  cfg: a.extend({ format: C }),
                  encrypt: function (_, T, F, P) {
                    P = this.cfg.extend(P);
                    var I = _.createEncryptor(F, P),
                      X = I.finalize(T),
                      V = I.cfg;
                    return E.create({
                      ciphertext: X,
                      key: F,
                      iv: V.iv,
                      algorithm: _,
                      mode: V.mode,
                      padding: V.padding,
                      blockSize: _.blockSize,
                      formatter: P.format,
                    });
                  },
                  decrypt: function (_, T, F, P) {
                    (P = this.cfg.extend(P)), (T = this._parse(T, P.format));
                    var I = _.createDecryptor(F, P).finalize(T.ciphertext);
                    return I;
                  },
                  _parse: function (_, T) {
                    return typeof _ == "string" ? T.parse(_, this) : _;
                  },
                })),
                S = (r.kdf = {}),
                R = (S.OpenSSL = {
                  execute: function (_, T, F, P, I) {
                    if ((P || (P = o.random(64 / 8)), I))
                      var X = f
                        .create({ keySize: T + F, hasher: I })
                        .compute(_, P);
                    else var X = f.create({ keySize: T + F }).compute(_, P);
                    var V = o.create(X.words.slice(T), F * 4);
                    return (
                      (X.sigBytes = T * 4), E.create({ key: X, iv: V, salt: P })
                    );
                  },
                }),
                M = (s.PasswordBasedCipher = A.extend({
                  cfg: A.cfg.extend({ kdf: R }),
                  encrypt: function (_, T, F, P) {
                    P = this.cfg.extend(P);
                    var I = P.kdf.execute(
                      F,
                      _.keySize,
                      _.ivSize,
                      P.salt,
                      P.hasher,
                    );
                    P.iv = I.iv;
                    var X = A.encrypt.call(this, _, T, I.key, P);
                    return X.mixIn(I), X;
                  },
                  decrypt: function (_, T, F, P) {
                    (P = this.cfg.extend(P)), (T = this._parse(T, P.format));
                    var I = P.kdf.execute(
                      F,
                      _.keySize,
                      _.ivSize,
                      T.salt,
                      P.hasher,
                    );
                    P.iv = I.iv;
                    var X = A.decrypt.call(this, _, T, I.key, P);
                    return X;
                  },
                }));
            })();
        });
      })(qs)),
    qs.exports
  );
}
var Ys = { exports: {} },
  $0 = Ys.exports,
  Kl;
function j0() {
  return (
    Kl ||
      ((Kl = 1),
      (function (i, e) {
        (function (t, n, r) {
          i.exports = n(ct(), kt());
        })($0, function (t) {
          return (
            (t.mode.CFB = (function () {
              var n = t.lib.BlockCipherMode.extend();
              (n.Encryptor = n.extend({
                processBlock: function (s, a) {
                  var o = this._cipher,
                    l = o.blockSize;
                  r.call(this, s, a, l, o),
                    (this._prevBlock = s.slice(a, a + l));
                },
              })),
                (n.Decryptor = n.extend({
                  processBlock: function (s, a) {
                    var o = this._cipher,
                      l = o.blockSize,
                      c = s.slice(a, a + l);
                    r.call(this, s, a, l, o), (this._prevBlock = c);
                  },
                }));
              function r(s, a, o, l) {
                var c,
                  u = this._iv;
                u
                  ? ((c = u.slice(0)), (this._iv = void 0))
                  : (c = this._prevBlock),
                  l.encryptBlock(c, 0);
                for (var h = 0; h < o; h++) s[a + h] ^= c[h];
              }
              return n;
            })()),
            t.mode.CFB
          );
        });
      })(Ys)),
    Ys.exports
  );
}
var $s = { exports: {} },
  K0 = $s.exports,
  Zl;
function Z0() {
  return (
    Zl ||
      ((Zl = 1),
      (function (i, e) {
        (function (t, n, r) {
          i.exports = n(ct(), kt());
        })(K0, function (t) {
          return (
            (t.mode.CTR = (function () {
              var n = t.lib.BlockCipherMode.extend(),
                r = (n.Encryptor = n.extend({
                  processBlock: function (s, a) {
                    var o = this._cipher,
                      l = o.blockSize,
                      c = this._iv,
                      u = this._counter;
                    c &&
                      ((u = this._counter = c.slice(0)), (this._iv = void 0));
                    var h = u.slice(0);
                    o.encryptBlock(h, 0), (u[l - 1] = (u[l - 1] + 1) | 0);
                    for (var f = 0; f < l; f++) s[a + f] ^= h[f];
                  },
                }));
              return (n.Decryptor = r), n;
            })()),
            t.mode.CTR
          );
        });
      })($s)),
    $s.exports
  );
}
var js = { exports: {} },
  J0 = js.exports,
  Jl;
function Q0() {
  return (
    Jl ||
      ((Jl = 1),
      (function (i, e) {
        (function (t, n, r) {
          i.exports = n(ct(), kt());
        })(J0, function (t) {
          /** @preserve
           * Counter block mode compatible with  Dr Brian Gladman fileenc.c
           * derived from CryptoJS.mode.CTR
           * Jan Hruby jhruby.web@gmail.com
           */ return (
            (t.mode.CTRGladman = (function () {
              var n = t.lib.BlockCipherMode.extend();
              function r(o) {
                if (((o >> 24) & 255) === 255) {
                  var l = (o >> 16) & 255,
                    c = (o >> 8) & 255,
                    u = o & 255;
                  l === 255
                    ? ((l = 0),
                      c === 255 ? ((c = 0), u === 255 ? (u = 0) : ++u) : ++c)
                    : ++l,
                    (o = 0),
                    (o += l << 16),
                    (o += c << 8),
                    (o += u);
                } else o += 1 << 24;
                return o;
              }
              function s(o) {
                return (o[0] = r(o[0])) === 0 && (o[1] = r(o[1])), o;
              }
              var a = (n.Encryptor = n.extend({
                processBlock: function (o, l) {
                  var c = this._cipher,
                    u = c.blockSize,
                    h = this._iv,
                    f = this._counter;
                  h && ((f = this._counter = h.slice(0)), (this._iv = void 0)),
                    s(f);
                  var m = f.slice(0);
                  c.encryptBlock(m, 0);
                  for (var x = 0; x < u; x++) o[l + x] ^= m[x];
                },
              }));
              return (n.Decryptor = a), n;
            })()),
            t.mode.CTRGladman
          );
        });
      })(js)),
    js.exports
  );
}
var Ks = { exports: {} },
  ep = Ks.exports,
  Ql;
function tp() {
  return (
    Ql ||
      ((Ql = 1),
      (function (i, e) {
        (function (t, n, r) {
          i.exports = n(ct(), kt());
        })(ep, function (t) {
          return (
            (t.mode.OFB = (function () {
              var n = t.lib.BlockCipherMode.extend(),
                r = (n.Encryptor = n.extend({
                  processBlock: function (s, a) {
                    var o = this._cipher,
                      l = o.blockSize,
                      c = this._iv,
                      u = this._keystream;
                    c &&
                      ((u = this._keystream = c.slice(0)), (this._iv = void 0)),
                      o.encryptBlock(u, 0);
                    for (var h = 0; h < l; h++) s[a + h] ^= u[h];
                  },
                }));
              return (n.Decryptor = r), n;
            })()),
            t.mode.OFB
          );
        });
      })(Ks)),
    Ks.exports
  );
}
var Zs = { exports: {} },
  np = Zs.exports,
  eu;
function ip() {
  return (
    eu ||
      ((eu = 1),
      (function (i, e) {
        (function (t, n, r) {
          i.exports = n(ct(), kt());
        })(np, function (t) {
          return (
            (t.mode.ECB = (function () {
              var n = t.lib.BlockCipherMode.extend();
              return (
                (n.Encryptor = n.extend({
                  processBlock: function (r, s) {
                    this._cipher.encryptBlock(r, s);
                  },
                })),
                (n.Decryptor = n.extend({
                  processBlock: function (r, s) {
                    this._cipher.decryptBlock(r, s);
                  },
                })),
                n
              );
            })()),
            t.mode.ECB
          );
        });
      })(Zs)),
    Zs.exports
  );
}
var Js = { exports: {} },
  rp = Js.exports,
  tu;
function sp() {
  return (
    tu ||
      ((tu = 1),
      (function (i, e) {
        (function (t, n, r) {
          i.exports = n(ct(), kt());
        })(rp, function (t) {
          return (
            (t.pad.AnsiX923 = {
              pad: function (n, r) {
                var s = n.sigBytes,
                  a = r * 4,
                  o = a - (s % a),
                  l = s + o - 1;
                n.clamp(),
                  (n.words[l >>> 2] |= o << (24 - (l % 4) * 8)),
                  (n.sigBytes += o);
              },
              unpad: function (n) {
                var r = n.words[(n.sigBytes - 1) >>> 2] & 255;
                n.sigBytes -= r;
              },
            }),
            t.pad.Ansix923
          );
        });
      })(Js)),
    Js.exports
  );
}
var Qs = { exports: {} },
  ap = Qs.exports,
  nu;
function op() {
  return (
    nu ||
      ((nu = 1),
      (function (i, e) {
        (function (t, n, r) {
          i.exports = n(ct(), kt());
        })(ap, function (t) {
          return (
            (t.pad.Iso10126 = {
              pad: function (n, r) {
                var s = r * 4,
                  a = s - (n.sigBytes % s);
                n.concat(t.lib.WordArray.random(a - 1)).concat(
                  t.lib.WordArray.create([a << 24], 1),
                );
              },
              unpad: function (n) {
                var r = n.words[(n.sigBytes - 1) >>> 2] & 255;
                n.sigBytes -= r;
              },
            }),
            t.pad.Iso10126
          );
        });
      })(Qs)),
    Qs.exports
  );
}
var ea = { exports: {} },
  cp = ea.exports,
  iu;
function lp() {
  return (
    iu ||
      ((iu = 1),
      (function (i, e) {
        (function (t, n, r) {
          i.exports = n(ct(), kt());
        })(cp, function (t) {
          return (
            (t.pad.Iso97971 = {
              pad: function (n, r) {
                n.concat(t.lib.WordArray.create([2147483648], 1)),
                  t.pad.ZeroPadding.pad(n, r);
              },
              unpad: function (n) {
                t.pad.ZeroPadding.unpad(n), n.sigBytes--;
              },
            }),
            t.pad.Iso97971
          );
        });
      })(ea)),
    ea.exports
  );
}
var ta = { exports: {} },
  up = ta.exports,
  ru;
function fp() {
  return (
    ru ||
      ((ru = 1),
      (function (i, e) {
        (function (t, n, r) {
          i.exports = n(ct(), kt());
        })(up, function (t) {
          return (
            (t.pad.ZeroPadding = {
              pad: function (n, r) {
                var s = r * 4;
                n.clamp(), (n.sigBytes += s - (n.sigBytes % s || s));
              },
              unpad: function (n) {
                for (
                  var r = n.words, s = n.sigBytes - 1, s = n.sigBytes - 1;
                  s >= 0;
                  s--
                )
                  if ((r[s >>> 2] >>> (24 - (s % 4) * 8)) & 255) {
                    n.sigBytes = s + 1;
                    break;
                  }
              },
            }),
            t.pad.ZeroPadding
          );
        });
      })(ta)),
    ta.exports
  );
}
var na = { exports: {} },
  hp = na.exports,
  su;
function dp() {
  return (
    su ||
      ((su = 1),
      (function (i, e) {
        (function (t, n, r) {
          i.exports = n(ct(), kt());
        })(hp, function (t) {
          return (
            (t.pad.NoPadding = { pad: function () {}, unpad: function () {} }),
            t.pad.NoPadding
          );
        });
      })(na)),
    na.exports
  );
}
var ia = { exports: {} },
  pp = ia.exports,
  au;
function mp() {
  return (
    au ||
      ((au = 1),
      (function (i, e) {
        (function (t, n, r) {
          i.exports = n(ct(), kt());
        })(pp, function (t) {
          return (
            (function (n) {
              var r = t,
                s = r.lib,
                a = s.CipherParams,
                o = r.enc,
                l = o.Hex,
                c = r.format;
              c.Hex = {
                stringify: function (u) {
                  return u.ciphertext.toString(l);
                },
                parse: function (u) {
                  var h = l.parse(u);
                  return a.create({ ciphertext: h });
                },
              };
            })(),
            t.format.Hex
          );
        });
      })(ia)),
    ia.exports
  );
}
var ra = { exports: {} },
  xp = ra.exports,
  ou;
function gp() {
  return (
    ou ||
      ((ou = 1),
      (function (i, e) {
        (function (t, n, r) {
          i.exports = n(ct(), Di(), Pi(), oi(), kt());
        })(xp, function (t) {
          return (
            (function () {
              var n = t,
                r = n.lib,
                s = r.BlockCipher,
                a = n.algo,
                o = [],
                l = [],
                c = [],
                u = [],
                h = [],
                f = [],
                m = [],
                x = [],
                g = [],
                d = [];
              (function () {
                for (var E = [], v = 0; v < 256; v++)
                  v < 128 ? (E[v] = v << 1) : (E[v] = (v << 1) ^ 283);
                for (var C = 0, A = 0, v = 0; v < 256; v++) {
                  var S = A ^ (A << 1) ^ (A << 2) ^ (A << 3) ^ (A << 4);
                  (S = (S >>> 8) ^ (S & 255) ^ 99), (o[C] = S), (l[S] = C);
                  var R = E[C],
                    M = E[R],
                    _ = E[M],
                    T = (E[S] * 257) ^ (S * 16843008);
                  (c[C] = (T << 24) | (T >>> 8)),
                    (u[C] = (T << 16) | (T >>> 16)),
                    (h[C] = (T << 8) | (T >>> 24)),
                    (f[C] = T);
                  var T =
                    (_ * 16843009) ^ (M * 65537) ^ (R * 257) ^ (C * 16843008);
                  (m[S] = (T << 24) | (T >>> 8)),
                    (x[S] = (T << 16) | (T >>> 16)),
                    (g[S] = (T << 8) | (T >>> 24)),
                    (d[S] = T),
                    C
                      ? ((C = R ^ E[E[E[_ ^ R]]]), (A ^= E[E[A]]))
                      : (C = A = 1);
                }
              })();
              var p = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
                y = (a.AES = s.extend({
                  _doReset: function () {
                    var E;
                    if (!(this._nRounds && this._keyPriorReset === this._key)) {
                      for (
                        var v = (this._keyPriorReset = this._key),
                          C = v.words,
                          A = v.sigBytes / 4,
                          S = (this._nRounds = A + 6),
                          R = (S + 1) * 4,
                          M = (this._keySchedule = []),
                          _ = 0;
                        _ < R;
                        _++
                      )
                        _ < A
                          ? (M[_] = C[_])
                          : ((E = M[_ - 1]),
                            _ % A
                              ? A > 6 &&
                                _ % A == 4 &&
                                (E =
                                  (o[E >>> 24] << 24) |
                                  (o[(E >>> 16) & 255] << 16) |
                                  (o[(E >>> 8) & 255] << 8) |
                                  o[E & 255])
                              : ((E = (E << 8) | (E >>> 24)),
                                (E =
                                  (o[E >>> 24] << 24) |
                                  (o[(E >>> 16) & 255] << 16) |
                                  (o[(E >>> 8) & 255] << 8) |
                                  o[E & 255]),
                                (E ^= p[(_ / A) | 0] << 24)),
                            (M[_] = M[_ - A] ^ E));
                      for (
                        var T = (this._invKeySchedule = []), F = 0;
                        F < R;
                        F++
                      ) {
                        var _ = R - F;
                        if (F % 4) var E = M[_];
                        else var E = M[_ - 4];
                        F < 4 || _ <= 4
                          ? (T[F] = E)
                          : (T[F] =
                              m[o[E >>> 24]] ^
                              x[o[(E >>> 16) & 255]] ^
                              g[o[(E >>> 8) & 255]] ^
                              d[o[E & 255]]);
                      }
                    }
                  },
                  encryptBlock: function (E, v) {
                    this._doCryptBlock(E, v, this._keySchedule, c, u, h, f, o);
                  },
                  decryptBlock: function (E, v) {
                    var C = E[v + 1];
                    (E[v + 1] = E[v + 3]),
                      (E[v + 3] = C),
                      this._doCryptBlock(
                        E,
                        v,
                        this._invKeySchedule,
                        m,
                        x,
                        g,
                        d,
                        l,
                      );
                    var C = E[v + 1];
                    (E[v + 1] = E[v + 3]), (E[v + 3] = C);
                  },
                  _doCryptBlock: function (E, v, C, A, S, R, M, _) {
                    for (
                      var T = this._nRounds,
                        F = E[v] ^ C[0],
                        P = E[v + 1] ^ C[1],
                        I = E[v + 2] ^ C[2],
                        X = E[v + 3] ^ C[3],
                        V = 4,
                        ie = 1;
                      ie < T;
                      ie++
                    ) {
                      var k =
                          A[F >>> 24] ^
                          S[(P >>> 16) & 255] ^
                          R[(I >>> 8) & 255] ^
                          M[X & 255] ^
                          C[V++],
                        ae =
                          A[P >>> 24] ^
                          S[(I >>> 16) & 255] ^
                          R[(X >>> 8) & 255] ^
                          M[F & 255] ^
                          C[V++],
                        ce =
                          A[I >>> 24] ^
                          S[(X >>> 16) & 255] ^
                          R[(F >>> 8) & 255] ^
                          M[P & 255] ^
                          C[V++],
                        H =
                          A[X >>> 24] ^
                          S[(F >>> 16) & 255] ^
                          R[(P >>> 8) & 255] ^
                          M[I & 255] ^
                          C[V++];
                      (F = k), (P = ae), (I = ce), (X = H);
                    }
                    var k =
                        ((_[F >>> 24] << 24) |
                          (_[(P >>> 16) & 255] << 16) |
                          (_[(I >>> 8) & 255] << 8) |
                          _[X & 255]) ^
                        C[V++],
                      ae =
                        ((_[P >>> 24] << 24) |
                          (_[(I >>> 16) & 255] << 16) |
                          (_[(X >>> 8) & 255] << 8) |
                          _[F & 255]) ^
                        C[V++],
                      ce =
                        ((_[I >>> 24] << 24) |
                          (_[(X >>> 16) & 255] << 16) |
                          (_[(F >>> 8) & 255] << 8) |
                          _[P & 255]) ^
                        C[V++],
                      H =
                        ((_[X >>> 24] << 24) |
                          (_[(F >>> 16) & 255] << 16) |
                          (_[(P >>> 8) & 255] << 8) |
                          _[I & 255]) ^
                        C[V++];
                    (E[v] = k),
                      (E[v + 1] = ae),
                      (E[v + 2] = ce),
                      (E[v + 3] = H);
                  },
                  keySize: 256 / 32,
                }));
              n.AES = s._createHelper(y);
            })(),
            t.AES
          );
        });
      })(ra)),
    ra.exports
  );
}
var sa = { exports: {} },
  _p = sa.exports,
  cu;
function vp() {
  return (
    cu ||
      ((cu = 1),
      (function (i, e) {
        (function (t, n, r) {
          i.exports = n(ct(), Di(), Pi(), oi(), kt());
        })(_p, function (t) {
          return (
            (function () {
              var n = t,
                r = n.lib,
                s = r.WordArray,
                a = r.BlockCipher,
                o = n.algo,
                l = [
                  57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2,
                  59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39,
                  31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37,
                  29, 21, 13, 5, 28, 20, 12, 4,
                ],
                c = [
                  14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26,
                  8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51,
                  45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32,
                ],
                u = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28],
                h = [
                  {
                    0: 8421888,
                    268435456: 32768,
                    536870912: 8421378,
                    805306368: 2,
                    1073741824: 512,
                    1342177280: 8421890,
                    1610612736: 8389122,
                    1879048192: 8388608,
                    2147483648: 514,
                    2415919104: 8389120,
                    2684354560: 33280,
                    2952790016: 8421376,
                    3221225472: 32770,
                    3489660928: 8388610,
                    3758096384: 0,
                    4026531840: 33282,
                    134217728: 0,
                    402653184: 8421890,
                    671088640: 33282,
                    939524096: 32768,
                    1207959552: 8421888,
                    1476395008: 512,
                    1744830464: 8421378,
                    2013265920: 2,
                    2281701376: 8389120,
                    2550136832: 33280,
                    2818572288: 8421376,
                    3087007744: 8389122,
                    3355443200: 8388610,
                    3623878656: 32770,
                    3892314112: 514,
                    4160749568: 8388608,
                    1: 32768,
                    268435457: 2,
                    536870913: 8421888,
                    805306369: 8388608,
                    1073741825: 8421378,
                    1342177281: 33280,
                    1610612737: 512,
                    1879048193: 8389122,
                    2147483649: 8421890,
                    2415919105: 8421376,
                    2684354561: 8388610,
                    2952790017: 33282,
                    3221225473: 514,
                    3489660929: 8389120,
                    3758096385: 32770,
                    4026531841: 0,
                    134217729: 8421890,
                    402653185: 8421376,
                    671088641: 8388608,
                    939524097: 512,
                    1207959553: 32768,
                    1476395009: 8388610,
                    1744830465: 2,
                    2013265921: 33282,
                    2281701377: 32770,
                    2550136833: 8389122,
                    2818572289: 514,
                    3087007745: 8421888,
                    3355443201: 8389120,
                    3623878657: 0,
                    3892314113: 33280,
                    4160749569: 8421378,
                  },
                  {
                    0: 1074282512,
                    16777216: 16384,
                    33554432: 524288,
                    50331648: 1074266128,
                    67108864: 1073741840,
                    83886080: 1074282496,
                    100663296: 1073758208,
                    117440512: 16,
                    134217728: 540672,
                    150994944: 1073758224,
                    167772160: 1073741824,
                    184549376: 540688,
                    201326592: 524304,
                    218103808: 0,
                    234881024: 16400,
                    251658240: 1074266112,
                    8388608: 1073758208,
                    25165824: 540688,
                    41943040: 16,
                    58720256: 1073758224,
                    75497472: 1074282512,
                    92274688: 1073741824,
                    109051904: 524288,
                    125829120: 1074266128,
                    142606336: 524304,
                    159383552: 0,
                    176160768: 16384,
                    192937984: 1074266112,
                    209715200: 1073741840,
                    226492416: 540672,
                    243269632: 1074282496,
                    260046848: 16400,
                    268435456: 0,
                    285212672: 1074266128,
                    301989888: 1073758224,
                    318767104: 1074282496,
                    335544320: 1074266112,
                    352321536: 16,
                    369098752: 540688,
                    385875968: 16384,
                    402653184: 16400,
                    419430400: 524288,
                    436207616: 524304,
                    452984832: 1073741840,
                    469762048: 540672,
                    486539264: 1073758208,
                    503316480: 1073741824,
                    520093696: 1074282512,
                    276824064: 540688,
                    293601280: 524288,
                    310378496: 1074266112,
                    327155712: 16384,
                    343932928: 1073758208,
                    360710144: 1074282512,
                    377487360: 16,
                    394264576: 1073741824,
                    411041792: 1074282496,
                    427819008: 1073741840,
                    444596224: 1073758224,
                    461373440: 524304,
                    478150656: 0,
                    494927872: 16400,
                    511705088: 1074266128,
                    528482304: 540672,
                  },
                  {
                    0: 260,
                    1048576: 0,
                    2097152: 67109120,
                    3145728: 65796,
                    4194304: 65540,
                    5242880: 67108868,
                    6291456: 67174660,
                    7340032: 67174400,
                    8388608: 67108864,
                    9437184: 67174656,
                    10485760: 65792,
                    11534336: 67174404,
                    12582912: 67109124,
                    13631488: 65536,
                    14680064: 4,
                    15728640: 256,
                    524288: 67174656,
                    1572864: 67174404,
                    2621440: 0,
                    3670016: 67109120,
                    4718592: 67108868,
                    5767168: 65536,
                    6815744: 65540,
                    7864320: 260,
                    8912896: 4,
                    9961472: 256,
                    11010048: 67174400,
                    12058624: 65796,
                    13107200: 65792,
                    14155776: 67109124,
                    15204352: 67174660,
                    16252928: 67108864,
                    16777216: 67174656,
                    17825792: 65540,
                    18874368: 65536,
                    19922944: 67109120,
                    20971520: 256,
                    22020096: 67174660,
                    23068672: 67108868,
                    24117248: 0,
                    25165824: 67109124,
                    26214400: 67108864,
                    27262976: 4,
                    28311552: 65792,
                    29360128: 67174400,
                    30408704: 260,
                    31457280: 65796,
                    32505856: 67174404,
                    17301504: 67108864,
                    18350080: 260,
                    19398656: 67174656,
                    20447232: 0,
                    21495808: 65540,
                    22544384: 67109120,
                    23592960: 256,
                    24641536: 67174404,
                    25690112: 65536,
                    26738688: 67174660,
                    27787264: 65796,
                    28835840: 67108868,
                    29884416: 67109124,
                    30932992: 67174400,
                    31981568: 4,
                    33030144: 65792,
                  },
                  {
                    0: 2151682048,
                    65536: 2147487808,
                    131072: 4198464,
                    196608: 2151677952,
                    262144: 0,
                    327680: 4198400,
                    393216: 2147483712,
                    458752: 4194368,
                    524288: 2147483648,
                    589824: 4194304,
                    655360: 64,
                    720896: 2147487744,
                    786432: 2151678016,
                    851968: 4160,
                    917504: 4096,
                    983040: 2151682112,
                    32768: 2147487808,
                    98304: 64,
                    163840: 2151678016,
                    229376: 2147487744,
                    294912: 4198400,
                    360448: 2151682112,
                    425984: 0,
                    491520: 2151677952,
                    557056: 4096,
                    622592: 2151682048,
                    688128: 4194304,
                    753664: 4160,
                    819200: 2147483648,
                    884736: 4194368,
                    950272: 4198464,
                    1015808: 2147483712,
                    1048576: 4194368,
                    1114112: 4198400,
                    1179648: 2147483712,
                    1245184: 0,
                    1310720: 4160,
                    1376256: 2151678016,
                    1441792: 2151682048,
                    1507328: 2147487808,
                    1572864: 2151682112,
                    1638400: 2147483648,
                    1703936: 2151677952,
                    1769472: 4198464,
                    1835008: 2147487744,
                    1900544: 4194304,
                    1966080: 64,
                    2031616: 4096,
                    1081344: 2151677952,
                    1146880: 2151682112,
                    1212416: 0,
                    1277952: 4198400,
                    1343488: 4194368,
                    1409024: 2147483648,
                    1474560: 2147487808,
                    1540096: 64,
                    1605632: 2147483712,
                    1671168: 4096,
                    1736704: 2147487744,
                    1802240: 2151678016,
                    1867776: 4160,
                    1933312: 2151682048,
                    1998848: 4194304,
                    2064384: 4198464,
                  },
                  {
                    0: 128,
                    4096: 17039360,
                    8192: 262144,
                    12288: 536870912,
                    16384: 537133184,
                    20480: 16777344,
                    24576: 553648256,
                    28672: 262272,
                    32768: 16777216,
                    36864: 537133056,
                    40960: 536871040,
                    45056: 553910400,
                    49152: 553910272,
                    53248: 0,
                    57344: 17039488,
                    61440: 553648128,
                    2048: 17039488,
                    6144: 553648256,
                    10240: 128,
                    14336: 17039360,
                    18432: 262144,
                    22528: 537133184,
                    26624: 553910272,
                    30720: 536870912,
                    34816: 537133056,
                    38912: 0,
                    43008: 553910400,
                    47104: 16777344,
                    51200: 536871040,
                    55296: 553648128,
                    59392: 16777216,
                    63488: 262272,
                    65536: 262144,
                    69632: 128,
                    73728: 536870912,
                    77824: 553648256,
                    81920: 16777344,
                    86016: 553910272,
                    90112: 537133184,
                    94208: 16777216,
                    98304: 553910400,
                    102400: 553648128,
                    106496: 17039360,
                    110592: 537133056,
                    114688: 262272,
                    118784: 536871040,
                    122880: 0,
                    126976: 17039488,
                    67584: 553648256,
                    71680: 16777216,
                    75776: 17039360,
                    79872: 537133184,
                    83968: 536870912,
                    88064: 17039488,
                    92160: 128,
                    96256: 553910272,
                    100352: 262272,
                    104448: 553910400,
                    108544: 0,
                    112640: 553648128,
                    116736: 16777344,
                    120832: 262144,
                    124928: 537133056,
                    129024: 536871040,
                  },
                  {
                    0: 268435464,
                    256: 8192,
                    512: 270532608,
                    768: 270540808,
                    1024: 268443648,
                    1280: 2097152,
                    1536: 2097160,
                    1792: 268435456,
                    2048: 0,
                    2304: 268443656,
                    2560: 2105344,
                    2816: 8,
                    3072: 270532616,
                    3328: 2105352,
                    3584: 8200,
                    3840: 270540800,
                    128: 270532608,
                    384: 270540808,
                    640: 8,
                    896: 2097152,
                    1152: 2105352,
                    1408: 268435464,
                    1664: 268443648,
                    1920: 8200,
                    2176: 2097160,
                    2432: 8192,
                    2688: 268443656,
                    2944: 270532616,
                    3200: 0,
                    3456: 270540800,
                    3712: 2105344,
                    3968: 268435456,
                    4096: 268443648,
                    4352: 270532616,
                    4608: 270540808,
                    4864: 8200,
                    5120: 2097152,
                    5376: 268435456,
                    5632: 268435464,
                    5888: 2105344,
                    6144: 2105352,
                    6400: 0,
                    6656: 8,
                    6912: 270532608,
                    7168: 8192,
                    7424: 268443656,
                    7680: 270540800,
                    7936: 2097160,
                    4224: 8,
                    4480: 2105344,
                    4736: 2097152,
                    4992: 268435464,
                    5248: 268443648,
                    5504: 8200,
                    5760: 270540808,
                    6016: 270532608,
                    6272: 270540800,
                    6528: 270532616,
                    6784: 8192,
                    7040: 2105352,
                    7296: 2097160,
                    7552: 0,
                    7808: 268435456,
                    8064: 268443656,
                  },
                  {
                    0: 1048576,
                    16: 33555457,
                    32: 1024,
                    48: 1049601,
                    64: 34604033,
                    80: 0,
                    96: 1,
                    112: 34603009,
                    128: 33555456,
                    144: 1048577,
                    160: 33554433,
                    176: 34604032,
                    192: 34603008,
                    208: 1025,
                    224: 1049600,
                    240: 33554432,
                    8: 34603009,
                    24: 0,
                    40: 33555457,
                    56: 34604032,
                    72: 1048576,
                    88: 33554433,
                    104: 33554432,
                    120: 1025,
                    136: 1049601,
                    152: 33555456,
                    168: 34603008,
                    184: 1048577,
                    200: 1024,
                    216: 34604033,
                    232: 1,
                    248: 1049600,
                    256: 33554432,
                    272: 1048576,
                    288: 33555457,
                    304: 34603009,
                    320: 1048577,
                    336: 33555456,
                    352: 34604032,
                    368: 1049601,
                    384: 1025,
                    400: 34604033,
                    416: 1049600,
                    432: 1,
                    448: 0,
                    464: 34603008,
                    480: 33554433,
                    496: 1024,
                    264: 1049600,
                    280: 33555457,
                    296: 34603009,
                    312: 1,
                    328: 33554432,
                    344: 1048576,
                    360: 1025,
                    376: 34604032,
                    392: 33554433,
                    408: 34603008,
                    424: 0,
                    440: 34604033,
                    456: 1049601,
                    472: 1024,
                    488: 33555456,
                    504: 1048577,
                  },
                  {
                    0: 134219808,
                    1: 131072,
                    2: 134217728,
                    3: 32,
                    4: 131104,
                    5: 134350880,
                    6: 134350848,
                    7: 2048,
                    8: 134348800,
                    9: 134219776,
                    10: 133120,
                    11: 134348832,
                    12: 2080,
                    13: 0,
                    14: 134217760,
                    15: 133152,
                    2147483648: 2048,
                    2147483649: 134350880,
                    2147483650: 134219808,
                    2147483651: 134217728,
                    2147483652: 134348800,
                    2147483653: 133120,
                    2147483654: 133152,
                    2147483655: 32,
                    2147483656: 134217760,
                    2147483657: 2080,
                    2147483658: 131104,
                    2147483659: 134350848,
                    2147483660: 0,
                    2147483661: 134348832,
                    2147483662: 134219776,
                    2147483663: 131072,
                    16: 133152,
                    17: 134350848,
                    18: 32,
                    19: 2048,
                    20: 134219776,
                    21: 134217760,
                    22: 134348832,
                    23: 131072,
                    24: 0,
                    25: 131104,
                    26: 134348800,
                    27: 134219808,
                    28: 134350880,
                    29: 133120,
                    30: 2080,
                    31: 134217728,
                    2147483664: 131072,
                    2147483665: 2048,
                    2147483666: 134348832,
                    2147483667: 133152,
                    2147483668: 32,
                    2147483669: 134348800,
                    2147483670: 134217728,
                    2147483671: 134219808,
                    2147483672: 134350880,
                    2147483673: 134217760,
                    2147483674: 134219776,
                    2147483675: 0,
                    2147483676: 133120,
                    2147483677: 2080,
                    2147483678: 131104,
                    2147483679: 134350848,
                  },
                ],
                f = [
                  4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504,
                  2147483679,
                ],
                m = (o.DES = a.extend({
                  _doReset: function () {
                    for (
                      var p = this._key, y = p.words, E = [], v = 0;
                      v < 56;
                      v++
                    ) {
                      var C = l[v] - 1;
                      E[v] = (y[C >>> 5] >>> (31 - (C % 32))) & 1;
                    }
                    for (var A = (this._subKeys = []), S = 0; S < 16; S++) {
                      for (var R = (A[S] = []), M = u[S], v = 0; v < 24; v++)
                        (R[(v / 6) | 0] |=
                          E[(c[v] - 1 + M) % 28] << (31 - (v % 6))),
                          (R[4 + ((v / 6) | 0)] |=
                            E[28 + ((c[v + 24] - 1 + M) % 28)] <<
                            (31 - (v % 6)));
                      R[0] = (R[0] << 1) | (R[0] >>> 31);
                      for (var v = 1; v < 7; v++)
                        R[v] = R[v] >>> ((v - 1) * 4 + 3);
                      R[7] = (R[7] << 5) | (R[7] >>> 27);
                    }
                    for (var _ = (this._invSubKeys = []), v = 0; v < 16; v++)
                      _[v] = A[15 - v];
                  },
                  encryptBlock: function (p, y) {
                    this._doCryptBlock(p, y, this._subKeys);
                  },
                  decryptBlock: function (p, y) {
                    this._doCryptBlock(p, y, this._invSubKeys);
                  },
                  _doCryptBlock: function (p, y, E) {
                    (this._lBlock = p[y]),
                      (this._rBlock = p[y + 1]),
                      x.call(this, 4, 252645135),
                      x.call(this, 16, 65535),
                      g.call(this, 2, 858993459),
                      g.call(this, 8, 16711935),
                      x.call(this, 1, 1431655765);
                    for (var v = 0; v < 16; v++) {
                      for (
                        var C = E[v],
                          A = this._lBlock,
                          S = this._rBlock,
                          R = 0,
                          M = 0;
                        M < 8;
                        M++
                      )
                        R |= h[M][((S ^ C[M]) & f[M]) >>> 0];
                      (this._lBlock = S), (this._rBlock = A ^ R);
                    }
                    var _ = this._lBlock;
                    (this._lBlock = this._rBlock),
                      (this._rBlock = _),
                      x.call(this, 1, 1431655765),
                      g.call(this, 8, 16711935),
                      g.call(this, 2, 858993459),
                      x.call(this, 16, 65535),
                      x.call(this, 4, 252645135),
                      (p[y] = this._lBlock),
                      (p[y + 1] = this._rBlock);
                  },
                  keySize: 64 / 32,
                  ivSize: 64 / 32,
                  blockSize: 64 / 32,
                }));
              function x(p, y) {
                var E = ((this._lBlock >>> p) ^ this._rBlock) & y;
                (this._rBlock ^= E), (this._lBlock ^= E << p);
              }
              function g(p, y) {
                var E = ((this._rBlock >>> p) ^ this._lBlock) & y;
                (this._lBlock ^= E), (this._rBlock ^= E << p);
              }
              n.DES = a._createHelper(m);
              var d = (o.TripleDES = a.extend({
                _doReset: function () {
                  var p = this._key,
                    y = p.words;
                  if (y.length !== 2 && y.length !== 4 && y.length < 6)
                    throw new Error(
                      "Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.",
                    );
                  var E = y.slice(0, 2),
                    v = y.length < 4 ? y.slice(0, 2) : y.slice(2, 4),
                    C = y.length < 6 ? y.slice(0, 2) : y.slice(4, 6);
                  (this._des1 = m.createEncryptor(s.create(E))),
                    (this._des2 = m.createEncryptor(s.create(v))),
                    (this._des3 = m.createEncryptor(s.create(C)));
                },
                encryptBlock: function (p, y) {
                  this._des1.encryptBlock(p, y),
                    this._des2.decryptBlock(p, y),
                    this._des3.encryptBlock(p, y);
                },
                decryptBlock: function (p, y) {
                  this._des3.decryptBlock(p, y),
                    this._des2.encryptBlock(p, y),
                    this._des1.decryptBlock(p, y);
                },
                keySize: 192 / 32,
                ivSize: 64 / 32,
                blockSize: 64 / 32,
              }));
              n.TripleDES = a._createHelper(d);
            })(),
            t.TripleDES
          );
        });
      })(sa)),
    sa.exports
  );
}
var aa = { exports: {} },
  Ep = aa.exports,
  lu;
function yp() {
  return (
    lu ||
      ((lu = 1),
      (function (i, e) {
        (function (t, n, r) {
          i.exports = n(ct(), Di(), Pi(), oi(), kt());
        })(Ep, function (t) {
          return (
            (function () {
              var n = t,
                r = n.lib,
                s = r.StreamCipher,
                a = n.algo,
                o = (a.RC4 = s.extend({
                  _doReset: function () {
                    for (
                      var u = this._key,
                        h = u.words,
                        f = u.sigBytes,
                        m = (this._S = []),
                        x = 0;
                      x < 256;
                      x++
                    )
                      m[x] = x;
                    for (var x = 0, g = 0; x < 256; x++) {
                      var d = x % f,
                        p = (h[d >>> 2] >>> (24 - (d % 4) * 8)) & 255;
                      g = (g + m[x] + p) % 256;
                      var y = m[x];
                      (m[x] = m[g]), (m[g] = y);
                    }
                    this._i = this._j = 0;
                  },
                  _doProcessBlock: function (u, h) {
                    u[h] ^= l.call(this);
                  },
                  keySize: 256 / 32,
                  ivSize: 0,
                }));
              function l() {
                for (
                  var u = this._S, h = this._i, f = this._j, m = 0, x = 0;
                  x < 4;
                  x++
                ) {
                  (h = (h + 1) % 256), (f = (f + u[h]) % 256);
                  var g = u[h];
                  (u[h] = u[f]),
                    (u[f] = g),
                    (m |= u[(u[h] + u[f]) % 256] << (24 - x * 8));
                }
                return (this._i = h), (this._j = f), m;
              }
              n.RC4 = s._createHelper(o);
              var c = (a.RC4Drop = o.extend({
                cfg: o.cfg.extend({ drop: 192 }),
                _doReset: function () {
                  o._doReset.call(this);
                  for (var u = this.cfg.drop; u > 0; u--) l.call(this);
                },
              }));
              n.RC4Drop = s._createHelper(c);
            })(),
            t.RC4
          );
        });
      })(aa)),
    aa.exports
  );
}
var oa = { exports: {} },
  Sp = oa.exports,
  uu;
function Mp() {
  return (
    uu ||
      ((uu = 1),
      (function (i, e) {
        (function (t, n, r) {
          i.exports = n(ct(), Di(), Pi(), oi(), kt());
        })(Sp, function (t) {
          return (
            (function () {
              var n = t,
                r = n.lib,
                s = r.StreamCipher,
                a = n.algo,
                o = [],
                l = [],
                c = [],
                u = (a.Rabbit = s.extend({
                  _doReset: function () {
                    for (
                      var f = this._key.words, m = this.cfg.iv, x = 0;
                      x < 4;
                      x++
                    )
                      f[x] =
                        (((f[x] << 8) | (f[x] >>> 24)) & 16711935) |
                        (((f[x] << 24) | (f[x] >>> 8)) & 4278255360);
                    var g = (this._X = [
                        f[0],
                        (f[3] << 16) | (f[2] >>> 16),
                        f[1],
                        (f[0] << 16) | (f[3] >>> 16),
                        f[2],
                        (f[1] << 16) | (f[0] >>> 16),
                        f[3],
                        (f[2] << 16) | (f[1] >>> 16),
                      ]),
                      d = (this._C = [
                        (f[2] << 16) | (f[2] >>> 16),
                        (f[0] & 4294901760) | (f[1] & 65535),
                        (f[3] << 16) | (f[3] >>> 16),
                        (f[1] & 4294901760) | (f[2] & 65535),
                        (f[0] << 16) | (f[0] >>> 16),
                        (f[2] & 4294901760) | (f[3] & 65535),
                        (f[1] << 16) | (f[1] >>> 16),
                        (f[3] & 4294901760) | (f[0] & 65535),
                      ]);
                    this._b = 0;
                    for (var x = 0; x < 4; x++) h.call(this);
                    for (var x = 0; x < 8; x++) d[x] ^= g[(x + 4) & 7];
                    if (m) {
                      var p = m.words,
                        y = p[0],
                        E = p[1],
                        v =
                          (((y << 8) | (y >>> 24)) & 16711935) |
                          (((y << 24) | (y >>> 8)) & 4278255360),
                        C =
                          (((E << 8) | (E >>> 24)) & 16711935) |
                          (((E << 24) | (E >>> 8)) & 4278255360),
                        A = (v >>> 16) | (C & 4294901760),
                        S = (C << 16) | (v & 65535);
                      (d[0] ^= v),
                        (d[1] ^= A),
                        (d[2] ^= C),
                        (d[3] ^= S),
                        (d[4] ^= v),
                        (d[5] ^= A),
                        (d[6] ^= C),
                        (d[7] ^= S);
                      for (var x = 0; x < 4; x++) h.call(this);
                    }
                  },
                  _doProcessBlock: function (f, m) {
                    var x = this._X;
                    h.call(this),
                      (o[0] = x[0] ^ (x[5] >>> 16) ^ (x[3] << 16)),
                      (o[1] = x[2] ^ (x[7] >>> 16) ^ (x[5] << 16)),
                      (o[2] = x[4] ^ (x[1] >>> 16) ^ (x[7] << 16)),
                      (o[3] = x[6] ^ (x[3] >>> 16) ^ (x[1] << 16));
                    for (var g = 0; g < 4; g++)
                      (o[g] =
                        (((o[g] << 8) | (o[g] >>> 24)) & 16711935) |
                        (((o[g] << 24) | (o[g] >>> 8)) & 4278255360)),
                        (f[m + g] ^= o[g]);
                  },
                  blockSize: 128 / 32,
                  ivSize: 64 / 32,
                }));
              function h() {
                for (var f = this._X, m = this._C, x = 0; x < 8; x++)
                  l[x] = m[x];
                (m[0] = (m[0] + 1295307597 + this._b) | 0),
                  (m[1] =
                    (m[1] + 3545052371 + (m[0] >>> 0 < l[0] >>> 0 ? 1 : 0)) |
                    0),
                  (m[2] =
                    (m[2] + 886263092 + (m[1] >>> 0 < l[1] >>> 0 ? 1 : 0)) | 0),
                  (m[3] =
                    (m[3] + 1295307597 + (m[2] >>> 0 < l[2] >>> 0 ? 1 : 0)) |
                    0),
                  (m[4] =
                    (m[4] + 3545052371 + (m[3] >>> 0 < l[3] >>> 0 ? 1 : 0)) |
                    0),
                  (m[5] =
                    (m[5] + 886263092 + (m[4] >>> 0 < l[4] >>> 0 ? 1 : 0)) | 0),
                  (m[6] =
                    (m[6] + 1295307597 + (m[5] >>> 0 < l[5] >>> 0 ? 1 : 0)) |
                    0),
                  (m[7] =
                    (m[7] + 3545052371 + (m[6] >>> 0 < l[6] >>> 0 ? 1 : 0)) |
                    0),
                  (this._b = m[7] >>> 0 < l[7] >>> 0 ? 1 : 0);
                for (var x = 0; x < 8; x++) {
                  var g = f[x] + m[x],
                    d = g & 65535,
                    p = g >>> 16,
                    y = ((((d * d) >>> 17) + d * p) >>> 15) + p * p,
                    E = (((g & 4294901760) * g) | 0) + (((g & 65535) * g) | 0);
                  c[x] = y ^ E;
                }
                (f[0] =
                  (c[0] +
                    ((c[7] << 16) | (c[7] >>> 16)) +
                    ((c[6] << 16) | (c[6] >>> 16))) |
                  0),
                  (f[1] = (c[1] + ((c[0] << 8) | (c[0] >>> 24)) + c[7]) | 0),
                  (f[2] =
                    (c[2] +
                      ((c[1] << 16) | (c[1] >>> 16)) +
                      ((c[0] << 16) | (c[0] >>> 16))) |
                    0),
                  (f[3] = (c[3] + ((c[2] << 8) | (c[2] >>> 24)) + c[1]) | 0),
                  (f[4] =
                    (c[4] +
                      ((c[3] << 16) | (c[3] >>> 16)) +
                      ((c[2] << 16) | (c[2] >>> 16))) |
                    0),
                  (f[5] = (c[5] + ((c[4] << 8) | (c[4] >>> 24)) + c[3]) | 0),
                  (f[6] =
                    (c[6] +
                      ((c[5] << 16) | (c[5] >>> 16)) +
                      ((c[4] << 16) | (c[4] >>> 16))) |
                    0),
                  (f[7] = (c[7] + ((c[6] << 8) | (c[6] >>> 24)) + c[5]) | 0);
              }
              n.Rabbit = s._createHelper(u);
            })(),
            t.Rabbit
          );
        });
      })(oa)),
    oa.exports
  );
}
var ca = { exports: {} },
  Ap = ca.exports,
  fu;
function bp() {
  return (
    fu ||
      ((fu = 1),
      (function (i, e) {
        (function (t, n, r) {
          i.exports = n(ct(), Di(), Pi(), oi(), kt());
        })(Ap, function (t) {
          return (
            (function () {
              var n = t,
                r = n.lib,
                s = r.StreamCipher,
                a = n.algo,
                o = [],
                l = [],
                c = [],
                u = (a.RabbitLegacy = s.extend({
                  _doReset: function () {
                    var f = this._key.words,
                      m = this.cfg.iv,
                      x = (this._X = [
                        f[0],
                        (f[3] << 16) | (f[2] >>> 16),
                        f[1],
                        (f[0] << 16) | (f[3] >>> 16),
                        f[2],
                        (f[1] << 16) | (f[0] >>> 16),
                        f[3],
                        (f[2] << 16) | (f[1] >>> 16),
                      ]),
                      g = (this._C = [
                        (f[2] << 16) | (f[2] >>> 16),
                        (f[0] & 4294901760) | (f[1] & 65535),
                        (f[3] << 16) | (f[3] >>> 16),
                        (f[1] & 4294901760) | (f[2] & 65535),
                        (f[0] << 16) | (f[0] >>> 16),
                        (f[2] & 4294901760) | (f[3] & 65535),
                        (f[1] << 16) | (f[1] >>> 16),
                        (f[3] & 4294901760) | (f[0] & 65535),
                      ]);
                    this._b = 0;
                    for (var d = 0; d < 4; d++) h.call(this);
                    for (var d = 0; d < 8; d++) g[d] ^= x[(d + 4) & 7];
                    if (m) {
                      var p = m.words,
                        y = p[0],
                        E = p[1],
                        v =
                          (((y << 8) | (y >>> 24)) & 16711935) |
                          (((y << 24) | (y >>> 8)) & 4278255360),
                        C =
                          (((E << 8) | (E >>> 24)) & 16711935) |
                          (((E << 24) | (E >>> 8)) & 4278255360),
                        A = (v >>> 16) | (C & 4294901760),
                        S = (C << 16) | (v & 65535);
                      (g[0] ^= v),
                        (g[1] ^= A),
                        (g[2] ^= C),
                        (g[3] ^= S),
                        (g[4] ^= v),
                        (g[5] ^= A),
                        (g[6] ^= C),
                        (g[7] ^= S);
                      for (var d = 0; d < 4; d++) h.call(this);
                    }
                  },
                  _doProcessBlock: function (f, m) {
                    var x = this._X;
                    h.call(this),
                      (o[0] = x[0] ^ (x[5] >>> 16) ^ (x[3] << 16)),
                      (o[1] = x[2] ^ (x[7] >>> 16) ^ (x[5] << 16)),
                      (o[2] = x[4] ^ (x[1] >>> 16) ^ (x[7] << 16)),
                      (o[3] = x[6] ^ (x[3] >>> 16) ^ (x[1] << 16));
                    for (var g = 0; g < 4; g++)
                      (o[g] =
                        (((o[g] << 8) | (o[g] >>> 24)) & 16711935) |
                        (((o[g] << 24) | (o[g] >>> 8)) & 4278255360)),
                        (f[m + g] ^= o[g]);
                  },
                  blockSize: 128 / 32,
                  ivSize: 64 / 32,
                }));
              function h() {
                for (var f = this._X, m = this._C, x = 0; x < 8; x++)
                  l[x] = m[x];
                (m[0] = (m[0] + 1295307597 + this._b) | 0),
                  (m[1] =
                    (m[1] + 3545052371 + (m[0] >>> 0 < l[0] >>> 0 ? 1 : 0)) |
                    0),
                  (m[2] =
                    (m[2] + 886263092 + (m[1] >>> 0 < l[1] >>> 0 ? 1 : 0)) | 0),
                  (m[3] =
                    (m[3] + 1295307597 + (m[2] >>> 0 < l[2] >>> 0 ? 1 : 0)) |
                    0),
                  (m[4] =
                    (m[4] + 3545052371 + (m[3] >>> 0 < l[3] >>> 0 ? 1 : 0)) |
                    0),
                  (m[5] =
                    (m[5] + 886263092 + (m[4] >>> 0 < l[4] >>> 0 ? 1 : 0)) | 0),
                  (m[6] =
                    (m[6] + 1295307597 + (m[5] >>> 0 < l[5] >>> 0 ? 1 : 0)) |
                    0),
                  (m[7] =
                    (m[7] + 3545052371 + (m[6] >>> 0 < l[6] >>> 0 ? 1 : 0)) |
                    0),
                  (this._b = m[7] >>> 0 < l[7] >>> 0 ? 1 : 0);
                for (var x = 0; x < 8; x++) {
                  var g = f[x] + m[x],
                    d = g & 65535,
                    p = g >>> 16,
                    y = ((((d * d) >>> 17) + d * p) >>> 15) + p * p,
                    E = (((g & 4294901760) * g) | 0) + (((g & 65535) * g) | 0);
                  c[x] = y ^ E;
                }
                (f[0] =
                  (c[0] +
                    ((c[7] << 16) | (c[7] >>> 16)) +
                    ((c[6] << 16) | (c[6] >>> 16))) |
                  0),
                  (f[1] = (c[1] + ((c[0] << 8) | (c[0] >>> 24)) + c[7]) | 0),
                  (f[2] =
                    (c[2] +
                      ((c[1] << 16) | (c[1] >>> 16)) +
                      ((c[0] << 16) | (c[0] >>> 16))) |
                    0),
                  (f[3] = (c[3] + ((c[2] << 8) | (c[2] >>> 24)) + c[1]) | 0),
                  (f[4] =
                    (c[4] +
                      ((c[3] << 16) | (c[3] >>> 16)) +
                      ((c[2] << 16) | (c[2] >>> 16))) |
                    0),
                  (f[5] = (c[5] + ((c[4] << 8) | (c[4] >>> 24)) + c[3]) | 0),
                  (f[6] =
                    (c[6] +
                      ((c[5] << 16) | (c[5] >>> 16)) +
                      ((c[4] << 16) | (c[4] >>> 16))) |
                    0),
                  (f[7] = (c[7] + ((c[6] << 8) | (c[6] >>> 24)) + c[5]) | 0);
              }
              n.RabbitLegacy = s._createHelper(u);
            })(),
            t.RabbitLegacy
          );
        });
      })(ca)),
    ca.exports
  );
}
var la = { exports: {} },
  Tp = la.exports,
  hu;
function Cp() {
  return (
    hu ||
      ((hu = 1),
      (function (i, e) {
        (function (t, n, r) {
          i.exports = n(ct(), Di(), Pi(), oi(), kt());
        })(Tp, function (t) {
          return (
            (function () {
              var n = t,
                r = n.lib,
                s = r.BlockCipher,
                a = n.algo;
              const o = 16,
                l = [
                  608135816, 2242054355, 320440878, 57701188, 2752067618,
                  698298832, 137296536, 3964562569, 1160258022, 953160567,
                  3193202383, 887688300, 3232508343, 3380367581, 1065670069,
                  3041331479, 2450970073, 2306472731,
                ],
                c = [
                  [
                    3509652390, 2564797868, 805139163, 3491422135, 3101798381,
                    1780907670, 3128725573, 4046225305, 614570311, 3012652279,
                    134345442, 2240740374, 1667834072, 1901547113, 2757295779,
                    4103290238, 227898511, 1921955416, 1904987480, 2182433518,
                    2069144605, 3260701109, 2620446009, 720527379, 3318853667,
                    677414384, 3393288472, 3101374703, 2390351024, 1614419982,
                    1822297739, 2954791486, 3608508353, 3174124327, 2024746970,
                    1432378464, 3864339955, 2857741204, 1464375394, 1676153920,
                    1439316330, 715854006, 3033291828, 289532110, 2706671279,
                    2087905683, 3018724369, 1668267050, 732546397, 1947742710,
                    3462151702, 2609353502, 2950085171, 1814351708, 2050118529,
                    680887927, 999245976, 1800124847, 3300911131, 1713906067,
                    1641548236, 4213287313, 1216130144, 1575780402, 4018429277,
                    3917837745, 3693486850, 3949271944, 596196993, 3549867205,
                    258830323, 2213823033, 772490370, 2760122372, 1774776394,
                    2652871518, 566650946, 4142492826, 1728879713, 2882767088,
                    1783734482, 3629395816, 2517608232, 2874225571, 1861159788,
                    326777828, 3124490320, 2130389656, 2716951837, 967770486,
                    1724537150, 2185432712, 2364442137, 1164943284, 2105845187,
                    998989502, 3765401048, 2244026483, 1075463327, 1455516326,
                    1322494562, 910128902, 469688178, 1117454909, 936433444,
                    3490320968, 3675253459, 1240580251, 122909385, 2157517691,
                    634681816, 4142456567, 3825094682, 3061402683, 2540495037,
                    79693498, 3249098678, 1084186820, 1583128258, 426386531,
                    1761308591, 1047286709, 322548459, 995290223, 1845252383,
                    2603652396, 3431023940, 2942221577, 3202600964, 3727903485,
                    1712269319, 422464435, 3234572375, 1170764815, 3523960633,
                    3117677531, 1434042557, 442511882, 3600875718, 1076654713,
                    1738483198, 4213154764, 2393238008, 3677496056, 1014306527,
                    4251020053, 793779912, 2902807211, 842905082, 4246964064,
                    1395751752, 1040244610, 2656851899, 3396308128, 445077038,
                    3742853595, 3577915638, 679411651, 2892444358, 2354009459,
                    1767581616, 3150600392, 3791627101, 3102740896, 284835224,
                    4246832056, 1258075500, 768725851, 2589189241, 3069724005,
                    3532540348, 1274779536, 3789419226, 2764799539, 1660621633,
                    3471099624, 4011903706, 913787905, 3497959166, 737222580,
                    2514213453, 2928710040, 3937242737, 1804850592, 3499020752,
                    2949064160, 2386320175, 2390070455, 2415321851, 4061277028,
                    2290661394, 2416832540, 1336762016, 1754252060, 3520065937,
                    3014181293, 791618072, 3188594551, 3933548030, 2332172193,
                    3852520463, 3043980520, 413987798, 3465142937, 3030929376,
                    4245938359, 2093235073, 3534596313, 375366246, 2157278981,
                    2479649556, 555357303, 3870105701, 2008414854, 3344188149,
                    4221384143, 3956125452, 2067696032, 3594591187, 2921233993,
                    2428461, 544322398, 577241275, 1471733935, 610547355,
                    4027169054, 1432588573, 1507829418, 2025931657, 3646575487,
                    545086370, 48609733, 2200306550, 1653985193, 298326376,
                    1316178497, 3007786442, 2064951626, 458293330, 2589141269,
                    3591329599, 3164325604, 727753846, 2179363840, 146436021,
                    1461446943, 4069977195, 705550613, 3059967265, 3887724982,
                    4281599278, 3313849956, 1404054877, 2845806497, 146425753,
                    1854211946,
                  ],
                  [
                    1266315497, 3048417604, 3681880366, 3289982499, 290971e4,
                    1235738493, 2632868024, 2414719590, 3970600049, 1771706367,
                    1449415276, 3266420449, 422970021, 1963543593, 2690192192,
                    3826793022, 1062508698, 1531092325, 1804592342, 2583117782,
                    2714934279, 4024971509, 1294809318, 4028980673, 1289560198,
                    2221992742, 1669523910, 35572830, 157838143, 1052438473,
                    1016535060, 1802137761, 1753167236, 1386275462, 3080475397,
                    2857371447, 1040679964, 2145300060, 2390574316, 1461121720,
                    2956646967, 4031777805, 4028374788, 33600511, 2920084762,
                    1018524850, 629373528, 3691585981, 3515945977, 2091462646,
                    2486323059, 586499841, 988145025, 935516892, 3367335476,
                    2599673255, 2839830854, 265290510, 3972581182, 2759138881,
                    3795373465, 1005194799, 847297441, 406762289, 1314163512,
                    1332590856, 1866599683, 4127851711, 750260880, 613907577,
                    1450815602, 3165620655, 3734664991, 3650291728, 3012275730,
                    3704569646, 1427272223, 778793252, 1343938022, 2676280711,
                    2052605720, 1946737175, 3164576444, 3914038668, 3967478842,
                    3682934266, 1661551462, 3294938066, 4011595847, 840292616,
                    3712170807, 616741398, 312560963, 711312465, 1351876610,
                    322626781, 1910503582, 271666773, 2175563734, 1594956187,
                    70604529, 3617834859, 1007753275, 1495573769, 4069517037,
                    2549218298, 2663038764, 504708206, 2263041392, 3941167025,
                    2249088522, 1514023603, 1998579484, 1312622330, 694541497,
                    2582060303, 2151582166, 1382467621, 776784248, 2618340202,
                    3323268794, 2497899128, 2784771155, 503983604, 4076293799,
                    907881277, 423175695, 432175456, 1378068232, 4145222326,
                    3954048622, 3938656102, 3820766613, 2793130115, 2977904593,
                    26017576, 3274890735, 3194772133, 1700274565, 1756076034,
                    4006520079, 3677328699, 720338349, 1533947780, 354530856,
                    688349552, 3973924725, 1637815568, 332179504, 3949051286,
                    53804574, 2852348879, 3044236432, 1282449977, 3583942155,
                    3416972820, 4006381244, 1617046695, 2628476075, 3002303598,
                    1686838959, 431878346, 2686675385, 1700445008, 1080580658,
                    1009431731, 832498133, 3223435511, 2605976345, 2271191193,
                    2516031870, 1648197032, 4164389018, 2548247927, 300782431,
                    375919233, 238389289, 3353747414, 2531188641, 2019080857,
                    1475708069, 455242339, 2609103871, 448939670, 3451063019,
                    1395535956, 2413381860, 1841049896, 1491858159, 885456874,
                    4264095073, 4001119347, 1565136089, 3898914787, 1108368660,
                    540939232, 1173283510, 2745871338, 3681308437, 4207628240,
                    3343053890, 4016749493, 1699691293, 1103962373, 3625875870,
                    2256883143, 3830138730, 1031889488, 3479347698, 1535977030,
                    4236805024, 3251091107, 2132092099, 1774941330, 1199868427,
                    1452454533, 157007616, 2904115357, 342012276, 595725824,
                    1480756522, 206960106, 497939518, 591360097, 863170706,
                    2375253569, 3596610801, 1814182875, 2094937945, 3421402208,
                    1082520231, 3463918190, 2785509508, 435703966, 3908032597,
                    1641649973, 2842273706, 3305899714, 1510255612, 2148256476,
                    2655287854, 3276092548, 4258621189, 236887753, 3681803219,
                    274041037, 1734335097, 3815195456, 3317970021, 1899903192,
                    1026095262, 4050517792, 356393447, 2410691914, 3873677099,
                    3682840055,
                  ],
                  [
                    3913112168, 2491498743, 4132185628, 2489919796, 1091903735,
                    1979897079, 3170134830, 3567386728, 3557303409, 857797738,
                    1136121015, 1342202287, 507115054, 2535736646, 337727348,
                    3213592640, 1301675037, 2528481711, 1895095763, 1721773893,
                    3216771564, 62756741, 2142006736, 835421444, 2531993523,
                    1442658625, 3659876326, 2882144922, 676362277, 1392781812,
                    170690266, 3921047035, 1759253602, 3611846912, 1745797284,
                    664899054, 1329594018, 3901205900, 3045908486, 2062866102,
                    2865634940, 3543621612, 3464012697, 1080764994, 553557557,
                    3656615353, 3996768171, 991055499, 499776247, 1265440854,
                    648242737, 3940784050, 980351604, 3713745714, 1749149687,
                    3396870395, 4211799374, 3640570775, 1161844396, 3125318951,
                    1431517754, 545492359, 4268468663, 3499529547, 1437099964,
                    2702547544, 3433638243, 2581715763, 2787789398, 1060185593,
                    1593081372, 2418618748, 4260947970, 69676912, 2159744348,
                    86519011, 2512459080, 3838209314, 1220612927, 3339683548,
                    133810670, 1090789135, 1078426020, 1569222167, 845107691,
                    3583754449, 4072456591, 1091646820, 628848692, 1613405280,
                    3757631651, 526609435, 236106946, 48312990, 2942717905,
                    3402727701, 1797494240, 859738849, 992217954, 4005476642,
                    2243076622, 3870952857, 3732016268, 765654824, 3490871365,
                    2511836413, 1685915746, 3888969200, 1414112111, 2273134842,
                    3281911079, 4080962846, 172450625, 2569994100, 980381355,
                    4109958455, 2819808352, 2716589560, 2568741196, 3681446669,
                    3329971472, 1835478071, 660984891, 3704678404, 4045999559,
                    3422617507, 3040415634, 1762651403, 1719377915, 3470491036,
                    2693910283, 3642056355, 3138596744, 1364962596, 2073328063,
                    1983633131, 926494387, 3423689081, 2150032023, 4096667949,
                    1749200295, 3328846651, 309677260, 2016342300, 1779581495,
                    3079819751, 111262694, 1274766160, 443224088, 298511866,
                    1025883608, 3806446537, 1145181785, 168956806, 3641502830,
                    3584813610, 1689216846, 3666258015, 3200248200, 1692713982,
                    2646376535, 4042768518, 1618508792, 1610833997, 3523052358,
                    4130873264, 2001055236, 3610705100, 2202168115, 4028541809,
                    2961195399, 1006657119, 2006996926, 3186142756, 1430667929,
                    3210227297, 1314452623, 4074634658, 4101304120, 2273951170,
                    1399257539, 3367210612, 3027628629, 1190975929, 2062231137,
                    2333990788, 2221543033, 2438960610, 1181637006, 548689776,
                    2362791313, 3372408396, 3104550113, 3145860560, 296247880,
                    1970579870, 3078560182, 3769228297, 1714227617, 3291629107,
                    3898220290, 166772364, 1251581989, 493813264, 448347421,
                    195405023, 2709975567, 677966185, 3703036547, 1463355134,
                    2715995803, 1338867538, 1343315457, 2802222074, 2684532164,
                    233230375, 2599980071, 2000651841, 3277868038, 1638401717,
                    4028070440, 3237316320, 6314154, 819756386, 300326615,
                    590932579, 1405279636, 3267499572, 3150704214, 2428286686,
                    3959192993, 3461946742, 1862657033, 1266418056, 963775037,
                    2089974820, 2263052895, 1917689273, 448879540, 3550394620,
                    3981727096, 150775221, 3627908307, 1303187396, 508620638,
                    2975983352, 2726630617, 1817252668, 1876281319, 1457606340,
                    908771278, 3720792119, 3617206836, 2455994898, 1729034894,
                    1080033504,
                  ],
                  [
                    976866871, 3556439503, 2881648439, 1522871579, 1555064734,
                    1336096578, 3548522304, 2579274686, 3574697629, 3205460757,
                    3593280638, 3338716283, 3079412587, 564236357, 2993598910,
                    1781952180, 1464380207, 3163844217, 3332601554, 1699332808,
                    1393555694, 1183702653, 3581086237, 1288719814, 691649499,
                    2847557200, 2895455976, 3193889540, 2717570544, 1781354906,
                    1676643554, 2592534050, 3230253752, 1126444790, 2770207658,
                    2633158820, 2210423226, 2615765581, 2414155088, 3127139286,
                    673620729, 2805611233, 1269405062, 4015350505, 3341807571,
                    4149409754, 1057255273, 2012875353, 2162469141, 2276492801,
                    2601117357, 993977747, 3918593370, 2654263191, 753973209,
                    36408145, 2530585658, 25011837, 3520020182, 2088578344,
                    530523599, 2918365339, 1524020338, 1518925132, 3760827505,
                    3759777254, 1202760957, 3985898139, 3906192525, 674977740,
                    4174734889, 2031300136, 2019492241, 3983892565, 4153806404,
                    3822280332, 352677332, 2297720250, 60907813, 90501309,
                    3286998549, 1016092578, 2535922412, 2839152426, 457141659,
                    509813237, 4120667899, 652014361, 1966332200, 2975202805,
                    55981186, 2327461051, 676427537, 3255491064, 2882294119,
                    3433927263, 1307055953, 942726286, 933058658, 2468411793,
                    3933900994, 4215176142, 1361170020, 2001714738, 2830558078,
                    3274259782, 1222529897, 1679025792, 2729314320, 3714953764,
                    1770335741, 151462246, 3013232138, 1682292957, 1483529935,
                    471910574, 1539241949, 458788160, 3436315007, 1807016891,
                    3718408830, 978976581, 1043663428, 3165965781, 1927990952,
                    4200891579, 2372276910, 3208408903, 3533431907, 1412390302,
                    2931980059, 4132332400, 1947078029, 3881505623, 4168226417,
                    2941484381, 1077988104, 1320477388, 886195818, 18198404,
                    3786409e3, 2509781533, 112762804, 3463356488, 1866414978,
                    891333506, 18488651, 661792760, 1628790961, 3885187036,
                    3141171499, 876946877, 2693282273, 1372485963, 791857591,
                    2686433993, 3759982718, 3167212022, 3472953795, 2716379847,
                    445679433, 3561995674, 3504004811, 3574258232, 54117162,
                    3331405415, 2381918588, 3769707343, 4154350007, 1140177722,
                    4074052095, 668550556, 3214352940, 367459370, 261225585,
                    2610173221, 4209349473, 3468074219, 3265815641, 314222801,
                    3066103646, 3808782860, 282218597, 3406013506, 3773591054,
                    379116347, 1285071038, 846784868, 2669647154, 3771962079,
                    3550491691, 2305946142, 453669953, 1268987020, 3317592352,
                    3279303384, 3744833421, 2610507566, 3859509063, 266596637,
                    3847019092, 517658769, 3462560207, 3443424879, 370717030,
                    4247526661, 2224018117, 4143653529, 4112773975, 2788324899,
                    2477274417, 1456262402, 2901442914, 1517677493, 1846949527,
                    2295493580, 3734397586, 2176403920, 1280348187, 1908823572,
                    3871786941, 846861322, 1172426758, 3287448474, 3383383037,
                    1655181056, 3139813346, 901632758, 1897031941, 2986607138,
                    3066810236, 3447102507, 1393639104, 373351379, 950779232,
                    625454576, 3124240540, 4148612726, 2007998917, 544563296,
                    2244738638, 2330496472, 2058025392, 1291430526, 424198748,
                    50039436, 29584100, 3605783033, 2429876329, 2791104160,
                    1057563949, 3255363231, 3075367218, 3463963227, 1469046755,
                    985887462,
                  ],
                ];
              var u = { pbox: [], sbox: [] };
              function h(d, p) {
                let y = (p >> 24) & 255,
                  E = (p >> 16) & 255,
                  v = (p >> 8) & 255,
                  C = p & 255,
                  A = d.sbox[0][y] + d.sbox[1][E];
                return (A = A ^ d.sbox[2][v]), (A = A + d.sbox[3][C]), A;
              }
              function f(d, p, y) {
                let E = p,
                  v = y,
                  C;
                for (let A = 0; A < o; ++A)
                  (E = E ^ d.pbox[A]),
                    (v = h(d, E) ^ v),
                    (C = E),
                    (E = v),
                    (v = C);
                return (
                  (C = E),
                  (E = v),
                  (v = C),
                  (v = v ^ d.pbox[o]),
                  (E = E ^ d.pbox[o + 1]),
                  { left: E, right: v }
                );
              }
              function m(d, p, y) {
                let E = p,
                  v = y,
                  C;
                for (let A = o + 1; A > 1; --A)
                  (E = E ^ d.pbox[A]),
                    (v = h(d, E) ^ v),
                    (C = E),
                    (E = v),
                    (v = C);
                return (
                  (C = E),
                  (E = v),
                  (v = C),
                  (v = v ^ d.pbox[1]),
                  (E = E ^ d.pbox[0]),
                  { left: E, right: v }
                );
              }
              function x(d, p, y) {
                for (let S = 0; S < 4; S++) {
                  d.sbox[S] = [];
                  for (let R = 0; R < 256; R++) d.sbox[S][R] = c[S][R];
                }
                let E = 0;
                for (let S = 0; S < o + 2; S++)
                  (d.pbox[S] = l[S] ^ p[E]), E++, E >= y && (E = 0);
                let v = 0,
                  C = 0,
                  A = 0;
                for (let S = 0; S < o + 2; S += 2)
                  (A = f(d, v, C)),
                    (v = A.left),
                    (C = A.right),
                    (d.pbox[S] = v),
                    (d.pbox[S + 1] = C);
                for (let S = 0; S < 4; S++)
                  for (let R = 0; R < 256; R += 2)
                    (A = f(d, v, C)),
                      (v = A.left),
                      (C = A.right),
                      (d.sbox[S][R] = v),
                      (d.sbox[S][R + 1] = C);
                return !0;
              }
              var g = (a.Blowfish = s.extend({
                _doReset: function () {
                  if (this._keyPriorReset !== this._key) {
                    var d = (this._keyPriorReset = this._key),
                      p = d.words,
                      y = d.sigBytes / 4;
                    x(u, p, y);
                  }
                },
                encryptBlock: function (d, p) {
                  var y = f(u, d[p], d[p + 1]);
                  (d[p] = y.left), (d[p + 1] = y.right);
                },
                decryptBlock: function (d, p) {
                  var y = m(u, d[p], d[p + 1]);
                  (d[p] = y.left), (d[p + 1] = y.right);
                },
                blockSize: 64 / 32,
                keySize: 128 / 32,
                ivSize: 64 / 32,
              }));
              n.Blowfish = s._createHelper(g);
            })(),
            t.Blowfish
          );
        });
      })(la)),
    la.exports
  );
}
var wp = ws.exports,
  du;
function Rp() {
  return (
    du ||
      ((du = 1),
      (function (i, e) {
        (function (t, n, r) {
          i.exports = n(
            ct(),
            Da(),
            b0(),
            C0(),
            Di(),
            D0(),
            Pi(),
            Yf(),
            Vc(),
            U0(),
            $f(),
            O0(),
            k0(),
            V0(),
            Gc(),
            X0(),
            oi(),
            kt(),
            j0(),
            Z0(),
            Q0(),
            tp(),
            ip(),
            sp(),
            op(),
            lp(),
            fp(),
            dp(),
            mp(),
            gp(),
            vp(),
            yp(),
            Mp(),
            bp(),
            Cp(),
          );
        })(wp, function (t) {
          return t;
        });
      })(ws)),
    ws.exports
  );
}
var Dp = Rp();
const dS = Ed(Dp);
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const Wc = "173",
  Pp = 0,
  pu = 1,
  Fp = 2,
  jf = 1,
  Bp = 2,
  On = 3,
  si = 0,
  Qt = 1,
  zn = 2,
  ti = 0,
  ir = 1,
  mu = 2,
  xu = 3,
  gu = 4,
  Lp = 5,
  vi = 100,
  Up = 101,
  Ip = 102,
  Np = 103,
  Op = 104,
  zp = 200,
  kp = 201,
  Hp = 202,
  Vp = 203,
  ko = 204,
  Ho = 205,
  Gp = 206,
  Wp = 207,
  Xp = 208,
  qp = 209,
  Yp = 210,
  $p = 211,
  jp = 212,
  Kp = 213,
  Zp = 214,
  Vo = 0,
  Go = 1,
  Wo = 2,
  cr = 3,
  Xo = 4,
  qo = 5,
  Yo = 6,
  $o = 7,
  Xc = 0,
  Jp = 1,
  Qp = 2,
  ni = 0,
  em = 1,
  tm = 2,
  nm = 3,
  im = 4,
  rm = 5,
  sm = 6,
  am = 7,
  Kf = 300,
  lr = 301,
  ur = 302,
  jo = 303,
  Ko = 304,
  Pa = 306,
  Zo = 1e3,
  Si = 1001,
  Jo = 1002,
  Mn = 1003,
  om = 1004,
  Zr = 1005,
  Dn = 1006,
  ja = 1007,
  Mi = 1008,
  Wn = 1009,
  Zf = 1010,
  Jf = 1011,
  zr = 1012,
  qc = 1013,
  Ti = 1014,
  kn = 1015,
  Vr = 1016,
  Yc = 1017,
  $c = 1018,
  fr = 1020,
  Qf = 35902,
  eh = 1021,
  th = 1022,
  Sn = 1023,
  nh = 1024,
  ih = 1025,
  rr = 1026,
  hr = 1027,
  rh = 1028,
  jc = 1029,
  sh = 1030,
  Kc = 1031,
  Zc = 1033,
  ua = 33776,
  fa = 33777,
  ha = 33778,
  da = 33779,
  Qo = 35840,
  ec = 35841,
  tc = 35842,
  nc = 35843,
  ic = 36196,
  rc = 37492,
  sc = 37496,
  ac = 37808,
  oc = 37809,
  cc = 37810,
  lc = 37811,
  uc = 37812,
  fc = 37813,
  hc = 37814,
  dc = 37815,
  pc = 37816,
  mc = 37817,
  xc = 37818,
  gc = 37819,
  _c = 37820,
  vc = 37821,
  pa = 36492,
  Ec = 36494,
  yc = 36495,
  ah = 36283,
  Sc = 36284,
  Mc = 36285,
  Ac = 36286,
  cm = 3200,
  lm = 3201,
  oh = 0,
  um = 1,
  Qn = "",
  hn = "srgb",
  dr = "srgb-linear",
  ba = "linear",
  vt = "srgb",
  Ii = 7680,
  _u = 519,
  fm = 512,
  hm = 513,
  dm = 514,
  ch = 515,
  pm = 516,
  mm = 517,
  xm = 518,
  gm = 519,
  bc = 35044,
  vu = "300 es",
  Hn = 2e3,
  Ta = 2001;
class xr {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  hasEventListener(e, t) {
    const n = this._listeners;
    return n === void 0 ? !1 : n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    const n = this._listeners;
    if (n === void 0) return;
    const r = n[e];
    if (r !== void 0) {
      const s = r.indexOf(t);
      s !== -1 && r.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    const t = this._listeners;
    if (t === void 0) return;
    const n = t[e.type];
    if (n !== void 0) {
      e.target = this;
      const r = n.slice(0);
      for (let s = 0, a = r.length; s < a; s++) r[s].call(this, e);
      e.target = null;
    }
  }
}
const Gt = [
    "00",
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "0a",
    "0b",
    "0c",
    "0d",
    "0e",
    "0f",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "1a",
    "1b",
    "1c",
    "1d",
    "1e",
    "1f",
    "20",
    "21",
    "22",
    "23",
    "24",
    "25",
    "26",
    "27",
    "28",
    "29",
    "2a",
    "2b",
    "2c",
    "2d",
    "2e",
    "2f",
    "30",
    "31",
    "32",
    "33",
    "34",
    "35",
    "36",
    "37",
    "38",
    "39",
    "3a",
    "3b",
    "3c",
    "3d",
    "3e",
    "3f",
    "40",
    "41",
    "42",
    "43",
    "44",
    "45",
    "46",
    "47",
    "48",
    "49",
    "4a",
    "4b",
    "4c",
    "4d",
    "4e",
    "4f",
    "50",
    "51",
    "52",
    "53",
    "54",
    "55",
    "56",
    "57",
    "58",
    "59",
    "5a",
    "5b",
    "5c",
    "5d",
    "5e",
    "5f",
    "60",
    "61",
    "62",
    "63",
    "64",
    "65",
    "66",
    "67",
    "68",
    "69",
    "6a",
    "6b",
    "6c",
    "6d",
    "6e",
    "6f",
    "70",
    "71",
    "72",
    "73",
    "74",
    "75",
    "76",
    "77",
    "78",
    "79",
    "7a",
    "7b",
    "7c",
    "7d",
    "7e",
    "7f",
    "80",
    "81",
    "82",
    "83",
    "84",
    "85",
    "86",
    "87",
    "88",
    "89",
    "8a",
    "8b",
    "8c",
    "8d",
    "8e",
    "8f",
    "90",
    "91",
    "92",
    "93",
    "94",
    "95",
    "96",
    "97",
    "98",
    "99",
    "9a",
    "9b",
    "9c",
    "9d",
    "9e",
    "9f",
    "a0",
    "a1",
    "a2",
    "a3",
    "a4",
    "a5",
    "a6",
    "a7",
    "a8",
    "a9",
    "aa",
    "ab",
    "ac",
    "ad",
    "ae",
    "af",
    "b0",
    "b1",
    "b2",
    "b3",
    "b4",
    "b5",
    "b6",
    "b7",
    "b8",
    "b9",
    "ba",
    "bb",
    "bc",
    "bd",
    "be",
    "bf",
    "c0",
    "c1",
    "c2",
    "c3",
    "c4",
    "c5",
    "c6",
    "c7",
    "c8",
    "c9",
    "ca",
    "cb",
    "cc",
    "cd",
    "ce",
    "cf",
    "d0",
    "d1",
    "d2",
    "d3",
    "d4",
    "d5",
    "d6",
    "d7",
    "d8",
    "d9",
    "da",
    "db",
    "dc",
    "dd",
    "de",
    "df",
    "e0",
    "e1",
    "e2",
    "e3",
    "e4",
    "e5",
    "e6",
    "e7",
    "e8",
    "e9",
    "ea",
    "eb",
    "ec",
    "ed",
    "ee",
    "ef",
    "f0",
    "f1",
    "f2",
    "f3",
    "f4",
    "f5",
    "f6",
    "f7",
    "f8",
    "f9",
    "fa",
    "fb",
    "fc",
    "fd",
    "fe",
    "ff",
  ],
  Ka = Math.PI / 180,
  Tc = 180 / Math.PI;
function ii() {
  const i = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    n = (Math.random() * 4294967295) | 0;
  return (
    Gt[i & 255] +
    Gt[(i >> 8) & 255] +
    Gt[(i >> 16) & 255] +
    Gt[(i >> 24) & 255] +
    "-" +
    Gt[e & 255] +
    Gt[(e >> 8) & 255] +
    "-" +
    Gt[((e >> 16) & 15) | 64] +
    Gt[(e >> 24) & 255] +
    "-" +
    Gt[(t & 63) | 128] +
    Gt[(t >> 8) & 255] +
    "-" +
    Gt[(t >> 16) & 255] +
    Gt[(t >> 24) & 255] +
    Gt[n & 255] +
    Gt[(n >> 8) & 255] +
    Gt[(n >> 16) & 255] +
    Gt[(n >> 24) & 255]
  ).toLowerCase();
}
function ot(i, e, t) {
  return Math.max(e, Math.min(t, i));
}
function _m(i, e) {
  return ((i % e) + e) % e;
}
function Za(i, e, t) {
  return (1 - t) * i + t * e;
}
function Rn(i, e) {
  switch (e.constructor) {
    case Float32Array:
      return i;
    case Uint32Array:
      return i / 4294967295;
    case Uint16Array:
      return i / 65535;
    case Uint8Array:
      return i / 255;
    case Int32Array:
      return Math.max(i / 2147483647, -1);
    case Int16Array:
      return Math.max(i / 32767, -1);
    case Int8Array:
      return Math.max(i / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Et(i, e) {
  switch (e.constructor) {
    case Float32Array:
      return i;
    case Uint32Array:
      return Math.round(i * 4294967295);
    case Uint16Array:
      return Math.round(i * 65535);
    case Uint8Array:
      return Math.round(i * 255);
    case Int32Array:
      return Math.round(i * 2147483647);
    case Int16Array:
      return Math.round(i * 32767);
    case Int8Array:
      return Math.round(i * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
class it {
  constructor(e = 0, t = 0) {
    (it.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      n = this.y,
      r = e.elements;
    return (
      (this.x = r[0] * t + r[3] * n + r[6]),
      (this.y = r[1] * t + r[4] * n + r[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = ot(this.x, e.x, t.x)), (this.y = ot(this.y, e.y, t.y)), this
    );
  }
  clampScalar(e, t) {
    return (this.x = ot(this.x, e, t)), (this.y = ot(this.y, e, t)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(ot(n, e, t));
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(ot(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n), (this.y = e.y + (t.y - e.y) * n), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const n = Math.cos(t),
      r = Math.sin(t),
      s = this.x - e.x,
      a = this.y - e.y;
    return (this.x = s * n - a * r + e.x), (this.y = s * r + a * n + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Ze {
  constructor(e, t, n, r, s, a, o, l, c) {
    (Ze.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, n, r, s, a, o, l, c);
  }
  set(e, t, n, r, s, a, o, l, c) {
    const u = this.elements;
    return (
      (u[0] = e),
      (u[1] = r),
      (u[2] = o),
      (u[3] = t),
      (u[4] = s),
      (u[5] = l),
      (u[6] = n),
      (u[7] = a),
      (u[8] = c),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      n = e.elements;
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      this
    );
  }
  extractBasis(e, t, n) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      n.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements,
      r = t.elements,
      s = this.elements,
      a = n[0],
      o = n[3],
      l = n[6],
      c = n[1],
      u = n[4],
      h = n[7],
      f = n[2],
      m = n[5],
      x = n[8],
      g = r[0],
      d = r[3],
      p = r[6],
      y = r[1],
      E = r[4],
      v = r[7],
      C = r[2],
      A = r[5],
      S = r[8];
    return (
      (s[0] = a * g + o * y + l * C),
      (s[3] = a * d + o * E + l * A),
      (s[6] = a * p + o * v + l * S),
      (s[1] = c * g + u * y + h * C),
      (s[4] = c * d + u * E + h * A),
      (s[7] = c * p + u * v + h * S),
      (s[2] = f * g + m * y + x * C),
      (s[5] = f * d + m * E + x * A),
      (s[8] = f * p + m * v + x * S),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      r = e[2],
      s = e[3],
      a = e[4],
      o = e[5],
      l = e[6],
      c = e[7],
      u = e[8];
    return (
      t * a * u - t * o * c - n * s * u + n * o * l + r * s * c - r * a * l
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      r = e[2],
      s = e[3],
      a = e[4],
      o = e[5],
      l = e[6],
      c = e[7],
      u = e[8],
      h = u * a - o * c,
      f = o * l - u * s,
      m = c * s - a * l,
      x = t * h + n * f + r * m;
    if (x === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const g = 1 / x;
    return (
      (e[0] = h * g),
      (e[1] = (r * c - u * n) * g),
      (e[2] = (o * n - r * a) * g),
      (e[3] = f * g),
      (e[4] = (u * t - r * l) * g),
      (e[5] = (r * s - o * t) * g),
      (e[6] = m * g),
      (e[7] = (n * l - c * t) * g),
      (e[8] = (a * t - n * s) * g),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, n, r, s, a, o) {
    const l = Math.cos(s),
      c = Math.sin(s);
    return (
      this.set(
        n * l,
        n * c,
        -n * (l * a + c * o) + a + e,
        -r * c,
        r * l,
        -r * (-c * a + l * o) + o + t,
        0,
        0,
        1,
      ),
      this
    );
  }
  scale(e, t) {
    return this.premultiply(Ja.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(Ja.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(Ja.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements,
      n = e.elements;
    for (let r = 0; r < 9; r++) if (t[r] !== n[r]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return (
      (e[t] = n[0]),
      (e[t + 1] = n[1]),
      (e[t + 2] = n[2]),
      (e[t + 3] = n[3]),
      (e[t + 4] = n[4]),
      (e[t + 5] = n[5]),
      (e[t + 6] = n[6]),
      (e[t + 7] = n[7]),
      (e[t + 8] = n[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Ja = new Ze();
function lh(i) {
  for (let e = i.length - 1; e >= 0; --e) if (i[e] >= 65535) return !0;
  return !1;
}
function kr(i) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", i);
}
function vm() {
  const i = kr("canvas");
  return (i.style.display = "block"), i;
}
const Eu = {};
function tr(i) {
  i in Eu || ((Eu[i] = !0), console.warn(i));
}
function Em(i, e, t) {
  return new Promise(function (n, r) {
    function s() {
      switch (i.clientWaitSync(e, i.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case i.WAIT_FAILED:
          r();
          break;
        case i.TIMEOUT_EXPIRED:
          setTimeout(s, t);
          break;
        default:
          n();
      }
    }
    setTimeout(s, t);
  });
}
function ym(i) {
  const e = i.elements;
  (e[2] = 0.5 * e[2] + 0.5 * e[3]),
    (e[6] = 0.5 * e[6] + 0.5 * e[7]),
    (e[10] = 0.5 * e[10] + 0.5 * e[11]),
    (e[14] = 0.5 * e[14] + 0.5 * e[15]);
}
function Sm(i) {
  const e = i.elements;
  e[11] === -1
    ? ((e[10] = -e[10] - 1), (e[14] = -e[14]))
    : ((e[10] = -e[10]), (e[14] = -e[14] + 1));
}
const yu = new Ze().set(
    0.4123908,
    0.3575843,
    0.1804808,
    0.212639,
    0.7151687,
    0.0721923,
    0.0193308,
    0.1191948,
    0.9505322,
  ),
  Su = new Ze().set(
    3.2409699,
    -1.5373832,
    -0.4986108,
    -0.9692436,
    1.8759675,
    0.0415551,
    0.0556301,
    -0.203977,
    1.0569715,
  );
function Mm() {
  const i = {
      enabled: !0,
      workingColorSpace: dr,
      spaces: {},
      convert: function (r, s, a) {
        return (
          this.enabled === !1 ||
            s === a ||
            !s ||
            !a ||
            (this.spaces[s].transfer === vt &&
              ((r.r = Gn(r.r)), (r.g = Gn(r.g)), (r.b = Gn(r.b))),
            this.spaces[s].primaries !== this.spaces[a].primaries &&
              (r.applyMatrix3(this.spaces[s].toXYZ),
              r.applyMatrix3(this.spaces[a].fromXYZ)),
            this.spaces[a].transfer === vt &&
              ((r.r = sr(r.r)), (r.g = sr(r.g)), (r.b = sr(r.b)))),
          r
        );
      },
      fromWorkingColorSpace: function (r, s) {
        return this.convert(r, this.workingColorSpace, s);
      },
      toWorkingColorSpace: function (r, s) {
        return this.convert(r, s, this.workingColorSpace);
      },
      getPrimaries: function (r) {
        return this.spaces[r].primaries;
      },
      getTransfer: function (r) {
        return r === Qn ? ba : this.spaces[r].transfer;
      },
      getLuminanceCoefficients: function (r, s = this.workingColorSpace) {
        return r.fromArray(this.spaces[s].luminanceCoefficients);
      },
      define: function (r) {
        Object.assign(this.spaces, r);
      },
      _getMatrix: function (r, s, a) {
        return r.copy(this.spaces[s].toXYZ).multiply(this.spaces[a].fromXYZ);
      },
      _getDrawingBufferColorSpace: function (r) {
        return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace;
      },
      _getUnpackColorSpace: function (r = this.workingColorSpace) {
        return this.spaces[r].workingColorSpaceConfig.unpackColorSpace;
      },
    },
    e = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06],
    t = [0.2126, 0.7152, 0.0722],
    n = [0.3127, 0.329];
  return (
    i.define({
      [dr]: {
        primaries: e,
        whitePoint: n,
        transfer: ba,
        toXYZ: yu,
        fromXYZ: Su,
        luminanceCoefficients: t,
        workingColorSpaceConfig: { unpackColorSpace: hn },
        outputColorSpaceConfig: { drawingBufferColorSpace: hn },
      },
      [hn]: {
        primaries: e,
        whitePoint: n,
        transfer: vt,
        toXYZ: yu,
        fromXYZ: Su,
        luminanceCoefficients: t,
        outputColorSpaceConfig: { drawingBufferColorSpace: hn },
      },
    }),
    i
  );
}
const pt = Mm();
function Gn(i) {
  return i < 0.04045
    ? i * 0.0773993808
    : Math.pow(i * 0.9478672986 + 0.0521327014, 2.4);
}
function sr(i) {
  return i < 0.0031308 ? i * 12.92 : 1.055 * Math.pow(i, 0.41666) - 0.055;
}
let Ni;
class Am {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement == "undefined")
      return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      Ni === void 0 && (Ni = kr("canvas")),
        (Ni.width = e.width),
        (Ni.height = e.height);
      const n = Ni.getContext("2d");
      e instanceof ImageData
        ? n.putImageData(e, 0, 0)
        : n.drawImage(e, 0, 0, e.width, e.height),
        (t = Ni);
    }
    return t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement != "undefined" &&
        e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement != "undefined" &&
        e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap != "undefined" && e instanceof ImageBitmap)
    ) {
      const t = kr("canvas");
      (t.width = e.width), (t.height = e.height);
      const n = t.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const r = n.getImageData(0, 0, e.width, e.height),
        s = r.data;
      for (let a = 0; a < s.length; a++) s[a] = Gn(s[a] / 255) * 255;
      return n.putImageData(r, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let n = 0; n < t.length; n++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[n] = Math.floor(Gn(t[n] / 255) * 255))
          : (t[n] = Gn(t[n]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.",
        ),
        e
      );
  }
}
let bm = 0;
class uh {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: bm++ }),
      (this.uuid = ii()),
      (this.data = e),
      (this.dataReady = !0),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const n = { uuid: this.uuid, url: "" },
      r = this.data;
    if (r !== null) {
      let s;
      if (Array.isArray(r)) {
        s = [];
        for (let a = 0, o = r.length; a < o; a++)
          r[a].isDataTexture ? s.push(Qa(r[a].image)) : s.push(Qa(r[a]));
      } else s = Qa(r);
      n.url = s;
    }
    return t || (e.images[this.uuid] = n), n;
  }
}
function Qa(i) {
  return (typeof HTMLImageElement != "undefined" &&
    i instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement != "undefined" &&
      i instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap != "undefined" && i instanceof ImageBitmap)
    ? Am.getDataURL(i)
    : i.data
      ? {
          data: Array.from(i.data),
          width: i.width,
          height: i.height,
          type: i.data.constructor.name,
        }
      : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let Tm = 0;
class qt extends xr {
  constructor(
    e = qt.DEFAULT_IMAGE,
    t = qt.DEFAULT_MAPPING,
    n = Si,
    r = Si,
    s = Dn,
    a = Mi,
    o = Sn,
    l = Wn,
    c = qt.DEFAULT_ANISOTROPY,
    u = Qn,
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: Tm++ }),
      (this.uuid = ii()),
      (this.name = ""),
      (this.source = new uh(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = n),
      (this.wrapT = r),
      (this.magFilter = s),
      (this.minFilter = a),
      (this.anisotropy = c),
      (this.format = o),
      (this.internalFormat = null),
      (this.type = l),
      (this.offset = new it(0, 0)),
      (this.repeat = new it(1, 1)),
      (this.center = new it(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new Ze()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.colorSpace = u),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.renderTarget = null),
      (this.isRenderTargetTexture = !1),
      (this.pmremVersion = 0);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y,
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.renderTarget = e.renderTarget),
      (this.isRenderTargetTexture = e.isRenderTargetTexture),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const n = {
      metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (n.userData = this.userData),
      t || (e.textures[this.uuid] = n),
      n
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== Kf) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case Zo:
          e.x = e.x - Math.floor(e.x);
          break;
        case Si:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Jo:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Zo:
          e.y = e.y - Math.floor(e.y);
          break;
        case Si:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Jo:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
qt.DEFAULT_IMAGE = null;
qt.DEFAULT_MAPPING = Kf;
qt.DEFAULT_ANISOTROPY = 1;
class yt {
  constructor(e = 0, t = 0, n = 0, r = 1) {
    (yt.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = n),
      (this.w = r);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, n, r) {
    return (this.x = e), (this.y = t), (this.z = n), (this.w = r), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      n = this.y,
      r = this.z,
      s = this.w,
      a = e.elements;
    return (
      (this.x = a[0] * t + a[4] * n + a[8] * r + a[12] * s),
      (this.y = a[1] * t + a[5] * n + a[9] * r + a[13] * s),
      (this.z = a[2] * t + a[6] * n + a[10] * r + a[14] * s),
      (this.w = a[3] * t + a[7] * n + a[11] * r + a[15] * s),
      this
    );
  }
  divide(e) {
    return (
      (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), (this.w /= e.w), this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, n, r, s;
    const l = e.elements,
      c = l[0],
      u = l[4],
      h = l[8],
      f = l[1],
      m = l[5],
      x = l[9],
      g = l[2],
      d = l[6],
      p = l[10];
    if (
      Math.abs(u - f) < 0.01 &&
      Math.abs(h - g) < 0.01 &&
      Math.abs(x - d) < 0.01
    ) {
      if (
        Math.abs(u + f) < 0.1 &&
        Math.abs(h + g) < 0.1 &&
        Math.abs(x + d) < 0.1 &&
        Math.abs(c + m + p - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const E = (c + 1) / 2,
        v = (m + 1) / 2,
        C = (p + 1) / 2,
        A = (u + f) / 4,
        S = (h + g) / 4,
        R = (x + d) / 4;
      return (
        E > v && E > C
          ? E < 0.01
            ? ((n = 0), (r = 0.707106781), (s = 0.707106781))
            : ((n = Math.sqrt(E)), (r = A / n), (s = S / n))
          : v > C
            ? v < 0.01
              ? ((n = 0.707106781), (r = 0), (s = 0.707106781))
              : ((r = Math.sqrt(v)), (n = A / r), (s = R / r))
            : C < 0.01
              ? ((n = 0.707106781), (r = 0.707106781), (s = 0))
              : ((s = Math.sqrt(C)), (n = S / s), (r = R / s)),
        this.set(n, r, s, t),
        this
      );
    }
    let y = Math.sqrt(
      (d - x) * (d - x) + (h - g) * (h - g) + (f - u) * (f - u),
    );
    return (
      Math.abs(y) < 0.001 && (y = 1),
      (this.x = (d - x) / y),
      (this.y = (h - g) / y),
      (this.z = (f - u) / y),
      (this.w = Math.acos((c + m + p - 1) / 2)),
      this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (
      (this.x = t[12]),
      (this.y = t[13]),
      (this.z = t[14]),
      (this.w = t[15]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = ot(this.x, e.x, t.x)),
      (this.y = ot(this.y, e.y, t.y)),
      (this.z = ot(this.z, e.z, t.z)),
      (this.w = ot(this.w, e.w, t.w)),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = ot(this.x, e, t)),
      (this.y = ot(this.y, e, t)),
      (this.z = ot(this.z, e, t)),
      (this.w = ot(this.w, e, t)),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(ot(n, e, t));
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w,
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n),
      (this.y = e.y + (t.y - e.y) * n),
      (this.z = e.z + (t.z - e.z) * n),
      (this.w = e.w + (t.w - e.w) * n),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class Cm extends xr {
  constructor(e = 1, t = 1, n = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new yt(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new yt(0, 0, e, t));
    const r = { width: e, height: t, depth: 1 };
    n = Object.assign(
      {
        generateMipmaps: !1,
        internalFormat: null,
        minFilter: Dn,
        depthBuffer: !0,
        stencilBuffer: !1,
        resolveDepthBuffer: !0,
        resolveStencilBuffer: !0,
        depthTexture: null,
        samples: 0,
        count: 1,
      },
      n,
    );
    const s = new qt(
      r,
      n.mapping,
      n.wrapS,
      n.wrapT,
      n.magFilter,
      n.minFilter,
      n.format,
      n.type,
      n.anisotropy,
      n.colorSpace,
    );
    (s.flipY = !1),
      (s.generateMipmaps = n.generateMipmaps),
      (s.internalFormat = n.internalFormat),
      (this.textures = []);
    const a = n.count;
    for (let o = 0; o < a; o++)
      (this.textures[o] = s.clone()),
        (this.textures[o].isRenderTargetTexture = !0),
        (this.textures[o].renderTarget = this);
    (this.depthBuffer = n.depthBuffer),
      (this.stencilBuffer = n.stencilBuffer),
      (this.resolveDepthBuffer = n.resolveDepthBuffer),
      (this.resolveStencilBuffer = n.resolveStencilBuffer),
      (this._depthTexture = null),
      (this.depthTexture = n.depthTexture),
      (this.samples = n.samples);
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  set depthTexture(e) {
    this._depthTexture !== null && (this._depthTexture.renderTarget = null),
      e !== null && (e.renderTarget = this),
      (this._depthTexture = e);
  }
  get depthTexture() {
    return this._depthTexture;
  }
  setSize(e, t, n = 1) {
    if (this.width !== e || this.height !== t || this.depth !== n) {
      (this.width = e), (this.height = t), (this.depth = n);
      for (let r = 0, s = this.textures.length; r < s; r++)
        (this.textures[r].image.width = e),
          (this.textures[r].image.height = t),
          (this.textures[r].image.depth = n);
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.textures.length = 0);
    for (let n = 0, r = e.textures.length; n < r; n++)
      (this.textures[n] = e.textures[n].clone()),
        (this.textures[n].isRenderTargetTexture = !0),
        (this.textures[n].renderTarget = this);
    const t = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new uh(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      (this.resolveDepthBuffer = e.resolveDepthBuffer),
      (this.resolveStencilBuffer = e.resolveStencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Ci extends Cm {
  constructor(e = 1, t = 1, n = {}) {
    super(e, t, n), (this.isWebGLRenderTarget = !0);
  }
}
class fh extends qt {
  constructor(e = null, t = 1, n = 1, r = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: n, depth: r }),
      (this.magFilter = Mn),
      (this.minFilter = Mn),
      (this.wrapR = Si),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class wm extends qt {
  constructor(e = null, t = 1, n = 1, r = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: n, depth: r }),
      (this.magFilter = Mn),
      (this.minFilter = Mn),
      (this.wrapR = Si),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class Gr {
  constructor(e = 0, t = 0, n = 0, r = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._w = r);
  }
  static slerpFlat(e, t, n, r, s, a, o) {
    let l = n[r + 0],
      c = n[r + 1],
      u = n[r + 2],
      h = n[r + 3];
    const f = s[a + 0],
      m = s[a + 1],
      x = s[a + 2],
      g = s[a + 3];
    if (o === 0) {
      (e[t + 0] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = h);
      return;
    }
    if (o === 1) {
      (e[t + 0] = f), (e[t + 1] = m), (e[t + 2] = x), (e[t + 3] = g);
      return;
    }
    if (h !== g || l !== f || c !== m || u !== x) {
      let d = 1 - o;
      const p = l * f + c * m + u * x + h * g,
        y = p >= 0 ? 1 : -1,
        E = 1 - p * p;
      if (E > Number.EPSILON) {
        const C = Math.sqrt(E),
          A = Math.atan2(C, p * y);
        (d = Math.sin(d * A) / C), (o = Math.sin(o * A) / C);
      }
      const v = o * y;
      if (
        ((l = l * d + f * v),
        (c = c * d + m * v),
        (u = u * d + x * v),
        (h = h * d + g * v),
        d === 1 - o)
      ) {
        const C = 1 / Math.sqrt(l * l + c * c + u * u + h * h);
        (l *= C), (c *= C), (u *= C), (h *= C);
      }
    }
    (e[t] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = h);
  }
  static multiplyQuaternionsFlat(e, t, n, r, s, a) {
    const o = n[r],
      l = n[r + 1],
      c = n[r + 2],
      u = n[r + 3],
      h = s[a],
      f = s[a + 1],
      m = s[a + 2],
      x = s[a + 3];
    return (
      (e[t] = o * x + u * h + l * m - c * f),
      (e[t + 1] = l * x + u * f + c * h - o * m),
      (e[t + 2] = c * x + u * m + o * f - l * h),
      (e[t + 3] = u * x - o * h - l * f - c * m),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, n, r) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._w = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t = !0) {
    const n = e._x,
      r = e._y,
      s = e._z,
      a = e._order,
      o = Math.cos,
      l = Math.sin,
      c = o(n / 2),
      u = o(r / 2),
      h = o(s / 2),
      f = l(n / 2),
      m = l(r / 2),
      x = l(s / 2);
    switch (a) {
      case "XYZ":
        (this._x = f * u * h + c * m * x),
          (this._y = c * m * h - f * u * x),
          (this._z = c * u * x + f * m * h),
          (this._w = c * u * h - f * m * x);
        break;
      case "YXZ":
        (this._x = f * u * h + c * m * x),
          (this._y = c * m * h - f * u * x),
          (this._z = c * u * x - f * m * h),
          (this._w = c * u * h + f * m * x);
        break;
      case "ZXY":
        (this._x = f * u * h - c * m * x),
          (this._y = c * m * h + f * u * x),
          (this._z = c * u * x + f * m * h),
          (this._w = c * u * h - f * m * x);
        break;
      case "ZYX":
        (this._x = f * u * h - c * m * x),
          (this._y = c * m * h + f * u * x),
          (this._z = c * u * x - f * m * h),
          (this._w = c * u * h + f * m * x);
        break;
      case "YZX":
        (this._x = f * u * h + c * m * x),
          (this._y = c * m * h + f * u * x),
          (this._z = c * u * x - f * m * h),
          (this._w = c * u * h - f * m * x);
        break;
      case "XZY":
        (this._x = f * u * h - c * m * x),
          (this._y = c * m * h - f * u * x),
          (this._z = c * u * x + f * m * h),
          (this._w = c * u * h + f * m * x);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
            a,
        );
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const n = t / 2,
      r = Math.sin(n);
    return (
      (this._x = e.x * r),
      (this._y = e.y * r),
      (this._z = e.z * r),
      (this._w = Math.cos(n)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      n = t[0],
      r = t[4],
      s = t[8],
      a = t[1],
      o = t[5],
      l = t[9],
      c = t[2],
      u = t[6],
      h = t[10],
      f = n + o + h;
    if (f > 0) {
      const m = 0.5 / Math.sqrt(f + 1);
      (this._w = 0.25 / m),
        (this._x = (u - l) * m),
        (this._y = (s - c) * m),
        (this._z = (a - r) * m);
    } else if (n > o && n > h) {
      const m = 2 * Math.sqrt(1 + n - o - h);
      (this._w = (u - l) / m),
        (this._x = 0.25 * m),
        (this._y = (r + a) / m),
        (this._z = (s + c) / m);
    } else if (o > h) {
      const m = 2 * Math.sqrt(1 + o - n - h);
      (this._w = (s - c) / m),
        (this._x = (r + a) / m),
        (this._y = 0.25 * m),
        (this._z = (l + u) / m);
    } else {
      const m = 2 * Math.sqrt(1 + h - n - o);
      (this._w = (a - r) / m),
        (this._x = (s + c) / m),
        (this._y = (l + u) / m),
        (this._z = 0.25 * m);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return (
      n < Number.EPSILON
        ? ((n = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = n))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = n)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = n)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(ot(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (n === 0) return this;
    const r = Math.min(1, t / n);
    return this.slerp(e, r), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w,
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const n = e._x,
      r = e._y,
      s = e._z,
      a = e._w,
      o = t._x,
      l = t._y,
      c = t._z,
      u = t._w;
    return (
      (this._x = n * u + a * o + r * c - s * l),
      (this._y = r * u + a * l + s * o - n * c),
      (this._z = s * u + a * c + n * l - r * o),
      (this._w = a * u - n * o - r * l - s * c),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const n = this._x,
      r = this._y,
      s = this._z,
      a = this._w;
    let o = a * e._w + n * e._x + r * e._y + s * e._z;
    if (
      (o < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (o = -o))
        : this.copy(e),
      o >= 1)
    )
      return (this._w = a), (this._x = n), (this._y = r), (this._z = s), this;
    const l = 1 - o * o;
    if (l <= Number.EPSILON) {
      const m = 1 - t;
      return (
        (this._w = m * a + t * this._w),
        (this._x = m * n + t * this._x),
        (this._y = m * r + t * this._y),
        (this._z = m * s + t * this._z),
        this.normalize(),
        this
      );
    }
    const c = Math.sqrt(l),
      u = Math.atan2(c, o),
      h = Math.sin((1 - t) * u) / c,
      f = Math.sin(t * u) / c;
    return (
      (this._w = a * h + this._w * f),
      (this._x = n * h + this._x * f),
      (this._y = r * h + this._y * f),
      (this._z = s * h + this._z * f),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, n) {
    return this.copy(e).slerp(t, n);
  }
  random() {
    const e = 2 * Math.PI * Math.random(),
      t = 2 * Math.PI * Math.random(),
      n = Math.random(),
      r = Math.sqrt(1 - n),
      s = Math.sqrt(n);
    return this.set(
      r * Math.sin(e),
      r * Math.cos(e),
      s * Math.sin(t),
      s * Math.cos(t),
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this._onChangeCallback(),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class W {
  constructor(e = 0, t = 0, n = 0) {
    (W.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = n);
  }
  set(e, t, n) {
    return (
      n === void 0 && (n = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = n),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(Mu.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(Mu.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      n = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[3] * n + s[6] * r),
      (this.y = s[1] * t + s[4] * n + s[7] * r),
      (this.z = s[2] * t + s[5] * n + s[8] * r),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      n = this.y,
      r = this.z,
      s = e.elements,
      a = 1 / (s[3] * t + s[7] * n + s[11] * r + s[15]);
    return (
      (this.x = (s[0] * t + s[4] * n + s[8] * r + s[12]) * a),
      (this.y = (s[1] * t + s[5] * n + s[9] * r + s[13]) * a),
      (this.z = (s[2] * t + s[6] * n + s[10] * r + s[14]) * a),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      n = this.y,
      r = this.z,
      s = e.x,
      a = e.y,
      o = e.z,
      l = e.w,
      c = 2 * (a * r - o * n),
      u = 2 * (o * t - s * r),
      h = 2 * (s * n - a * t);
    return (
      (this.x = t + l * c + a * h - o * u),
      (this.y = n + l * u + o * c - s * h),
      (this.z = r + l * h + s * u - a * c),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix,
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld,
    );
  }
  transformDirection(e) {
    const t = this.x,
      n = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[4] * n + s[8] * r),
      (this.y = s[1] * t + s[5] * n + s[9] * r),
      (this.z = s[2] * t + s[6] * n + s[10] * r),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = ot(this.x, e.x, t.x)),
      (this.y = ot(this.y, e.y, t.y)),
      (this.z = ot(this.z, e.z, t.z)),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = ot(this.x, e, t)),
      (this.y = ot(this.y, e, t)),
      (this.z = ot(this.z, e, t)),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(ot(n, e, t));
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n),
      (this.y = e.y + (t.y - e.y) * n),
      (this.z = e.z + (t.z - e.z) * n),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const n = e.x,
      r = e.y,
      s = e.z,
      a = t.x,
      o = t.y,
      l = t.z;
    return (
      (this.x = r * l - s * o),
      (this.y = s * a - n * l),
      (this.z = n * o - r * a),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return eo.copy(this).projectOnVector(e), this.sub(eo);
  }
  reflect(e) {
    return this.sub(eo.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(ot(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      n = this.y - e.y,
      r = this.z - e.z;
    return t * t + n * n + r * r;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, n) {
    const r = Math.sin(t) * e;
    return (
      (this.x = r * Math.sin(n)),
      (this.y = Math.cos(t) * e),
      (this.z = r * Math.cos(n)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, n) {
    return (
      (this.x = e * Math.sin(t)), (this.y = n), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      n = this.setFromMatrixColumn(e, 1).length(),
      r = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = n), (this.z = r), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2,
      t = Math.random() * 2 - 1,
      n = Math.sqrt(1 - t * t);
    return (
      (this.x = n * Math.cos(e)), (this.y = t), (this.z = n * Math.sin(e)), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const eo = new W(),
  Mu = new Gr();
class Wr {
  constructor(
    e = new W(1 / 0, 1 / 0, 1 / 0),
    t = new W(-1 / 0, -1 / 0, -1 / 0),
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t += 3)
      this.expandByPoint(gn.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, n = e.count; t < n; t++)
      this.expandByPoint(gn.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = gn.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    if (n !== void 0) {
      const s = n.getAttribute("position");
      if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
        for (let a = 0, o = s.count; a < o; a++)
          e.isMesh === !0
            ? e.getVertexPosition(a, gn)
            : gn.fromBufferAttribute(s, a),
            gn.applyMatrix4(e.matrixWorld),
            this.expandByPoint(gn);
      else
        e.boundingBox !== void 0
          ? (e.boundingBox === null && e.computeBoundingBox(),
            Jr.copy(e.boundingBox))
          : (n.boundingBox === null && n.computeBoundingBox(),
            Jr.copy(n.boundingBox)),
          Jr.applyMatrix4(e.matrixWorld),
          this.union(Jr);
    }
    const r = e.children;
    for (let s = 0, a = r.length; s < a; s++) this.expandByObject(r[s], t);
    return this;
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y &&
      e.z >= this.min.z &&
      e.z <= this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z),
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y &&
      e.max.z >= this.min.z &&
      e.min.z <= this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, gn),
      gn.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, n;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (n += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (n += e.normal.z * this.min.z)),
      t <= -e.constant && n >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(Ar),
      Qr.subVectors(this.max, Ar),
      Oi.subVectors(e.a, Ar),
      zi.subVectors(e.b, Ar),
      ki.subVectors(e.c, Ar),
      qn.subVectors(zi, Oi),
      Yn.subVectors(ki, zi),
      ui.subVectors(Oi, ki);
    let t = [
      0,
      -qn.z,
      qn.y,
      0,
      -Yn.z,
      Yn.y,
      0,
      -ui.z,
      ui.y,
      qn.z,
      0,
      -qn.x,
      Yn.z,
      0,
      -Yn.x,
      ui.z,
      0,
      -ui.x,
      -qn.y,
      qn.x,
      0,
      -Yn.y,
      Yn.x,
      0,
      -ui.y,
      ui.x,
      0,
    ];
    return !to(t, Oi, zi, ki, Qr) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !to(t, Oi, zi, ki, Qr))
      ? !1
      : (es.crossVectors(qn, Yn),
        (t = [es.x, es.y, es.z]),
        to(t, Oi, zi, ki, Qr));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, gn).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(gn).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (Bn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Bn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Bn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Bn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Bn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Bn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Bn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Bn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Bn),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Bn = [
    new W(),
    new W(),
    new W(),
    new W(),
    new W(),
    new W(),
    new W(),
    new W(),
  ],
  gn = new W(),
  Jr = new Wr(),
  Oi = new W(),
  zi = new W(),
  ki = new W(),
  qn = new W(),
  Yn = new W(),
  ui = new W(),
  Ar = new W(),
  Qr = new W(),
  es = new W(),
  fi = new W();
function to(i, e, t, n, r) {
  for (let s = 0, a = i.length - 3; s <= a; s += 3) {
    fi.fromArray(i, s);
    const o =
        r.x * Math.abs(fi.x) + r.y * Math.abs(fi.y) + r.z * Math.abs(fi.z),
      l = e.dot(fi),
      c = t.dot(fi),
      u = n.dot(fi);
    if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > o) return !1;
  }
  return !0;
}
const Rm = new Wr(),
  br = new W(),
  no = new W();
class Fa {
  constructor(e = new W(), t = -1) {
    (this.isSphere = !0), (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const n = this.center;
    t !== void 0 ? n.copy(t) : Rm.setFromPoints(e).getCenter(n);
    let r = 0;
    for (let s = 0, a = e.length; s < a; s++)
      r = Math.max(r, n.distanceToSquared(e[s]));
    return (this.radius = Math.sqrt(r)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const n = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      n > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    br.subVectors(e, this.center);
    const t = br.lengthSq();
    if (t > this.radius * this.radius) {
      const n = Math.sqrt(t),
        r = (n - this.radius) * 0.5;
      this.center.addScaledVector(br, r / n), (this.radius += r);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
        ? (this.copy(e), this)
        : (this.center.equals(e.center) === !0
            ? (this.radius = Math.max(this.radius, e.radius))
            : (no.subVectors(e.center, this.center).setLength(e.radius),
              this.expandByPoint(br.copy(e.center).add(no)),
              this.expandByPoint(br.copy(e.center).sub(no))),
          this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ln = new W(),
  io = new W(),
  ts = new W(),
  $n = new W(),
  ro = new W(),
  ns = new W(),
  so = new W();
class hh {
  constructor(e = new W(), t = new W(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Ln)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Ln.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (Ln.copy(this.origin).addScaledVector(this.direction, t),
        Ln.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, n, r) {
    io.copy(e).add(t).multiplyScalar(0.5),
      ts.copy(t).sub(e).normalize(),
      $n.copy(this.origin).sub(io);
    const s = e.distanceTo(t) * 0.5,
      a = -this.direction.dot(ts),
      o = $n.dot(this.direction),
      l = -$n.dot(ts),
      c = $n.lengthSq(),
      u = Math.abs(1 - a * a);
    let h, f, m, x;
    if (u > 0)
      if (((h = a * l - o), (f = a * o - l), (x = s * u), h >= 0))
        if (f >= -x)
          if (f <= x) {
            const g = 1 / u;
            (h *= g),
              (f *= g),
              (m = h * (h + a * f + 2 * o) + f * (a * h + f + 2 * l) + c);
          } else
            (f = s),
              (h = Math.max(0, -(a * f + o))),
              (m = -h * h + f * (f + 2 * l) + c);
        else
          (f = -s),
            (h = Math.max(0, -(a * f + o))),
            (m = -h * h + f * (f + 2 * l) + c);
      else
        f <= -x
          ? ((h = Math.max(0, -(-a * s + o))),
            (f = h > 0 ? -s : Math.min(Math.max(-s, -l), s)),
            (m = -h * h + f * (f + 2 * l) + c))
          : f <= x
            ? ((h = 0),
              (f = Math.min(Math.max(-s, -l), s)),
              (m = f * (f + 2 * l) + c))
            : ((h = Math.max(0, -(a * s + o))),
              (f = h > 0 ? s : Math.min(Math.max(-s, -l), s)),
              (m = -h * h + f * (f + 2 * l) + c));
    else
      (f = a > 0 ? -s : s),
        (h = Math.max(0, -(a * f + o))),
        (m = -h * h + f * (f + 2 * l) + c);
    return (
      n && n.copy(this.origin).addScaledVector(this.direction, h),
      r && r.copy(io).addScaledVector(ts, f),
      m
    );
  }
  intersectSphere(e, t) {
    Ln.subVectors(e.center, this.origin);
    const n = Ln.dot(this.direction),
      r = Ln.dot(Ln) - n * n,
      s = e.radius * e.radius;
    if (r > s) return null;
    const a = Math.sqrt(s - r),
      o = n - a,
      l = n + a;
    return l < 0 ? null : o < 0 ? this.at(l, t) : this.at(o, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let n, r, s, a, o, l;
    const c = 1 / this.direction.x,
      u = 1 / this.direction.y,
      h = 1 / this.direction.z,
      f = this.origin;
    return (
      c >= 0
        ? ((n = (e.min.x - f.x) * c), (r = (e.max.x - f.x) * c))
        : ((n = (e.max.x - f.x) * c), (r = (e.min.x - f.x) * c)),
      u >= 0
        ? ((s = (e.min.y - f.y) * u), (a = (e.max.y - f.y) * u))
        : ((s = (e.max.y - f.y) * u), (a = (e.min.y - f.y) * u)),
      n > a ||
      s > r ||
      ((s > n || isNaN(n)) && (n = s),
      (a < r || isNaN(r)) && (r = a),
      h >= 0
        ? ((o = (e.min.z - f.z) * h), (l = (e.max.z - f.z) * h))
        : ((o = (e.max.z - f.z) * h), (l = (e.min.z - f.z) * h)),
      n > l || o > r) ||
      ((o > n || n !== n) && (n = o), (l < r || r !== r) && (r = l), r < 0)
        ? null
        : this.at(n >= 0 ? n : r, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, Ln) !== null;
  }
  intersectTriangle(e, t, n, r, s) {
    ro.subVectors(t, e), ns.subVectors(n, e), so.crossVectors(ro, ns);
    let a = this.direction.dot(so),
      o;
    if (a > 0) {
      if (r) return null;
      o = 1;
    } else if (a < 0) (o = -1), (a = -a);
    else return null;
    $n.subVectors(this.origin, e);
    const l = o * this.direction.dot(ns.crossVectors($n, ns));
    if (l < 0) return null;
    const c = o * this.direction.dot(ro.cross($n));
    if (c < 0 || l + c > a) return null;
    const u = -o * $n.dot(so);
    return u < 0 ? null : this.at(u / a, s);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Tt {
  constructor(e, t, n, r, s, a, o, l, c, u, h, f, m, x, g, d) {
    (Tt.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, n, r, s, a, o, l, c, u, h, f, m, x, g, d);
  }
  set(e, t, n, r, s, a, o, l, c, u, h, f, m, x, g, d) {
    const p = this.elements;
    return (
      (p[0] = e),
      (p[4] = t),
      (p[8] = n),
      (p[12] = r),
      (p[1] = s),
      (p[5] = a),
      (p[9] = o),
      (p[13] = l),
      (p[2] = c),
      (p[6] = u),
      (p[10] = h),
      (p[14] = f),
      (p[3] = m),
      (p[7] = x),
      (p[11] = g),
      (p[15] = d),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Tt().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      n = e.elements;
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      (t[9] = n[9]),
      (t[10] = n[10]),
      (t[11] = n[11]),
      (t[12] = n[12]),
      (t[13] = n[13]),
      (t[14] = n[14]),
      (t[15] = n[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      n = e.elements;
    return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1,
      ),
      this
    );
  }
  extractBasis(e, t, n) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      n.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, n) {
    return (
      this.set(
        e.x,
        t.x,
        n.x,
        0,
        e.y,
        t.y,
        n.y,
        0,
        e.z,
        t.z,
        n.z,
        0,
        0,
        0,
        0,
        1,
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      n = e.elements,
      r = 1 / Hi.setFromMatrixColumn(e, 0).length(),
      s = 1 / Hi.setFromMatrixColumn(e, 1).length(),
      a = 1 / Hi.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = n[0] * r),
      (t[1] = n[1] * r),
      (t[2] = n[2] * r),
      (t[3] = 0),
      (t[4] = n[4] * s),
      (t[5] = n[5] * s),
      (t[6] = n[6] * s),
      (t[7] = 0),
      (t[8] = n[8] * a),
      (t[9] = n[9] * a),
      (t[10] = n[10] * a),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      n = e.x,
      r = e.y,
      s = e.z,
      a = Math.cos(n),
      o = Math.sin(n),
      l = Math.cos(r),
      c = Math.sin(r),
      u = Math.cos(s),
      h = Math.sin(s);
    if (e.order === "XYZ") {
      const f = a * u,
        m = a * h,
        x = o * u,
        g = o * h;
      (t[0] = l * u),
        (t[4] = -l * h),
        (t[8] = c),
        (t[1] = m + x * c),
        (t[5] = f - g * c),
        (t[9] = -o * l),
        (t[2] = g - f * c),
        (t[6] = x + m * c),
        (t[10] = a * l);
    } else if (e.order === "YXZ") {
      const f = l * u,
        m = l * h,
        x = c * u,
        g = c * h;
      (t[0] = f + g * o),
        (t[4] = x * o - m),
        (t[8] = a * c),
        (t[1] = a * h),
        (t[5] = a * u),
        (t[9] = -o),
        (t[2] = m * o - x),
        (t[6] = g + f * o),
        (t[10] = a * l);
    } else if (e.order === "ZXY") {
      const f = l * u,
        m = l * h,
        x = c * u,
        g = c * h;
      (t[0] = f - g * o),
        (t[4] = -a * h),
        (t[8] = x + m * o),
        (t[1] = m + x * o),
        (t[5] = a * u),
        (t[9] = g - f * o),
        (t[2] = -a * c),
        (t[6] = o),
        (t[10] = a * l);
    } else if (e.order === "ZYX") {
      const f = a * u,
        m = a * h,
        x = o * u,
        g = o * h;
      (t[0] = l * u),
        (t[4] = x * c - m),
        (t[8] = f * c + g),
        (t[1] = l * h),
        (t[5] = g * c + f),
        (t[9] = m * c - x),
        (t[2] = -c),
        (t[6] = o * l),
        (t[10] = a * l);
    } else if (e.order === "YZX") {
      const f = a * l,
        m = a * c,
        x = o * l,
        g = o * c;
      (t[0] = l * u),
        (t[4] = g - f * h),
        (t[8] = x * h + m),
        (t[1] = h),
        (t[5] = a * u),
        (t[9] = -o * u),
        (t[2] = -c * u),
        (t[6] = m * h + x),
        (t[10] = f - g * h);
    } else if (e.order === "XZY") {
      const f = a * l,
        m = a * c,
        x = o * l,
        g = o * c;
      (t[0] = l * u),
        (t[4] = -h),
        (t[8] = c * u),
        (t[1] = f * h + g),
        (t[5] = a * u),
        (t[9] = m * h - x),
        (t[2] = x * h - m),
        (t[6] = o * u),
        (t[10] = g * h + f);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(Dm, e, Pm);
  }
  lookAt(e, t, n) {
    const r = this.elements;
    return (
      sn.subVectors(e, t),
      sn.lengthSq() === 0 && (sn.z = 1),
      sn.normalize(),
      jn.crossVectors(n, sn),
      jn.lengthSq() === 0 &&
        (Math.abs(n.z) === 1 ? (sn.x += 1e-4) : (sn.z += 1e-4),
        sn.normalize(),
        jn.crossVectors(n, sn)),
      jn.normalize(),
      is.crossVectors(sn, jn),
      (r[0] = jn.x),
      (r[4] = is.x),
      (r[8] = sn.x),
      (r[1] = jn.y),
      (r[5] = is.y),
      (r[9] = sn.y),
      (r[2] = jn.z),
      (r[6] = is.z),
      (r[10] = sn.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements,
      r = t.elements,
      s = this.elements,
      a = n[0],
      o = n[4],
      l = n[8],
      c = n[12],
      u = n[1],
      h = n[5],
      f = n[9],
      m = n[13],
      x = n[2],
      g = n[6],
      d = n[10],
      p = n[14],
      y = n[3],
      E = n[7],
      v = n[11],
      C = n[15],
      A = r[0],
      S = r[4],
      R = r[8],
      M = r[12],
      _ = r[1],
      T = r[5],
      F = r[9],
      P = r[13],
      I = r[2],
      X = r[6],
      V = r[10],
      ie = r[14],
      k = r[3],
      ae = r[7],
      ce = r[11],
      H = r[15];
    return (
      (s[0] = a * A + o * _ + l * I + c * k),
      (s[4] = a * S + o * T + l * X + c * ae),
      (s[8] = a * R + o * F + l * V + c * ce),
      (s[12] = a * M + o * P + l * ie + c * H),
      (s[1] = u * A + h * _ + f * I + m * k),
      (s[5] = u * S + h * T + f * X + m * ae),
      (s[9] = u * R + h * F + f * V + m * ce),
      (s[13] = u * M + h * P + f * ie + m * H),
      (s[2] = x * A + g * _ + d * I + p * k),
      (s[6] = x * S + g * T + d * X + p * ae),
      (s[10] = x * R + g * F + d * V + p * ce),
      (s[14] = x * M + g * P + d * ie + p * H),
      (s[3] = y * A + E * _ + v * I + C * k),
      (s[7] = y * S + E * T + v * X + C * ae),
      (s[11] = y * R + E * F + v * V + C * ce),
      (s[15] = y * M + E * P + v * ie + C * H),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      n = e[4],
      r = e[8],
      s = e[12],
      a = e[1],
      o = e[5],
      l = e[9],
      c = e[13],
      u = e[2],
      h = e[6],
      f = e[10],
      m = e[14],
      x = e[3],
      g = e[7],
      d = e[11],
      p = e[15];
    return (
      x *
        (+s * l * h -
          r * c * h -
          s * o * f +
          n * c * f +
          r * o * m -
          n * l * m) +
      g *
        (+t * l * m -
          t * c * f +
          s * a * f -
          r * a * m +
          r * c * u -
          s * l * u) +
      d *
        (+t * c * h -
          t * o * m -
          s * a * h +
          n * a * m +
          s * o * u -
          n * c * u) +
      p *
        (-r * o * u - t * l * h + t * o * f + r * a * h - n * a * f + n * l * u)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, n) {
    const r = this.elements;
    return (
      e.isVector3
        ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
        : ((r[12] = e), (r[13] = t), (r[14] = n)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      r = e[2],
      s = e[3],
      a = e[4],
      o = e[5],
      l = e[6],
      c = e[7],
      u = e[8],
      h = e[9],
      f = e[10],
      m = e[11],
      x = e[12],
      g = e[13],
      d = e[14],
      p = e[15],
      y = h * d * c - g * f * c + g * l * m - o * d * m - h * l * p + o * f * p,
      E = x * f * c - u * d * c - x * l * m + a * d * m + u * l * p - a * f * p,
      v = u * g * c - x * h * c + x * o * m - a * g * m - u * o * p + a * h * p,
      C = x * h * l - u * g * l - x * o * f + a * g * f + u * o * d - a * h * d,
      A = t * y + n * E + r * v + s * C;
    if (A === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const S = 1 / A;
    return (
      (e[0] = y * S),
      (e[1] =
        (g * f * s -
          h * d * s -
          g * r * m +
          n * d * m +
          h * r * p -
          n * f * p) *
        S),
      (e[2] =
        (o * d * s -
          g * l * s +
          g * r * c -
          n * d * c -
          o * r * p +
          n * l * p) *
        S),
      (e[3] =
        (h * l * s -
          o * f * s -
          h * r * c +
          n * f * c +
          o * r * m -
          n * l * m) *
        S),
      (e[4] = E * S),
      (e[5] =
        (u * d * s -
          x * f * s +
          x * r * m -
          t * d * m -
          u * r * p +
          t * f * p) *
        S),
      (e[6] =
        (x * l * s -
          a * d * s -
          x * r * c +
          t * d * c +
          a * r * p -
          t * l * p) *
        S),
      (e[7] =
        (a * f * s -
          u * l * s +
          u * r * c -
          t * f * c -
          a * r * m +
          t * l * m) *
        S),
      (e[8] = v * S),
      (e[9] =
        (x * h * s -
          u * g * s -
          x * n * m +
          t * g * m +
          u * n * p -
          t * h * p) *
        S),
      (e[10] =
        (a * g * s -
          x * o * s +
          x * n * c -
          t * g * c -
          a * n * p +
          t * o * p) *
        S),
      (e[11] =
        (u * o * s -
          a * h * s -
          u * n * c +
          t * h * c +
          a * n * m -
          t * o * m) *
        S),
      (e[12] = C * S),
      (e[13] =
        (u * g * r -
          x * h * r +
          x * n * f -
          t * g * f -
          u * n * d +
          t * h * d) *
        S),
      (e[14] =
        (x * o * r -
          a * g * r -
          x * n * l +
          t * g * l +
          a * n * d -
          t * o * d) *
        S),
      (e[15] =
        (a * h * r -
          u * o * r +
          u * n * l -
          t * h * l -
          a * n * f +
          t * o * f) *
        S),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      n = e.x,
      r = e.y,
      s = e.z;
    return (
      (t[0] *= n),
      (t[4] *= r),
      (t[8] *= s),
      (t[1] *= n),
      (t[5] *= r),
      (t[9] *= s),
      (t[2] *= n),
      (t[6] *= r),
      (t[10] *= s),
      (t[3] *= n),
      (t[7] *= r),
      (t[11] *= s),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, r));
  }
  makeTranslation(e, t, n) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const n = Math.cos(t),
      r = Math.sin(t),
      s = 1 - n,
      a = e.x,
      o = e.y,
      l = e.z,
      c = s * a,
      u = s * o;
    return (
      this.set(
        c * a + n,
        c * o - r * l,
        c * l + r * o,
        0,
        c * o + r * l,
        u * o + n,
        u * l - r * a,
        0,
        c * l - r * o,
        u * l + r * a,
        s * l * l + n,
        0,
        0,
        0,
        0,
        1,
      ),
      this
    );
  }
  makeScale(e, t, n) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, n, r, s, a) {
    return this.set(1, n, s, 0, e, 1, a, 0, t, r, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, n) {
    const r = this.elements,
      s = t._x,
      a = t._y,
      o = t._z,
      l = t._w,
      c = s + s,
      u = a + a,
      h = o + o,
      f = s * c,
      m = s * u,
      x = s * h,
      g = a * u,
      d = a * h,
      p = o * h,
      y = l * c,
      E = l * u,
      v = l * h,
      C = n.x,
      A = n.y,
      S = n.z;
    return (
      (r[0] = (1 - (g + p)) * C),
      (r[1] = (m + v) * C),
      (r[2] = (x - E) * C),
      (r[3] = 0),
      (r[4] = (m - v) * A),
      (r[5] = (1 - (f + p)) * A),
      (r[6] = (d + y) * A),
      (r[7] = 0),
      (r[8] = (x + E) * S),
      (r[9] = (d - y) * S),
      (r[10] = (1 - (f + g)) * S),
      (r[11] = 0),
      (r[12] = e.x),
      (r[13] = e.y),
      (r[14] = e.z),
      (r[15] = 1),
      this
    );
  }
  decompose(e, t, n) {
    const r = this.elements;
    let s = Hi.set(r[0], r[1], r[2]).length();
    const a = Hi.set(r[4], r[5], r[6]).length(),
      o = Hi.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (s = -s),
      (e.x = r[12]),
      (e.y = r[13]),
      (e.z = r[14]),
      _n.copy(this);
    const c = 1 / s,
      u = 1 / a,
      h = 1 / o;
    return (
      (_n.elements[0] *= c),
      (_n.elements[1] *= c),
      (_n.elements[2] *= c),
      (_n.elements[4] *= u),
      (_n.elements[5] *= u),
      (_n.elements[6] *= u),
      (_n.elements[8] *= h),
      (_n.elements[9] *= h),
      (_n.elements[10] *= h),
      t.setFromRotationMatrix(_n),
      (n.x = s),
      (n.y = a),
      (n.z = o),
      this
    );
  }
  makePerspective(e, t, n, r, s, a, o = Hn) {
    const l = this.elements,
      c = (2 * s) / (t - e),
      u = (2 * s) / (n - r),
      h = (t + e) / (t - e),
      f = (n + r) / (n - r);
    let m, x;
    if (o === Hn) (m = -(a + s) / (a - s)), (x = (-2 * a * s) / (a - s));
    else if (o === Ta) (m = -a / (a - s)), (x = (-a * s) / (a - s));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o,
      );
    return (
      (l[0] = c),
      (l[4] = 0),
      (l[8] = h),
      (l[12] = 0),
      (l[1] = 0),
      (l[5] = u),
      (l[9] = f),
      (l[13] = 0),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = m),
      (l[14] = x),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = -1),
      (l[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, n, r, s, a, o = Hn) {
    const l = this.elements,
      c = 1 / (t - e),
      u = 1 / (n - r),
      h = 1 / (a - s),
      f = (t + e) * c,
      m = (n + r) * u;
    let x, g;
    if (o === Hn) (x = (a + s) * h), (g = -2 * h);
    else if (o === Ta) (x = s * h), (g = -1 * h);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o,
      );
    return (
      (l[0] = 2 * c),
      (l[4] = 0),
      (l[8] = 0),
      (l[12] = -f),
      (l[1] = 0),
      (l[5] = 2 * u),
      (l[9] = 0),
      (l[13] = -m),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = g),
      (l[14] = -x),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = 0),
      (l[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      n = e.elements;
    for (let r = 0; r < 16; r++) if (t[r] !== n[r]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return (
      (e[t] = n[0]),
      (e[t + 1] = n[1]),
      (e[t + 2] = n[2]),
      (e[t + 3] = n[3]),
      (e[t + 4] = n[4]),
      (e[t + 5] = n[5]),
      (e[t + 6] = n[6]),
      (e[t + 7] = n[7]),
      (e[t + 8] = n[8]),
      (e[t + 9] = n[9]),
      (e[t + 10] = n[10]),
      (e[t + 11] = n[11]),
      (e[t + 12] = n[12]),
      (e[t + 13] = n[13]),
      (e[t + 14] = n[14]),
      (e[t + 15] = n[15]),
      e
    );
  }
}
const Hi = new W(),
  _n = new Tt(),
  Dm = new W(0, 0, 0),
  Pm = new W(1, 1, 1),
  jn = new W(),
  is = new W(),
  sn = new W(),
  Au = new Tt(),
  bu = new Gr();
class Pn {
  constructor(e = 0, t = 0, n = 0, r = Pn.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._order = r);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, n, r = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._order = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, n = !0) {
    const r = e.elements,
      s = r[0],
      a = r[4],
      o = r[8],
      l = r[1],
      c = r[5],
      u = r[9],
      h = r[2],
      f = r[6],
      m = r[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin(ot(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(-u, m)), (this._z = Math.atan2(-a, s)))
            : ((this._x = Math.atan2(f, c)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-ot(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._y = Math.atan2(o, m)), (this._z = Math.atan2(l, c)))
            : ((this._y = Math.atan2(-h, s)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(ot(f, -1, 1))),
          Math.abs(f) < 0.9999999
            ? ((this._y = Math.atan2(-h, m)), (this._z = Math.atan2(-a, c)))
            : ((this._y = 0), (this._z = Math.atan2(l, s)));
        break;
      case "ZYX":
        (this._y = Math.asin(-ot(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._x = Math.atan2(f, m)), (this._z = Math.atan2(l, s)))
            : ((this._x = 0), (this._z = Math.atan2(-a, c)));
        break;
      case "YZX":
        (this._z = Math.asin(ot(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-u, c)), (this._y = Math.atan2(-h, s)))
            : ((this._x = 0), (this._y = Math.atan2(o, m)));
        break;
      case "XZY":
        (this._z = Math.asin(-ot(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(f, c)), (this._y = Math.atan2(o, s)))
            : ((this._x = Math.atan2(-u, m)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t,
        );
    }
    return (this._order = t), n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, n) {
    return (
      Au.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Au, t, n)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return bu.setFromEuler(this), this.setFromQuaternion(bu, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Pn.DEFAULT_ORDER = "XYZ";
class dh {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let Fm = 0;
const Tu = new W(),
  Vi = new Gr(),
  Un = new Tt(),
  rs = new W(),
  Tr = new W(),
  Bm = new W(),
  Lm = new Gr(),
  Cu = new W(1, 0, 0),
  wu = new W(0, 1, 0),
  Ru = new W(0, 0, 1),
  Du = { type: "added" },
  Um = { type: "removed" },
  Gi = { type: "childadded", child: null },
  ao = { type: "childremoved", child: null };
class Yt extends xr {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: Fm++ }),
      (this.uuid = ii()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Yt.DEFAULT_UP.clone());
    const e = new W(),
      t = new Pn(),
      n = new Gr(),
      r = new W(1, 1, 1);
    function s() {
      n.setFromEuler(t, !1);
    }
    function a() {
      t.setFromQuaternion(n, void 0, !1);
    }
    t._onChange(s),
      n._onChange(a),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: n },
        scale: { configurable: !0, enumerable: !0, value: r },
        modelViewMatrix: { value: new Tt() },
        normalMatrix: { value: new Ze() },
      }),
      (this.matrix = new Tt()),
      (this.matrixWorld = new Tt()),
      (this.matrixAutoUpdate = Yt.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = Yt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new dh()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Vi.setFromAxisAngle(e, t), this.quaternion.multiply(Vi), this;
  }
  rotateOnWorldAxis(e, t) {
    return Vi.setFromAxisAngle(e, t), this.quaternion.premultiply(Vi), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(Cu, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(wu, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(Ru, e);
  }
  translateOnAxis(e, t) {
    return (
      Tu.copy(e).applyQuaternion(this.quaternion),
      this.position.add(Tu.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(Cu, e);
  }
  translateY(e) {
    return this.translateOnAxis(wu, e);
  }
  translateZ(e) {
    return this.translateOnAxis(Ru, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(Un.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, n) {
    e.isVector3 ? rs.copy(e) : rs.set(e, t, n);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1),
      Tr.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? Un.lookAt(Tr, rs, this.up)
        : Un.lookAt(rs, Tr, this.up),
      this.quaternion.setFromRotationMatrix(Un),
      r &&
        (Un.extractRotation(r.matrixWorld),
        Vi.setFromRotationMatrix(Un),
        this.quaternion.premultiply(Vi.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e,
        ),
        this)
      : (e && e.isObject3D
          ? (e.removeFromParent(),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(Du),
            (Gi.child = e),
            this.dispatchEvent(Gi),
            (Gi.child = null))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e,
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null),
        this.children.splice(t, 1),
        e.dispatchEvent(Um),
        (ao.child = e),
        this.dispatchEvent(ao),
        (ao.child = null)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      Un.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), Un.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(Un),
      e.removeFromParent(),
      (e.parent = this),
      this.children.push(e),
      e.updateWorldMatrix(!1, !0),
      e.dispatchEvent(Du),
      (Gi.child = e),
      this.dispatchEvent(Gi),
      (Gi.child = null),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let n = 0, r = this.children.length; n < r; n++) {
      const a = this.children[n].getObjectByProperty(e, t);
      if (a !== void 0) return a;
    }
  }
  getObjectsByProperty(e, t, n = []) {
    this[e] === t && n.push(this);
    const r = this.children;
    for (let s = 0, a = r.length; s < a; s++)
      r[s].getObjectsByProperty(e, t, n);
    return n;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Tr, e, Bm), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Tr, Lm, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, r = t.length; n < r; n++) t[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let n = 0, r = t.length; n < r; n++) t[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.matrixWorldAutoUpdate === !0 &&
          (this.parent === null
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix,
              )),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let n = 0, r = t.length; n < r; n++) t[n].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (
      (e === !0 && n !== null && n.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.matrixWorldAutoUpdate === !0 &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix,
            )),
      t === !0)
    ) {
      const r = this.children;
      for (let s = 0, a = r.length; s < a; s++) r[s].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      n = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (n.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const r = {};
    (r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== "" && (r.name = this.name),
      this.castShadow === !0 && (r.castShadow = !0),
      this.receiveShadow === !0 && (r.receiveShadow = !0),
      this.visible === !1 && (r.visible = !1),
      this.frustumCulled === !1 && (r.frustumCulled = !1),
      this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      (r.layers = this.layers.mask),
      (r.matrix = this.matrix.toArray()),
      (r.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((r.type = "InstancedMesh"),
        (r.count = this.count),
        (r.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (r.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((r.type = "BatchedMesh"),
        (r.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (r.sortObjects = this.sortObjects),
        (r.drawRanges = this._drawRanges),
        (r.reservedRanges = this._reservedRanges),
        (r.visibility = this._visibility),
        (r.active = this._active),
        (r.bounds = this._bounds.map((o) => ({
          boxInitialized: o.boxInitialized,
          boxMin: o.box.min.toArray(),
          boxMax: o.box.max.toArray(),
          sphereInitialized: o.sphereInitialized,
          sphereRadius: o.sphere.radius,
          sphereCenter: o.sphere.center.toArray(),
        }))),
        (r.maxInstanceCount = this._maxInstanceCount),
        (r.maxVertexCount = this._maxVertexCount),
        (r.maxIndexCount = this._maxIndexCount),
        (r.geometryInitialized = this._geometryInitialized),
        (r.geometryCount = this._geometryCount),
        (r.matricesTexture = this._matricesTexture.toJSON(e)),
        this._colorsTexture !== null &&
          (r.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null &&
          (r.boundingSphere = {
            center: r.boundingSphere.center.toArray(),
            radius: r.boundingSphere.radius,
          }),
        this.boundingBox !== null &&
          (r.boundingBox = {
            min: r.boundingBox.min.toArray(),
            max: r.boundingBox.max.toArray(),
          }));
    function s(o, l) {
      return o[l.uuid] === void 0 && (o[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (r.background = this.background.toJSON())
          : this.background.isTexture &&
            (r.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (r.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(e.geometries, this.geometry);
      const o = this.geometry.parameters;
      if (o !== void 0 && o.shapes !== void 0) {
        const l = o.shapes;
        if (Array.isArray(l))
          for (let c = 0, u = l.length; c < u; c++) {
            const h = l[c];
            s(e.shapes, h);
          }
        else s(e.shapes, l);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((r.bindMode = this.bindMode),
        (r.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), (r.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const o = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          o.push(s(e.materials, this.material[l]));
        r.material = o;
      } else r.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let o = 0; o < this.children.length; o++)
        r.children.push(this.children[o].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let o = 0; o < this.animations.length; o++) {
        const l = this.animations[o];
        r.animations.push(s(e.animations, l));
      }
    }
    if (t) {
      const o = a(e.geometries),
        l = a(e.materials),
        c = a(e.textures),
        u = a(e.images),
        h = a(e.shapes),
        f = a(e.skeletons),
        m = a(e.animations),
        x = a(e.nodes);
      o.length > 0 && (n.geometries = o),
        l.length > 0 && (n.materials = l),
        c.length > 0 && (n.textures = c),
        u.length > 0 && (n.images = u),
        h.length > 0 && (n.shapes = h),
        f.length > 0 && (n.skeletons = f),
        m.length > 0 && (n.animations = m),
        x.length > 0 && (n.nodes = x);
    }
    return (n.object = r), n;
    function a(o) {
      const l = [];
      for (const c in o) {
        const u = o[c];
        delete u.metadata, l.push(u);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let n = 0; n < e.children.length; n++) {
        const r = e.children[n];
        this.add(r.clone());
      }
    return this;
  }
}
Yt.DEFAULT_UP = new W(0, 1, 0);
Yt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Yt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const vn = new W(),
  In = new W(),
  oo = new W(),
  Nn = new W(),
  Wi = new W(),
  Xi = new W(),
  Pu = new W(),
  co = new W(),
  lo = new W(),
  uo = new W(),
  fo = new yt(),
  ho = new yt(),
  po = new yt();
class mn {
  constructor(e = new W(), t = new W(), n = new W()) {
    (this.a = e), (this.b = t), (this.c = n);
  }
  static getNormal(e, t, n, r) {
    r.subVectors(n, t), vn.subVectors(e, t), r.cross(vn);
    const s = r.lengthSq();
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
  }
  static getBarycoord(e, t, n, r, s) {
    vn.subVectors(r, t), In.subVectors(n, t), oo.subVectors(e, t);
    const a = vn.dot(vn),
      o = vn.dot(In),
      l = vn.dot(oo),
      c = In.dot(In),
      u = In.dot(oo),
      h = a * c - o * o;
    if (h === 0) return s.set(0, 0, 0), null;
    const f = 1 / h,
      m = (c * l - o * u) * f,
      x = (a * u - o * l) * f;
    return s.set(1 - m - x, x, m);
  }
  static containsPoint(e, t, n, r) {
    return this.getBarycoord(e, t, n, r, Nn) === null
      ? !1
      : Nn.x >= 0 && Nn.y >= 0 && Nn.x + Nn.y <= 1;
  }
  static getInterpolation(e, t, n, r, s, a, o, l) {
    return this.getBarycoord(e, t, n, r, Nn) === null
      ? ((l.x = 0),
        (l.y = 0),
        "z" in l && (l.z = 0),
        "w" in l && (l.w = 0),
        null)
      : (l.setScalar(0),
        l.addScaledVector(s, Nn.x),
        l.addScaledVector(a, Nn.y),
        l.addScaledVector(o, Nn.z),
        l);
  }
  static getInterpolatedAttribute(e, t, n, r, s, a) {
    return (
      fo.setScalar(0),
      ho.setScalar(0),
      po.setScalar(0),
      fo.fromBufferAttribute(e, t),
      ho.fromBufferAttribute(e, n),
      po.fromBufferAttribute(e, r),
      a.setScalar(0),
      a.addScaledVector(fo, s.x),
      a.addScaledVector(ho, s.y),
      a.addScaledVector(po, s.z),
      a
    );
  }
  static isFrontFacing(e, t, n, r) {
    return vn.subVectors(n, t), In.subVectors(e, t), vn.cross(In).dot(r) < 0;
  }
  set(e, t, n) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, t, n, r) {
    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this;
  }
  setFromAttributeAndIndices(e, t, n, r) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, n),
      this.c.fromBufferAttribute(e, r),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      vn.subVectors(this.c, this.b),
      In.subVectors(this.a, this.b),
      vn.cross(In).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return mn.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return mn.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, n, r, s) {
    return mn.getInterpolation(e, this.a, this.b, this.c, t, n, r, s);
  }
  containsPoint(e) {
    return mn.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return mn.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const n = this.a,
      r = this.b,
      s = this.c;
    let a, o;
    Wi.subVectors(r, n), Xi.subVectors(s, n), co.subVectors(e, n);
    const l = Wi.dot(co),
      c = Xi.dot(co);
    if (l <= 0 && c <= 0) return t.copy(n);
    lo.subVectors(e, r);
    const u = Wi.dot(lo),
      h = Xi.dot(lo);
    if (u >= 0 && h <= u) return t.copy(r);
    const f = l * h - u * c;
    if (f <= 0 && l >= 0 && u <= 0)
      return (a = l / (l - u)), t.copy(n).addScaledVector(Wi, a);
    uo.subVectors(e, s);
    const m = Wi.dot(uo),
      x = Xi.dot(uo);
    if (x >= 0 && m <= x) return t.copy(s);
    const g = m * c - l * x;
    if (g <= 0 && c >= 0 && x <= 0)
      return (o = c / (c - x)), t.copy(n).addScaledVector(Xi, o);
    const d = u * x - m * h;
    if (d <= 0 && h - u >= 0 && m - x >= 0)
      return (
        Pu.subVectors(s, r),
        (o = (h - u) / (h - u + (m - x))),
        t.copy(r).addScaledVector(Pu, o)
      );
    const p = 1 / (d + g + f);
    return (
      (a = g * p),
      (o = f * p),
      t.copy(n).addScaledVector(Wi, a).addScaledVector(Xi, o)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const ph = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  Kn = { h: 0, s: 0, l: 0 },
  ss = { h: 0, s: 0, l: 0 };
function mo(i, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? i + (e - i) * 6 * t
      : t < 1 / 2
        ? e
        : t < 2 / 3
          ? i + (e - i) * 6 * (2 / 3 - t)
          : i
  );
}
class ut {
  constructor(e, t, n) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, t, n)
    );
  }
  set(e, t, n) {
    if (t === void 0 && n === void 0) {
      const r = e;
      r && r.isColor
        ? this.copy(r)
        : typeof r == "number"
          ? this.setHex(r)
          : typeof r == "string" && this.setStyle(r);
    } else this.setRGB(e, t, n);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = hn) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      pt.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, n, r = pt.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = n),
      pt.toWorkingColorSpace(this, r),
      this
    );
  }
  setHSL(e, t, n, r = pt.workingColorSpace) {
    if (((e = _m(e, 1)), (t = ot(t, 0, 1)), (n = ot(n, 0, 1)), t === 0))
      this.r = this.g = this.b = n;
    else {
      const s = n <= 0.5 ? n * (1 + t) : n + t - n * t,
        a = 2 * n - s;
      (this.r = mo(a, s, e + 1 / 3)),
        (this.g = mo(a, s, e)),
        (this.b = mo(a, s, e - 1 / 3));
    }
    return pt.toWorkingColorSpace(this, r), this;
  }
  setStyle(e, t = hn) {
    function n(s) {
      s !== void 0 &&
        parseFloat(s) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored.",
        );
    }
    let r;
    if ((r = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let s;
      const a = r[1],
        o = r[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (
            (s =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o,
              ))
          )
            return (
              n(s[4]),
              this.setRGB(
                Math.min(255, parseInt(s[1], 10)) / 255,
                Math.min(255, parseInt(s[2], 10)) / 255,
                Math.min(255, parseInt(s[3], 10)) / 255,
                t,
              )
            );
          if (
            (s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o,
              ))
          )
            return (
              n(s[4]),
              this.setRGB(
                Math.min(100, parseInt(s[1], 10)) / 100,
                Math.min(100, parseInt(s[2], 10)) / 100,
                Math.min(100, parseInt(s[3], 10)) / 100,
                t,
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o,
              ))
          )
            return (
              n(s[4]),
              this.setHSL(
                parseFloat(s[1]) / 360,
                parseFloat(s[2]) / 100,
                parseFloat(s[3]) / 100,
                t,
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((r = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const s = r[1],
        a = s.length;
      if (a === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          t,
        );
      if (a === 6) return this.setHex(parseInt(s, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = hn) {
    const n = ph[e.toLowerCase()];
    return (
      n !== void 0
        ? this.setHex(n, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = Gn(e.r)), (this.g = Gn(e.g)), (this.b = Gn(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = sr(e.r)), (this.g = sr(e.g)), (this.b = sr(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = hn) {
    return (
      pt.fromWorkingColorSpace(Wt.copy(this), e),
      Math.round(ot(Wt.r * 255, 0, 255)) * 65536 +
        Math.round(ot(Wt.g * 255, 0, 255)) * 256 +
        Math.round(ot(Wt.b * 255, 0, 255))
    );
  }
  getHexString(e = hn) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = pt.workingColorSpace) {
    pt.fromWorkingColorSpace(Wt.copy(this), t);
    const n = Wt.r,
      r = Wt.g,
      s = Wt.b,
      a = Math.max(n, r, s),
      o = Math.min(n, r, s);
    let l, c;
    const u = (o + a) / 2;
    if (o === a) (l = 0), (c = 0);
    else {
      const h = a - o;
      switch (((c = u <= 0.5 ? h / (a + o) : h / (2 - a - o)), a)) {
        case n:
          l = (r - s) / h + (r < s ? 6 : 0);
          break;
        case r:
          l = (s - n) / h + 2;
          break;
        case s:
          l = (n - r) / h + 4;
          break;
      }
      l /= 6;
    }
    return (e.h = l), (e.s = c), (e.l = u), e;
  }
  getRGB(e, t = pt.workingColorSpace) {
    return (
      pt.fromWorkingColorSpace(Wt.copy(this), t),
      (e.r = Wt.r),
      (e.g = Wt.g),
      (e.b = Wt.b),
      e
    );
  }
  getStyle(e = hn) {
    pt.fromWorkingColorSpace(Wt.copy(this), e);
    const t = Wt.r,
      n = Wt.g,
      r = Wt.b;
    return e !== hn
      ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${r.toFixed(3)})`
      : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(r * 255)})`;
  }
  offsetHSL(e, t, n) {
    return this.getHSL(Kn), this.setHSL(Kn.h + e, Kn.s + t, Kn.l + n);
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, n) {
    return (
      (this.r = e.r + (t.r - e.r) * n),
      (this.g = e.g + (t.g - e.g) * n),
      (this.b = e.b + (t.b - e.b) * n),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(Kn), e.getHSL(ss);
    const n = Za(Kn.h, ss.h, t),
      r = Za(Kn.s, ss.s, t),
      s = Za(Kn.l, ss.l, t);
    return this.setHSL(n, r, s), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const t = this.r,
      n = this.g,
      r = this.b,
      s = e.elements;
    return (
      (this.r = s[0] * t + s[3] * n + s[6] * r),
      (this.g = s[1] * t + s[4] * n + s[7] * r),
      (this.b = s[2] * t + s[5] * n + s[8] * r),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const Wt = new ut();
ut.NAMES = ph;
let Im = 0;
class Fi extends xr {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: Im++ }),
      (this.uuid = ii()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = ir),
      (this.side = si),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = ko),
      (this.blendDst = Ho),
      (this.blendEquation = vi),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new ut(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = cr),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = _u),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = Ii),
      (this.stencilZFail = Ii),
      (this.stencilZPass = Ii),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          console.warn(
            `THREE.Material: parameter '${t}' has value of undefined.`,
          );
          continue;
        }
        const r = this[t];
        if (r === void 0) {
          console.warn(
            `THREE.Material: '${t}' is not a property of THREE.${this.type}.`,
          );
          continue;
        }
        r && r.isColor
          ? r.set(n)
          : r && r.isVector3 && n && n.isVector3
            ? r.copy(n)
            : (this[t] = n);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const n = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (n.uuid = this.uuid),
      (n.type = this.type),
      this.name !== "" && (n.name = this.name),
      this.color && this.color.isColor && (n.color = this.color.getHex()),
      this.roughness !== void 0 && (n.roughness = this.roughness),
      this.metalness !== void 0 && (n.metalness = this.metalness),
      this.sheen !== void 0 && (n.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (n.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (n.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (n.emissive = this.emissive.getHex()),
      this.emissiveIntensity !== void 0 &&
        this.emissiveIntensity !== 1 &&
        (n.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (n.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (n.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (n.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (n.shininess = this.shininess),
      this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (n.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.dispersion !== void 0 && (n.dispersion = this.dispersion),
      this.iridescence !== void 0 && (n.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (n.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (n.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (n.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (n.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (n.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((n.lightMap = this.lightMap.toJSON(e).uuid),
        (n.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((n.aoMap = this.aoMap.toJSON(e).uuid),
        (n.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
        (n.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((n.normalMap = this.normalMap.toJSON(e).uuid),
        (n.normalMapType = this.normalMapType),
        (n.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
        (n.displacementScale = this.displacementScale),
        (n.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (n.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((n.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (n.combine = this.combine)),
      this.envMapRotation !== void 0 &&
        (n.envMapRotation = this.envMapRotation.toArray()),
      this.envMapIntensity !== void 0 &&
        (n.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (n.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (n.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (n.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (n.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (n.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (n.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (n.size = this.size),
      this.shadowSide !== null && (n.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (n.sizeAttenuation = this.sizeAttenuation),
      this.blending !== ir && (n.blending = this.blending),
      this.side !== si && (n.side = this.side),
      this.vertexColors === !0 && (n.vertexColors = !0),
      this.opacity < 1 && (n.opacity = this.opacity),
      this.transparent === !0 && (n.transparent = !0),
      this.blendSrc !== ko && (n.blendSrc = this.blendSrc),
      this.blendDst !== Ho && (n.blendDst = this.blendDst),
      this.blendEquation !== vi && (n.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (n.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (n.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha),
      this.depthFunc !== cr && (n.depthFunc = this.depthFunc),
      this.depthTest === !1 && (n.depthTest = this.depthTest),
      this.depthWrite === !1 && (n.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (n.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (n.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== _u && (n.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (n.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (n.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== Ii && (n.stencilFail = this.stencilFail),
      this.stencilZFail !== Ii && (n.stencilZFail = this.stencilZFail),
      this.stencilZPass !== Ii && (n.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (n.rotation = this.rotation),
      this.polygonOffset === !0 && (n.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (n.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (n.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (n.linewidth = this.linewidth),
      this.dashSize !== void 0 && (n.dashSize = this.dashSize),
      this.gapSize !== void 0 && (n.gapSize = this.gapSize),
      this.scale !== void 0 && (n.scale = this.scale),
      this.dithering === !0 && (n.dithering = !0),
      this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (n.alphaHash = !0),
      this.alphaToCoverage === !0 && (n.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (n.forceSinglePass = !0),
      this.wireframe === !0 && (n.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (n.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (n.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (n.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (n.flatShading = !0),
      this.visible === !1 && (n.visible = !1),
      this.toneMapped === !1 && (n.toneMapped = !1),
      this.fog === !1 && (n.fog = !1),
      Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function r(s) {
      const a = [];
      for (const o in s) {
        const l = s[o];
        delete l.metadata, a.push(l);
      }
      return a;
    }
    if (t) {
      const s = r(e.textures),
        a = r(e.images);
      s.length > 0 && (n.textures = s), a.length > 0 && (n.images = a);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let n = null;
    if (t !== null) {
      const r = t.length;
      n = new Array(r);
      for (let s = 0; s !== r; ++s) n[s] = t[s].clone();
    }
    return (
      (this.clippingPlanes = n),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}
class mh extends Fi {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new ut(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Pn()),
      (this.combine = Xc),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const Pt = new W(),
  as = new it();
let Nm = 0;
class An {
  constructor(e, t, n = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array.",
      );
    (this.isBufferAttribute = !0),
      Object.defineProperty(this, "id", { value: Nm++ }),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = n),
      (this.usage = bc),
      (this.updateRanges = []),
      (this.gpuType = kn),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, t, n) {
    (e *= this.itemSize), (n *= t.itemSize);
    for (let r = 0, s = this.itemSize; r < s; r++)
      this.array[e + r] = t.array[n + r];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, n = this.count; t < n; t++)
        as.fromBufferAttribute(this, t),
          as.applyMatrix3(e),
          this.setXY(t, as.x, as.y);
    else if (this.itemSize === 3)
      for (let t = 0, n = this.count; t < n; t++)
        Pt.fromBufferAttribute(this, t),
          Pt.applyMatrix3(e),
          this.setXYZ(t, Pt.x, Pt.y, Pt.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Pt.fromBufferAttribute(this, t),
        Pt.applyMatrix4(e),
        this.setXYZ(t, Pt.x, Pt.y, Pt.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Pt.fromBufferAttribute(this, t),
        Pt.applyNormalMatrix(e),
        this.setXYZ(t, Pt.x, Pt.y, Pt.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Pt.fromBufferAttribute(this, t),
        Pt.transformDirection(e),
        this.setXYZ(t, Pt.x, Pt.y, Pt.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.itemSize + t];
    return this.normalized && (n = Rn(n, this.array)), n;
  }
  setComponent(e, t, n) {
    return (
      this.normalized && (n = Et(n, this.array)),
      (this.array[e * this.itemSize + t] = n),
      this
    );
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Rn(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = Et(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Rn(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = Et(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Rn(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Et(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Rn(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = Et(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, n) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = Et(t, this.array)), (n = Et(n, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      this
    );
  }
  setXYZ(e, t, n, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Et(t, this.array)),
        (n = Et(n, this.array)),
        (r = Et(r, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      (this.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, t, n, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Et(t, this.array)),
        (n = Et(n, this.array)),
        (r = Et(r, this.array)),
        (s = Et(s, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      (this.array[e + 2] = r),
      (this.array[e + 3] = s),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== bc && (e.usage = this.usage),
      e
    );
  }
}
class xh extends An {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
class gh extends An {
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
}
class cn extends An {
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
}
let Om = 0;
const fn = new Tt(),
  xo = new Yt(),
  qi = new W(),
  an = new Wr(),
  Cr = new Wr(),
  zt = new W();
class bn extends xr {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: Om++ }),
      (this.uuid = ii()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.indirect = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (lh(e) ? gh : xh)(e, 1))
        : (this.index = e),
      this
    );
  }
  setIndirect(e) {
    return (this.indirect = e), this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, n = 0) {
    this.groups.push({ start: e, count: t, materialIndex: n });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const n = this.attributes.normal;
    if (n !== void 0) {
      const s = new Ze().getNormalMatrix(e);
      n.applyNormalMatrix(s), (n.needsUpdate = !0);
    }
    const r = this.attributes.tangent;
    return (
      r !== void 0 && (r.transformDirection(e), (r.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return fn.makeRotationFromQuaternion(e), this.applyMatrix4(fn), this;
  }
  rotateX(e) {
    return fn.makeRotationX(e), this.applyMatrix4(fn), this;
  }
  rotateY(e) {
    return fn.makeRotationY(e), this.applyMatrix4(fn), this;
  }
  rotateZ(e) {
    return fn.makeRotationZ(e), this.applyMatrix4(fn), this;
  }
  translate(e, t, n) {
    return fn.makeTranslation(e, t, n), this.applyMatrix4(fn), this;
  }
  scale(e, t, n) {
    return fn.makeScale(e, t, n), this.applyMatrix4(fn), this;
  }
  lookAt(e) {
    return xo.lookAt(e), xo.updateMatrix(), this.applyMatrix4(xo.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(qi).negate(),
      this.translate(qi.x, qi.y, qi.z),
      this
    );
  }
  setFromPoints(e) {
    const t = this.getAttribute("position");
    if (t === void 0) {
      const n = [];
      for (let r = 0, s = e.length; r < s; r++) {
        const a = e[r];
        n.push(a.x, a.y, a.z || 0);
      }
      this.setAttribute("position", new cn(n, 3));
    } else {
      const n = Math.min(e.length, t.count);
      for (let r = 0; r < n; r++) {
        const s = e[r];
        t.setXYZ(r, s.x, s.y, s.z || 0);
      }
      e.length > t.count &&
        console.warn(
          "THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.",
        ),
        (t.needsUpdate = !0);
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Wr());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
        this,
      ),
        this.boundingBox.set(
          new W(-1 / 0, -1 / 0, -1 / 0),
          new W(1 / 0, 1 / 0, 1 / 0),
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let n = 0, r = t.length; n < r; n++) {
          const s = t[n];
          an.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (zt.addVectors(this.boundingBox.min, an.min),
                this.boundingBox.expandByPoint(zt),
                zt.addVectors(this.boundingBox.max, an.max),
                this.boundingBox.expandByPoint(zt))
              : (this.boundingBox.expandByPoint(an.min),
                this.boundingBox.expandByPoint(an.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this,
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Fa());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
        this,
      ),
        this.boundingSphere.set(new W(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if ((an.setFromBufferAttribute(e), t))
        for (let s = 0, a = t.length; s < a; s++) {
          const o = t[s];
          Cr.setFromBufferAttribute(o),
            this.morphTargetsRelative
              ? (zt.addVectors(an.min, Cr.min),
                an.expandByPoint(zt),
                zt.addVectors(an.max, Cr.max),
                an.expandByPoint(zt))
              : (an.expandByPoint(Cr.min), an.expandByPoint(Cr.max));
        }
      an.getCenter(n);
      let r = 0;
      for (let s = 0, a = e.count; s < a; s++)
        zt.fromBufferAttribute(e, s),
          (r = Math.max(r, n.distanceToSquared(zt)));
      if (t)
        for (let s = 0, a = t.length; s < a; s++) {
          const o = t[s],
            l = this.morphTargetsRelative;
          for (let c = 0, u = o.count; c < u; c++)
            zt.fromBufferAttribute(o, c),
              l && (qi.fromBufferAttribute(e, c), zt.add(qi)),
              (r = Math.max(r, n.distanceToSquared(zt)));
        }
      (this.boundingSphere.radius = Math.sqrt(r)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this,
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)",
      );
      return;
    }
    const n = t.position,
      r = t.normal,
      s = t.uv;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new An(new Float32Array(4 * n.count), 4));
    const a = this.getAttribute("tangent"),
      o = [],
      l = [];
    for (let R = 0; R < n.count; R++) (o[R] = new W()), (l[R] = new W());
    const c = new W(),
      u = new W(),
      h = new W(),
      f = new it(),
      m = new it(),
      x = new it(),
      g = new W(),
      d = new W();
    function p(R, M, _) {
      c.fromBufferAttribute(n, R),
        u.fromBufferAttribute(n, M),
        h.fromBufferAttribute(n, _),
        f.fromBufferAttribute(s, R),
        m.fromBufferAttribute(s, M),
        x.fromBufferAttribute(s, _),
        u.sub(c),
        h.sub(c),
        m.sub(f),
        x.sub(f);
      const T = 1 / (m.x * x.y - x.x * m.y);
      isFinite(T) &&
        (g
          .copy(u)
          .multiplyScalar(x.y)
          .addScaledVector(h, -m.y)
          .multiplyScalar(T),
        d
          .copy(h)
          .multiplyScalar(m.x)
          .addScaledVector(u, -x.x)
          .multiplyScalar(T),
        o[R].add(g),
        o[M].add(g),
        o[_].add(g),
        l[R].add(d),
        l[M].add(d),
        l[_].add(d));
    }
    let y = this.groups;
    y.length === 0 && (y = [{ start: 0, count: e.count }]);
    for (let R = 0, M = y.length; R < M; ++R) {
      const _ = y[R],
        T = _.start,
        F = _.count;
      for (let P = T, I = T + F; P < I; P += 3)
        p(e.getX(P + 0), e.getX(P + 1), e.getX(P + 2));
    }
    const E = new W(),
      v = new W(),
      C = new W(),
      A = new W();
    function S(R) {
      C.fromBufferAttribute(r, R), A.copy(C);
      const M = o[R];
      E.copy(M),
        E.sub(C.multiplyScalar(C.dot(M))).normalize(),
        v.crossVectors(A, M);
      const T = v.dot(l[R]) < 0 ? -1 : 1;
      a.setXYZW(R, E.x, E.y, E.z, T);
    }
    for (let R = 0, M = y.length; R < M; ++R) {
      const _ = y[R],
        T = _.start,
        F = _.count;
      for (let P = T, I = T + F; P < I; P += 3)
        S(e.getX(P + 0)), S(e.getX(P + 1)), S(e.getX(P + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        (n = new An(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", n);
      else for (let f = 0, m = n.count; f < m; f++) n.setXYZ(f, 0, 0, 0);
      const r = new W(),
        s = new W(),
        a = new W(),
        o = new W(),
        l = new W(),
        c = new W(),
        u = new W(),
        h = new W();
      if (e)
        for (let f = 0, m = e.count; f < m; f += 3) {
          const x = e.getX(f + 0),
            g = e.getX(f + 1),
            d = e.getX(f + 2);
          r.fromBufferAttribute(t, x),
            s.fromBufferAttribute(t, g),
            a.fromBufferAttribute(t, d),
            u.subVectors(a, s),
            h.subVectors(r, s),
            u.cross(h),
            o.fromBufferAttribute(n, x),
            l.fromBufferAttribute(n, g),
            c.fromBufferAttribute(n, d),
            o.add(u),
            l.add(u),
            c.add(u),
            n.setXYZ(x, o.x, o.y, o.z),
            n.setXYZ(g, l.x, l.y, l.z),
            n.setXYZ(d, c.x, c.y, c.z);
        }
      else
        for (let f = 0, m = t.count; f < m; f += 3)
          r.fromBufferAttribute(t, f + 0),
            s.fromBufferAttribute(t, f + 1),
            a.fromBufferAttribute(t, f + 2),
            u.subVectors(a, s),
            h.subVectors(r, s),
            u.cross(h),
            n.setXYZ(f + 0, u.x, u.y, u.z),
            n.setXYZ(f + 1, u.x, u.y, u.z),
            n.setXYZ(f + 2, u.x, u.y, u.z);
      this.normalizeNormals(), (n.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++)
      zt.fromBufferAttribute(e, t),
        zt.normalize(),
        e.setXYZ(t, zt.x, zt.y, zt.z);
  }
  toNonIndexed() {
    function e(o, l) {
      const c = o.array,
        u = o.itemSize,
        h = o.normalized,
        f = new c.constructor(l.length * u);
      let m = 0,
        x = 0;
      for (let g = 0, d = l.length; g < d; g++) {
        o.isInterleavedBufferAttribute
          ? (m = l[g] * o.data.stride + o.offset)
          : (m = l[g] * u);
        for (let p = 0; p < u; p++) f[x++] = c[m++];
      }
      return new An(f, u, h);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.",
        ),
        this
      );
    const t = new bn(),
      n = this.index.array,
      r = this.attributes;
    for (const o in r) {
      const l = r[o],
        c = e(l, n);
      t.setAttribute(o, c);
    }
    const s = this.morphAttributes;
    for (const o in s) {
      const l = [],
        c = s[o];
      for (let u = 0, h = c.length; u < h; u++) {
        const f = c[u],
          m = e(f, n);
        l.push(m);
      }
      t.morphAttributes[o] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const a = this.groups;
    for (let o = 0, l = a.length; o < l; o++) {
      const c = a[o];
      t.addGroup(c.start, c.count, c.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const l = this.parameters;
      for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const n = this.attributes;
    for (const l in n) {
      const c = n[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const r = {};
    let s = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l],
        u = [];
      for (let h = 0, f = c.length; h < f; h++) {
        const m = c[h];
        u.push(m.toJSON(e.data));
      }
      u.length > 0 && ((r[l] = u), (s = !0));
    }
    s &&
      ((e.data.morphAttributes = r),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const a = this.groups;
    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
    const o = this.boundingSphere;
    return (
      o !== null &&
        (e.data.boundingSphere = {
          center: o.center.toArray(),
          radius: o.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(t));
    const r = e.attributes;
    for (const c in r) {
      const u = r[c];
      this.setAttribute(c, u.clone(t));
    }
    const s = e.morphAttributes;
    for (const c in s) {
      const u = [],
        h = s[c];
      for (let f = 0, m = h.length; f < m; f++) u.push(h[f].clone(t));
      this.morphAttributes[c] = u;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const a = e.groups;
    for (let c = 0, u = a.length; c < u; c++) {
      const h = a[c];
      this.addGroup(h.start, h.count, h.materialIndex);
    }
    const o = e.boundingBox;
    o !== null && (this.boundingBox = o.clone());
    const l = e.boundingSphere;
    return (
      l !== null && (this.boundingSphere = l.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const Fu = new Tt(),
  hi = new hh(),
  os = new Fa(),
  Bu = new W(),
  cs = new W(),
  ls = new W(),
  us = new W(),
  go = new W(),
  fs = new W(),
  Lu = new W(),
  hs = new W();
class Vn extends Yt {
  constructor(e = new bn(), t = new mh()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary,
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      n = Object.keys(t);
    if (n.length > 0) {
      const r = t[n[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, a = r.length; s < a; s++) {
          const o = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[o] = s);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const n = this.geometry,
      r = n.attributes.position,
      s = n.morphAttributes.position,
      a = n.morphTargetsRelative;
    t.fromBufferAttribute(r, e);
    const o = this.morphTargetInfluences;
    if (s && o) {
      fs.set(0, 0, 0);
      for (let l = 0, c = s.length; l < c; l++) {
        const u = o[l],
          h = s[l];
        u !== 0 &&
          (go.fromBufferAttribute(h, e),
          a ? fs.addScaledVector(go, u) : fs.addScaledVector(go.sub(t), u));
      }
      t.add(fs);
    }
    return t;
  }
  raycast(e, t) {
    const n = this.geometry,
      r = this.material,
      s = this.matrixWorld;
    r !== void 0 &&
      (n.boundingSphere === null && n.computeBoundingSphere(),
      os.copy(n.boundingSphere),
      os.applyMatrix4(s),
      hi.copy(e.ray).recast(e.near),
      !(
        os.containsPoint(hi.origin) === !1 &&
        (hi.intersectSphere(os, Bu) === null ||
          hi.origin.distanceToSquared(Bu) > (e.far - e.near) ** 2)
      ) &&
        (Fu.copy(s).invert(),
        hi.copy(e.ray).applyMatrix4(Fu),
        !(n.boundingBox !== null && hi.intersectsBox(n.boundingBox) === !1) &&
          this._computeIntersections(e, t, hi)));
  }
  _computeIntersections(e, t, n) {
    let r;
    const s = this.geometry,
      a = this.material,
      o = s.index,
      l = s.attributes.position,
      c = s.attributes.uv,
      u = s.attributes.uv1,
      h = s.attributes.normal,
      f = s.groups,
      m = s.drawRange;
    if (o !== null)
      if (Array.isArray(a))
        for (let x = 0, g = f.length; x < g; x++) {
          const d = f[x],
            p = a[d.materialIndex],
            y = Math.max(d.start, m.start),
            E = Math.min(
              o.count,
              Math.min(d.start + d.count, m.start + m.count),
            );
          for (let v = y, C = E; v < C; v += 3) {
            const A = o.getX(v),
              S = o.getX(v + 1),
              R = o.getX(v + 2);
            (r = ds(this, p, e, n, c, u, h, A, S, R)),
              r &&
                ((r.faceIndex = Math.floor(v / 3)),
                (r.face.materialIndex = d.materialIndex),
                t.push(r));
          }
        }
      else {
        const x = Math.max(0, m.start),
          g = Math.min(o.count, m.start + m.count);
        for (let d = x, p = g; d < p; d += 3) {
          const y = o.getX(d),
            E = o.getX(d + 1),
            v = o.getX(d + 2);
          (r = ds(this, a, e, n, c, u, h, y, E, v)),
            r && ((r.faceIndex = Math.floor(d / 3)), t.push(r));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(a))
        for (let x = 0, g = f.length; x < g; x++) {
          const d = f[x],
            p = a[d.materialIndex],
            y = Math.max(d.start, m.start),
            E = Math.min(
              l.count,
              Math.min(d.start + d.count, m.start + m.count),
            );
          for (let v = y, C = E; v < C; v += 3) {
            const A = v,
              S = v + 1,
              R = v + 2;
            (r = ds(this, p, e, n, c, u, h, A, S, R)),
              r &&
                ((r.faceIndex = Math.floor(v / 3)),
                (r.face.materialIndex = d.materialIndex),
                t.push(r));
          }
        }
      else {
        const x = Math.max(0, m.start),
          g = Math.min(l.count, m.start + m.count);
        for (let d = x, p = g; d < p; d += 3) {
          const y = d,
            E = d + 1,
            v = d + 2;
          (r = ds(this, a, e, n, c, u, h, y, E, v)),
            r && ((r.faceIndex = Math.floor(d / 3)), t.push(r));
        }
      }
  }
}
function zm(i, e, t, n, r, s, a, o) {
  let l;
  if (
    (e.side === Qt
      ? (l = n.intersectTriangle(a, s, r, !0, o))
      : (l = n.intersectTriangle(r, s, a, e.side === si, o)),
    l === null)
  )
    return null;
  hs.copy(o), hs.applyMatrix4(i.matrixWorld);
  const c = t.ray.origin.distanceTo(hs);
  return c < t.near || c > t.far
    ? null
    : { distance: c, point: hs.clone(), object: i };
}
function ds(i, e, t, n, r, s, a, o, l, c) {
  i.getVertexPosition(o, cs),
    i.getVertexPosition(l, ls),
    i.getVertexPosition(c, us);
  const u = zm(i, e, t, n, cs, ls, us, Lu);
  if (u) {
    const h = new W();
    mn.getBarycoord(Lu, cs, ls, us, h),
      r && (u.uv = mn.getInterpolatedAttribute(r, o, l, c, h, new it())),
      s && (u.uv1 = mn.getInterpolatedAttribute(s, o, l, c, h, new it())),
      a &&
        ((u.normal = mn.getInterpolatedAttribute(a, o, l, c, h, new W())),
        u.normal.dot(n.direction) > 0 && u.normal.multiplyScalar(-1));
    const f = { a: o, b: l, c, normal: new W(), materialIndex: 0 };
    mn.getNormal(cs, ls, us, f.normal), (u.face = f), (u.barycoord = h);
  }
  return u;
}
class Xr extends bn {
  constructor(e = 1, t = 1, n = 1, r = 1, s = 1, a = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: n,
        widthSegments: r,
        heightSegments: s,
        depthSegments: a,
      });
    const o = this;
    (r = Math.floor(r)), (s = Math.floor(s)), (a = Math.floor(a));
    const l = [],
      c = [],
      u = [],
      h = [];
    let f = 0,
      m = 0;
    x("z", "y", "x", -1, -1, n, t, e, a, s, 0),
      x("z", "y", "x", 1, -1, n, t, -e, a, s, 1),
      x("x", "z", "y", 1, 1, e, n, t, r, a, 2),
      x("x", "z", "y", 1, -1, e, n, -t, r, a, 3),
      x("x", "y", "z", 1, -1, e, t, n, r, s, 4),
      x("x", "y", "z", -1, -1, e, t, -n, r, s, 5),
      this.setIndex(l),
      this.setAttribute("position", new cn(c, 3)),
      this.setAttribute("normal", new cn(u, 3)),
      this.setAttribute("uv", new cn(h, 2));
    function x(g, d, p, y, E, v, C, A, S, R, M) {
      const _ = v / S,
        T = C / R,
        F = v / 2,
        P = C / 2,
        I = A / 2,
        X = S + 1,
        V = R + 1;
      let ie = 0,
        k = 0;
      const ae = new W();
      for (let ce = 0; ce < V; ce++) {
        const H = ce * T - P;
        for (let K = 0; K < X; K++) {
          const Q = K * _ - F;
          (ae[g] = Q * y),
            (ae[d] = H * E),
            (ae[p] = I),
            c.push(ae.x, ae.y, ae.z),
            (ae[g] = 0),
            (ae[d] = 0),
            (ae[p] = A > 0 ? 1 : -1),
            u.push(ae.x, ae.y, ae.z),
            h.push(K / S),
            h.push(1 - ce / R),
            (ie += 1);
        }
      }
      for (let ce = 0; ce < R; ce++)
        for (let H = 0; H < S; H++) {
          const K = f + H + X * ce,
            Q = f + H + X * (ce + 1),
            B = f + (H + 1) + X * (ce + 1),
            te = f + (H + 1) + X * ce;
          l.push(K, Q, te), l.push(Q, B, te), (k += 6);
        }
      o.addGroup(m, k, M), (m += k), (f += ie);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Xr(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments,
    );
  }
}
function pr(i) {
  const e = {};
  for (const t in i) {
    e[t] = {};
    for (const n in i[t]) {
      const r = i[t][n];
      r &&
      (r.isColor ||
        r.isMatrix3 ||
        r.isMatrix4 ||
        r.isVector2 ||
        r.isVector3 ||
        r.isVector4 ||
        r.isTexture ||
        r.isQuaternion)
        ? r.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().",
            ),
            (e[t][n] = null))
          : (e[t][n] = r.clone())
        : Array.isArray(r)
          ? (e[t][n] = r.slice())
          : (e[t][n] = r);
    }
  }
  return e;
}
function Kt(i) {
  const e = {};
  for (let t = 0; t < i.length; t++) {
    const n = pr(i[t]);
    for (const r in n) e[r] = n[r];
  }
  return e;
}
function km(i) {
  const e = [];
  for (let t = 0; t < i.length; t++) e.push(i[t].clone());
  return e;
}
function _h(i) {
  const e = i.getRenderTarget();
  return e === null
    ? i.outputColorSpace
    : e.isXRRenderTarget === !0
      ? e.texture.colorSpace
      : pt.workingColorSpace;
}
const Hm = { clone: pr, merge: Kt };
var Vm = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  Gm = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class ai extends Fi {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = Vm),
      (this.fragmentShader = Gm),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = pr(e.uniforms)),
      (this.uniformsGroups = km(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const r in this.uniforms) {
      const a = this.uniforms[r].value;
      a && a.isTexture
        ? (t.uniforms[r] = { type: "t", value: a.toJSON(e).uuid })
        : a && a.isColor
          ? (t.uniforms[r] = { type: "c", value: a.getHex() })
          : a && a.isVector2
            ? (t.uniforms[r] = { type: "v2", value: a.toArray() })
            : a && a.isVector3
              ? (t.uniforms[r] = { type: "v3", value: a.toArray() })
              : a && a.isVector4
                ? (t.uniforms[r] = { type: "v4", value: a.toArray() })
                : a && a.isMatrix3
                  ? (t.uniforms[r] = { type: "m3", value: a.toArray() })
                  : a && a.isMatrix4
                    ? (t.uniforms[r] = { type: "m4", value: a.toArray() })
                    : (t.uniforms[r] = { value: a });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping);
    const n = {};
    for (const r in this.extensions) this.extensions[r] === !0 && (n[r] = !0);
    return Object.keys(n).length > 0 && (t.extensions = n), t;
  }
}
class vh extends Yt {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new Tt()),
      (this.projectionMatrix = new Tt()),
      (this.projectionMatrixInverse = new Tt()),
      (this.coordinateSystem = Hn);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Zn = new W(),
  Uu = new it(),
  Iu = new it();
class dn extends vh {
  constructor(e = 50, t = 1, n = 0.1, r = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = n),
      (this.far = r),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = Tc * 2 * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(Ka * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return Tc * 2 * Math.atan(Math.tan(Ka * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(e, t, n) {
    Zn.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      t.set(Zn.x, Zn.y).multiplyScalar(-e / Zn.z),
      Zn.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      n.set(Zn.x, Zn.y).multiplyScalar(-e / Zn.z);
  }
  getViewSize(e, t) {
    return this.getViewBounds(e, Uu, Iu), t.subVectors(Iu, Uu);
  }
  setViewOffset(e, t, n, r, s, a) {
    (this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = n),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = a),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(Ka * 0.5 * this.fov)) / this.zoom,
      n = 2 * t,
      r = this.aspect * n,
      s = -0.5 * r;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = a.fullWidth,
        c = a.fullHeight;
      (s += (a.offsetX * r) / l),
        (t -= (a.offsetY * n) / c),
        (r *= a.width / l),
        (n *= a.height / c);
    }
    const o = this.filmOffset;
    o !== 0 && (s += (e * o) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        s,
        s + r,
        t,
        t - n,
        e,
        this.far,
        this.coordinateSystem,
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const Yi = -90,
  $i = 1;
class Wm extends Yt {
  constructor(e, t, n) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = n),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0);
    const r = new dn(Yi, $i, e, t);
    (r.layers = this.layers), this.add(r);
    const s = new dn(Yi, $i, e, t);
    (s.layers = this.layers), this.add(s);
    const a = new dn(Yi, $i, e, t);
    (a.layers = this.layers), this.add(a);
    const o = new dn(Yi, $i, e, t);
    (o.layers = this.layers), this.add(o);
    const l = new dn(Yi, $i, e, t);
    (l.layers = this.layers), this.add(l);
    const c = new dn(Yi, $i, e, t);
    (c.layers = this.layers), this.add(c);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      t = this.children.concat(),
      [n, r, s, a, o, l] = t;
    for (const c of t) this.remove(c);
    if (e === Hn)
      n.up.set(0, 1, 0),
        n.lookAt(1, 0, 0),
        r.up.set(0, 1, 0),
        r.lookAt(-1, 0, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, 1, 0),
        a.up.set(0, 0, 1),
        a.lookAt(0, -1, 0),
        o.up.set(0, 1, 0),
        o.lookAt(0, 0, 1),
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, -1);
    else if (e === Ta)
      n.up.set(0, -1, 0),
        n.lookAt(-1, 0, 0),
        r.up.set(0, -1, 0),
        r.lookAt(1, 0, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, 1, 0),
        a.up.set(0, 0, -1),
        a.lookAt(0, -1, 0),
        o.up.set(0, -1, 0),
        o.lookAt(0, 0, 1),
        l.up.set(0, -1, 0),
        l.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e,
      );
    for (const c of t) this.add(c), c.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: n, activeMipmapLevel: r } = this;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [s, a, o, l, c, u] = this.children,
      h = e.getRenderTarget(),
      f = e.getActiveCubeFace(),
      m = e.getActiveMipmapLevel(),
      x = e.xr.enabled;
    e.xr.enabled = !1;
    const g = n.texture.generateMipmaps;
    (n.texture.generateMipmaps = !1),
      e.setRenderTarget(n, 0, r),
      e.render(t, s),
      e.setRenderTarget(n, 1, r),
      e.render(t, a),
      e.setRenderTarget(n, 2, r),
      e.render(t, o),
      e.setRenderTarget(n, 3, r),
      e.render(t, l),
      e.setRenderTarget(n, 4, r),
      e.render(t, c),
      (n.texture.generateMipmaps = g),
      e.setRenderTarget(n, 5, r),
      e.render(t, u),
      e.setRenderTarget(h, f, m),
      (e.xr.enabled = x),
      (n.texture.needsPMREMUpdate = !0);
  }
}
class Eh extends qt {
  constructor(e, t, n, r, s, a, o, l, c, u) {
    (e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : lr),
      super(e, t, n, r, s, a, o, l, c, u),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class Xm extends Ci {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    const n = { width: e, height: e, depth: 1 },
      r = [n, n, n, n, n, n];
    (this.texture = new Eh(
      r,
      t.mapping,
      t.wrapS,
      t.wrapT,
      t.magFilter,
      t.minFilter,
      t.format,
      t.type,
      t.anisotropy,
      t.colorSpace,
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Dn);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const n = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      r = new Xr(5, 5, 5),
      s = new ai({
        name: "CubemapFromEquirect",
        uniforms: pr(n.uniforms),
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        side: Qt,
        blending: ti,
      });
    s.uniforms.tEquirect.value = t;
    const a = new Vn(r, s),
      o = t.minFilter;
    return (
      t.minFilter === Mi && (t.minFilter = Dn),
      new Wm(1, 10, this).update(e, a),
      (t.minFilter = o),
      a.geometry.dispose(),
      a.material.dispose(),
      this
    );
  }
  clear(e, t, n, r) {
    const s = e.getRenderTarget();
    for (let a = 0; a < 6; a++) e.setRenderTarget(this, a), e.clear(t, n, r);
    e.setRenderTarget(s);
  }
}
class ps extends Yt {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const qm = { type: "move" };
class _o {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new ps()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new ps()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new W()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new W())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new ps()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new W()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new W())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const n of e.hand.values()) this._getHandJoint(t, n);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, n) {
    let r = null,
      s = null,
      a = null;
    const o = this._targetRay,
      l = this._grip,
      c = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        a = !0;
        for (const g of e.hand.values()) {
          const d = t.getJointPose(g, n),
            p = this._getHandJoint(c, g);
          d !== null &&
            (p.matrix.fromArray(d.transform.matrix),
            p.matrix.decompose(p.position, p.rotation, p.scale),
            (p.matrixWorldNeedsUpdate = !0),
            (p.jointRadius = d.radius)),
            (p.visible = d !== null);
        }
        const u = c.joints["index-finger-tip"],
          h = c.joints["thumb-tip"],
          f = u.position.distanceTo(h.position),
          m = 0.02,
          x = 0.005;
        c.inputState.pinching && f > m + x
          ? ((c.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !c.inputState.pinching &&
            f <= m - x &&
            ((c.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        l !== null &&
          e.gripSpace &&
          ((s = t.getPose(e.gripSpace, n)),
          s !== null &&
            (l.matrix.fromArray(s.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            (l.matrixWorldNeedsUpdate = !0),
            s.linearVelocity
              ? ((l.hasLinearVelocity = !0),
                l.linearVelocity.copy(s.linearVelocity))
              : (l.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((l.hasAngularVelocity = !0),
                l.angularVelocity.copy(s.angularVelocity))
              : (l.hasAngularVelocity = !1)));
      o !== null &&
        ((r = t.getPose(e.targetRaySpace, n)),
        r === null && s !== null && (r = s),
        r !== null &&
          (o.matrix.fromArray(r.transform.matrix),
          o.matrix.decompose(o.position, o.rotation, o.scale),
          (o.matrixWorldNeedsUpdate = !0),
          r.linearVelocity
            ? ((o.hasLinearVelocity = !0),
              o.linearVelocity.copy(r.linearVelocity))
            : (o.hasLinearVelocity = !1),
          r.angularVelocity
            ? ((o.hasAngularVelocity = !0),
              o.angularVelocity.copy(r.angularVelocity))
            : (o.hasAngularVelocity = !1),
          this.dispatchEvent(qm)));
    }
    return (
      o !== null && (o.visible = r !== null),
      l !== null && (l.visible = s !== null),
      c !== null && (c.visible = a !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const n = new ps();
      (n.matrixAutoUpdate = !1),
        (n.visible = !1),
        (e.joints[t.jointName] = n),
        e.add(n);
    }
    return e.joints[t.jointName];
  }
}
class pS extends Yt {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.backgroundRotation = new Pn()),
      (this.environmentIntensity = 1),
      (this.environmentRotation = new Pn()),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ != "undefined" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this }),
        );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      this.backgroundRotation.copy(e.backgroundRotation),
      (this.environmentIntensity = e.environmentIntensity),
      this.environmentRotation.copy(e.environmentRotation),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      (t.object.backgroundRotation = this.backgroundRotation.toArray()),
      this.environmentIntensity !== 1 &&
        (t.object.environmentIntensity = this.environmentIntensity),
      (t.object.environmentRotation = this.environmentRotation.toArray()),
      t
    );
  }
}
class Ym {
  constructor(e, t) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = bc),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = ii());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, n) {
    (e *= this.stride), (n *= t.stride);
    for (let r = 0, s = this.stride; r < s; r++)
      this.array[e + r] = t.array[n + r];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ii()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid],
      ),
      n = new this.constructor(t, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ii()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer),
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const jt = new W();
class Ca {
  constructor(e, t, n, r = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = n),
      (this.normalized = r);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.data.count; t < n; t++)
      jt.fromBufferAttribute(this, t),
        jt.applyMatrix4(e),
        this.setXYZ(t, jt.x, jt.y, jt.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      jt.fromBufferAttribute(this, t),
        jt.applyNormalMatrix(e),
        this.setXYZ(t, jt.x, jt.y, jt.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      jt.fromBufferAttribute(this, t),
        jt.transformDirection(e),
        this.setXYZ(t, jt.x, jt.y, jt.z);
    return this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (n = Rn(n, this.array)), n;
  }
  setComponent(e, t, n) {
    return (
      this.normalized && (n = Et(n, this.array)),
      (this.data.array[e * this.data.stride + this.offset + t] = n),
      this
    );
  }
  setX(e, t) {
    return (
      this.normalized && (t = Et(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = Et(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Et(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = Et(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = Rn(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = Rn(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = Rn(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = Rn(t, this.array)), t;
  }
  setXY(e, t, n) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = Et(t, this.array)), (n = Et(n, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      this
    );
  }
  setXYZ(e, t, n, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = Et(t, this.array)),
        (n = Et(n, this.array)),
        (r = Et(r, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      (this.data.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, t, n, r, s) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = Et(t, this.array)),
        (n = Et(n, this.array)),
        (r = Et(r, this.array)),
        (s = Et(s, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      (this.data.array[e + 2] = r),
      (this.data.array[e + 3] = s),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.",
      );
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const r = n * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
      }
      return new An(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized,
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new Ca(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized,
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.",
      );
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const r = n * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
class $m extends Fi {
  constructor(e) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.type = "SpriteMaterial"),
      (this.color = new ut(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
let ji;
const wr = new W(),
  Ki = new W(),
  Zi = new W(),
  Ji = new it(),
  Rr = new it(),
  yh = new Tt(),
  ms = new W(),
  Dr = new W(),
  xs = new W(),
  Nu = new it(),
  vo = new it(),
  Ou = new it();
class mS extends Yt {
  constructor(e = new $m()) {
    if (
      (super(), (this.isSprite = !0), (this.type = "Sprite"), ji === void 0)
    ) {
      ji = new bn();
      const t = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        n = new Ym(t, 5);
      ji.setIndex([0, 1, 2, 0, 2, 3]),
        ji.setAttribute("position", new Ca(n, 3, 0, !1)),
        ji.setAttribute("uv", new Ca(n, 2, 3, !1));
    }
    (this.geometry = ji), (this.material = e), (this.center = new it(0.5, 0.5));
  }
  raycast(e, t) {
    e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.',
      ),
      Ki.setFromMatrixScale(this.matrixWorld),
      yh.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld,
      ),
      Zi.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        Ki.multiplyScalar(-Zi.z);
    const n = this.material.rotation;
    let r, s;
    n !== 0 && ((s = Math.cos(n)), (r = Math.sin(n)));
    const a = this.center;
    gs(ms.set(-0.5, -0.5, 0), Zi, a, Ki, r, s),
      gs(Dr.set(0.5, -0.5, 0), Zi, a, Ki, r, s),
      gs(xs.set(0.5, 0.5, 0), Zi, a, Ki, r, s),
      Nu.set(0, 0),
      vo.set(1, 0),
      Ou.set(1, 1);
    let o = e.ray.intersectTriangle(ms, Dr, xs, !1, wr);
    if (
      o === null &&
      (gs(Dr.set(-0.5, 0.5, 0), Zi, a, Ki, r, s),
      vo.set(0, 1),
      (o = e.ray.intersectTriangle(ms, xs, Dr, !1, wr)),
      o === null)
    )
      return;
    const l = e.ray.origin.distanceTo(wr);
    l < e.near ||
      l > e.far ||
      t.push({
        distance: l,
        point: wr.clone(),
        uv: mn.getInterpolation(wr, ms, Dr, xs, Nu, vo, Ou, new it()),
        face: null,
        object: this,
      });
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    );
  }
}
function gs(i, e, t, n, r, s) {
  Ji.subVectors(i, t).addScalar(0.5).multiply(n),
    r !== void 0
      ? ((Rr.x = s * Ji.x - r * Ji.y), (Rr.y = r * Ji.x + s * Ji.y))
      : Rr.copy(Ji),
    i.copy(e),
    (i.x += Rr.x),
    (i.y += Rr.y),
    i.applyMatrix4(yh);
}
const Eo = new W(),
  jm = new W(),
  Km = new Ze();
class xi {
  constructor(e = new W(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, n, r) {
    return this.normal.set(e, t, n), (this.constant = r), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, n) {
    const r = Eo.subVectors(n, t).cross(jm.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const n = e.delta(Eo),
      r = this.normal.dot(n);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / r;
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(n, s);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      n = this.distanceToPoint(e.end);
    return (t < 0 && n > 0) || (n < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const n = t || Km.getNormalMatrix(e),
      r = this.coplanarPoint(Eo).applyMatrix4(e),
      s = this.normal.applyMatrix3(n).normalize();
    return (this.constant = -r.dot(s)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const di = new Fa(),
  _s = new W();
class Jc {
  constructor(
    e = new xi(),
    t = new xi(),
    n = new xi(),
    r = new xi(),
    s = new xi(),
    a = new xi(),
  ) {
    this.planes = [e, t, n, r, s, a];
  }
  set(e, t, n, r, s, a) {
    const o = this.planes;
    return (
      o[0].copy(e),
      o[1].copy(t),
      o[2].copy(n),
      o[3].copy(r),
      o[4].copy(s),
      o[5].copy(a),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e, t = Hn) {
    const n = this.planes,
      r = e.elements,
      s = r[0],
      a = r[1],
      o = r[2],
      l = r[3],
      c = r[4],
      u = r[5],
      h = r[6],
      f = r[7],
      m = r[8],
      x = r[9],
      g = r[10],
      d = r[11],
      p = r[12],
      y = r[13],
      E = r[14],
      v = r[15];
    if (
      (n[0].setComponents(l - s, f - c, d - m, v - p).normalize(),
      n[1].setComponents(l + s, f + c, d + m, v + p).normalize(),
      n[2].setComponents(l + a, f + u, d + x, v + y).normalize(),
      n[3].setComponents(l - a, f - u, d - x, v - y).normalize(),
      n[4].setComponents(l - o, f - h, d - g, v - E).normalize(),
      t === Hn)
    )
      n[5].setComponents(l + o, f + h, d + g, v + E).normalize();
    else if (t === Ta) n[5].setComponents(o, h, g, E).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          t,
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        di.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(),
        di.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(di);
  }
  intersectsSprite(e) {
    return (
      di.center.set(0, 0, 0),
      (di.radius = 0.7071067811865476),
      di.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(di)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      n = e.center,
      r = -e.radius;
    for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(n) < r) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const r = t[n];
      if (
        ((_s.x = r.normal.x > 0 ? e.max.x : e.min.x),
        (_s.y = r.normal.y > 0 ? e.max.y : e.min.y),
        (_s.z = r.normal.z > 0 ? e.max.z : e.min.z),
        r.distanceToPoint(_s) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Zm extends Fi {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new ut(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const zu = new Tt(),
  Cc = new hh(),
  vs = new Fa(),
  Es = new W();
class xS extends Yt {
  constructor(e = new bn(), t = new Zm()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const n = this.geometry,
      r = this.matrixWorld,
      s = e.params.Points.threshold,
      a = n.drawRange;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      vs.copy(n.boundingSphere),
      vs.applyMatrix4(r),
      (vs.radius += s),
      e.ray.intersectsSphere(vs) === !1)
    )
      return;
    zu.copy(r).invert(), Cc.copy(e.ray).applyMatrix4(zu);
    const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = o * o,
      c = n.index,
      h = n.attributes.position;
    if (c !== null) {
      const f = Math.max(0, a.start),
        m = Math.min(c.count, a.start + a.count);
      for (let x = f, g = m; x < g; x++) {
        const d = c.getX(x);
        Es.fromBufferAttribute(h, d), ku(Es, d, l, r, e, t, this);
      }
    } else {
      const f = Math.max(0, a.start),
        m = Math.min(h.count, a.start + a.count);
      for (let x = f, g = m; x < g; x++)
        Es.fromBufferAttribute(h, x), ku(Es, x, l, r, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      n = Object.keys(t);
    if (n.length > 0) {
      const r = t[n[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, a = r.length; s < a; s++) {
          const o = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[o] = s);
        }
      }
    }
  }
}
function ku(i, e, t, n, r, s, a) {
  const o = Cc.distanceSqToPoint(i);
  if (o < t) {
    const l = new W();
    Cc.closestPointToPoint(i, l), l.applyMatrix4(n);
    const c = r.ray.origin.distanceTo(l);
    if (c < r.near || c > r.far) return;
    s.push({
      distance: c,
      distanceToRay: Math.sqrt(o),
      point: l,
      index: e,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: a,
    });
  }
}
class gS extends qt {
  constructor(e, t, n, r, s, a, o, l, c) {
    super(e, t, n, r, s, a, o, l, c),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0);
  }
}
class Sh extends qt {
  constructor(e, t, n, r, s, a, o, l, c, u = rr) {
    if (u !== rr && u !== hr)
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat",
      );
    n === void 0 && u === rr && (n = Ti),
      n === void 0 && u === hr && (n = fr),
      super(null, r, s, a, o, l, u, n, c),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = o !== void 0 ? o : Mn),
      (this.minFilter = l !== void 0 ? l : Mn),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (t.compareFunction = this.compareFunction),
      t
    );
  }
}
class Qc extends bn {
  constructor(
    e = 1,
    t = 1,
    n = 1,
    r = 32,
    s = 1,
    a = !1,
    o = 0,
    l = Math.PI * 2,
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: n,
        radialSegments: r,
        heightSegments: s,
        openEnded: a,
        thetaStart: o,
        thetaLength: l,
      });
    const c = this;
    (r = Math.floor(r)), (s = Math.floor(s));
    const u = [],
      h = [],
      f = [],
      m = [];
    let x = 0;
    const g = [],
      d = n / 2;
    let p = 0;
    y(),
      a === !1 && (e > 0 && E(!0), t > 0 && E(!1)),
      this.setIndex(u),
      this.setAttribute("position", new cn(h, 3)),
      this.setAttribute("normal", new cn(f, 3)),
      this.setAttribute("uv", new cn(m, 2));
    function y() {
      const v = new W(),
        C = new W();
      let A = 0;
      const S = (t - e) / n;
      for (let R = 0; R <= s; R++) {
        const M = [],
          _ = R / s,
          T = _ * (t - e) + e;
        for (let F = 0; F <= r; F++) {
          const P = F / r,
            I = P * l + o,
            X = Math.sin(I),
            V = Math.cos(I);
          (C.x = T * X),
            (C.y = -_ * n + d),
            (C.z = T * V),
            h.push(C.x, C.y, C.z),
            v.set(X, S, V).normalize(),
            f.push(v.x, v.y, v.z),
            m.push(P, 1 - _),
            M.push(x++);
        }
        g.push(M);
      }
      for (let R = 0; R < r; R++)
        for (let M = 0; M < s; M++) {
          const _ = g[M][R],
            T = g[M + 1][R],
            F = g[M + 1][R + 1],
            P = g[M][R + 1];
          (e > 0 || M !== 0) && (u.push(_, T, P), (A += 3)),
            (t > 0 || M !== s - 1) && (u.push(T, F, P), (A += 3));
        }
      c.addGroup(p, A, 0), (p += A);
    }
    function E(v) {
      const C = x,
        A = new it(),
        S = new W();
      let R = 0;
      const M = v === !0 ? e : t,
        _ = v === !0 ? 1 : -1;
      for (let F = 1; F <= r; F++)
        h.push(0, d * _, 0), f.push(0, _, 0), m.push(0.5, 0.5), x++;
      const T = x;
      for (let F = 0; F <= r; F++) {
        const I = (F / r) * l + o,
          X = Math.cos(I),
          V = Math.sin(I);
        (S.x = M * V),
          (S.y = d * _),
          (S.z = M * X),
          h.push(S.x, S.y, S.z),
          f.push(0, _, 0),
          (A.x = X * 0.5 + 0.5),
          (A.y = V * 0.5 * _ + 0.5),
          m.push(A.x, A.y),
          x++;
      }
      for (let F = 0; F < r; F++) {
        const P = C + F,
          I = T + F;
        v === !0 ? u.push(I, I + 1, P) : u.push(I + 1, I, P), (R += 3);
      }
      c.addGroup(p, R, v === !0 ? 1 : 2), (p += R);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Qc(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength,
    );
  }
}
class Mh extends Qc {
  constructor(e = 1, t = 1, n = 32, r = 1, s = !1, a = 0, o = Math.PI * 2) {
    super(0, e, t, n, r, s, a, o),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        radialSegments: n,
        heightSegments: r,
        openEnded: s,
        thetaStart: a,
        thetaLength: o,
      });
  }
  static fromJSON(e) {
    return new Mh(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength,
    );
  }
}
class Ba extends bn {
  constructor(e = 1, t = 1, n = 1, r = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: n,
        heightSegments: r,
      });
    const s = e / 2,
      a = t / 2,
      o = Math.floor(n),
      l = Math.floor(r),
      c = o + 1,
      u = l + 1,
      h = e / o,
      f = t / l,
      m = [],
      x = [],
      g = [],
      d = [];
    for (let p = 0; p < u; p++) {
      const y = p * f - a;
      for (let E = 0; E < c; E++) {
        const v = E * h - s;
        x.push(v, -y, 0), g.push(0, 0, 1), d.push(E / o), d.push(1 - p / l);
      }
    }
    for (let p = 0; p < l; p++)
      for (let y = 0; y < o; y++) {
        const E = y + c * p,
          v = y + c * (p + 1),
          C = y + 1 + c * (p + 1),
          A = y + 1 + c * p;
        m.push(E, v, A), m.push(v, C, A);
      }
    this.setIndex(m),
      this.setAttribute("position", new cn(x, 3)),
      this.setAttribute("normal", new cn(g, 3)),
      this.setAttribute("uv", new cn(d, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Ba(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
class Ah extends bn {
  constructor(
    e = 1,
    t = 32,
    n = 16,
    r = 0,
    s = Math.PI * 2,
    a = 0,
    o = Math.PI,
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: n,
        phiStart: r,
        phiLength: s,
        thetaStart: a,
        thetaLength: o,
      }),
      (t = Math.max(3, Math.floor(t))),
      (n = Math.max(2, Math.floor(n)));
    const l = Math.min(a + o, Math.PI);
    let c = 0;
    const u = [],
      h = new W(),
      f = new W(),
      m = [],
      x = [],
      g = [],
      d = [];
    for (let p = 0; p <= n; p++) {
      const y = [],
        E = p / n;
      let v = 0;
      p === 0 && a === 0
        ? (v = 0.5 / t)
        : p === n && l === Math.PI && (v = -0.5 / t);
      for (let C = 0; C <= t; C++) {
        const A = C / t;
        (h.x = -e * Math.cos(r + A * s) * Math.sin(a + E * o)),
          (h.y = e * Math.cos(a + E * o)),
          (h.z = e * Math.sin(r + A * s) * Math.sin(a + E * o)),
          x.push(h.x, h.y, h.z),
          f.copy(h).normalize(),
          g.push(f.x, f.y, f.z),
          d.push(A + v, 1 - E),
          y.push(c++);
      }
      u.push(y);
    }
    for (let p = 0; p < n; p++)
      for (let y = 0; y < t; y++) {
        const E = u[p][y + 1],
          v = u[p][y],
          C = u[p + 1][y],
          A = u[p + 1][y + 1];
        (p !== 0 || a > 0) && m.push(E, v, A),
          (p !== n - 1 || l < Math.PI) && m.push(v, C, A);
      }
    this.setIndex(m),
      this.setAttribute("position", new cn(x, 3)),
      this.setAttribute("normal", new cn(g, 3)),
      this.setAttribute("uv", new cn(d, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Ah(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength,
    );
  }
}
class _S extends Fi {
  constructor(e) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new ut(16777215)),
      (this.specular = new ut(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new ut(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = oh),
      (this.normalScale = new it(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Pn()),
      (this.combine = Xc),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class Jm extends Fi {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = cm),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class Qm extends Fi {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const Hu = {
  enabled: !1,
  files: {},
  add: function (i, e) {
    this.enabled !== !1 && (this.files[i] = e);
  },
  get: function (i) {
    if (this.enabled !== !1) return this.files[i];
  },
  remove: function (i) {
    delete this.files[i];
  },
  clear: function () {
    this.files = {};
  },
};
class ex {
  constructor(e, t, n) {
    const r = this;
    let s = !1,
      a = 0,
      o = 0,
      l;
    const c = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = n),
      (this.itemStart = function (u) {
        o++, s === !1 && r.onStart !== void 0 && r.onStart(u, a, o), (s = !0);
      }),
      (this.itemEnd = function (u) {
        a++,
          r.onProgress !== void 0 && r.onProgress(u, a, o),
          a === o && ((s = !1), r.onLoad !== void 0 && r.onLoad());
      }),
      (this.itemError = function (u) {
        r.onError !== void 0 && r.onError(u);
      }),
      (this.resolveURL = function (u) {
        return l ? l(u) : u;
      }),
      (this.setURLModifier = function (u) {
        return (l = u), this;
      }),
      (this.addHandler = function (u, h) {
        return c.push(u, h), this;
      }),
      (this.removeHandler = function (u) {
        const h = c.indexOf(u);
        return h !== -1 && c.splice(h, 2), this;
      }),
      (this.getHandler = function (u) {
        for (let h = 0, f = c.length; h < f; h += 2) {
          const m = c[h],
            x = c[h + 1];
          if ((m.global && (m.lastIndex = 0), m.test(u))) return x;
        }
        return null;
      });
  }
}
const tx = new ex();
class el {
  constructor(e) {
    (this.manager = e !== void 0 ? e : tx),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const n = this;
    return new Promise(function (r, s) {
      n.load(e, r, t, s);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
el.DEFAULT_MATERIAL_NAME = "__DEFAULT";
class nx extends el {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      a = Hu.get(e);
    if (a !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(a), s.manager.itemEnd(e);
        }, 0),
        a
      );
    const o = kr("img");
    function l() {
      u(), Hu.add(e, this), t && t(this), s.manager.itemEnd(e);
    }
    function c(h) {
      u(), r && r(h), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function u() {
      o.removeEventListener("load", l, !1),
        o.removeEventListener("error", c, !1);
    }
    return (
      o.addEventListener("load", l, !1),
      o.addEventListener("error", c, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (o.crossOrigin = this.crossOrigin),
      s.manager.itemStart(e),
      (o.src = e),
      o
    );
  }
}
class vS extends el {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const s = new qt(),
      a = new nx(this.manager);
    return (
      a.setCrossOrigin(this.crossOrigin),
      a.setPath(this.path),
      a.load(
        e,
        function (o) {
          (s.image = o), (s.needsUpdate = !0), t !== void 0 && t(s);
        },
        n,
        r,
      ),
      s
    );
  }
}
class bh extends Yt {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new ut(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      this.target !== void 0 && (t.object.target = this.target.uuid),
      t
    );
  }
}
const yo = new Tt(),
  Vu = new W(),
  Gu = new W();
class ix {
  constructor(e) {
    (this.camera = e),
      (this.intensity = 1),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new it(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new Tt()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Jc()),
      (this._frameExtents = new it(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new yt(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      n = this.matrix;
    Vu.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(Vu),
      Gu.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(Gu),
      t.updateMatrixWorld(),
      yo.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(yo),
      n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      n.multiply(yo);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.intensity = e.intensity),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.intensity !== 1 && (e.intensity = this.intensity),
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
const Wu = new Tt(),
  Pr = new W(),
  So = new W();
class rx extends ix {
  constructor() {
    super(new dn(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new it(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new yt(2, 1, 1, 1),
        new yt(0, 1, 1, 1),
        new yt(3, 1, 1, 1),
        new yt(1, 1, 1, 1),
        new yt(3, 0, 1, 1),
        new yt(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new W(1, 0, 0),
        new W(-1, 0, 0),
        new W(0, 0, 1),
        new W(0, 0, -1),
        new W(0, 1, 0),
        new W(0, -1, 0),
      ]),
      (this._cubeUps = [
        new W(0, 1, 0),
        new W(0, 1, 0),
        new W(0, 1, 0),
        new W(0, 1, 0),
        new W(0, 0, 1),
        new W(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const n = this.camera,
      r = this.matrix,
      s = e.distance || n.far;
    s !== n.far && ((n.far = s), n.updateProjectionMatrix()),
      Pr.setFromMatrixPosition(e.matrixWorld),
      n.position.copy(Pr),
      So.copy(n.position),
      So.add(this._cubeDirections[t]),
      n.up.copy(this._cubeUps[t]),
      n.lookAt(So),
      n.updateMatrixWorld(),
      r.makeTranslation(-Pr.x, -Pr.y, -Pr.z),
      Wu.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(Wu);
  }
}
class ES extends bh {
  constructor(e, t, n = 0, r = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = n),
      (this.decay = r),
      (this.shadow = new rx());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class sx extends vh {
  constructor(e = -1, t = 1, n = 1, r = -1, s = 0.1, a = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = n),
      (this.bottom = r),
      (this.near = s),
      (this.far = a),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, n, r, s, a) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = n),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = a),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      n = (this.right + this.left) / 2,
      r = (this.top + this.bottom) / 2;
    let s = n - e,
      a = n + e,
      o = r + t,
      l = r - t;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
        u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (s += c * this.view.offsetX),
        (a = s + c * this.view.width),
        (o -= u * this.view.offsetY),
        (l = o - u * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      s,
      a,
      o,
      l,
      this.near,
      this.far,
      this.coordinateSystem,
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
class yS extends bh {
  constructor(e, t) {
    super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class ax extends dn {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e), (this.index = 0);
  }
}
function Xu(i, e, t, n) {
  const r = ox(n);
  switch (t) {
    case eh:
      return i * e;
    case nh:
      return i * e;
    case ih:
      return i * e * 2;
    case rh:
      return ((i * e) / r.components) * r.byteLength;
    case jc:
      return ((i * e) / r.components) * r.byteLength;
    case sh:
      return ((i * e * 2) / r.components) * r.byteLength;
    case Kc:
      return ((i * e * 2) / r.components) * r.byteLength;
    case th:
      return ((i * e * 3) / r.components) * r.byteLength;
    case Sn:
      return ((i * e * 4) / r.components) * r.byteLength;
    case Zc:
      return ((i * e * 4) / r.components) * r.byteLength;
    case ua:
    case fa:
      return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case ha:
    case da:
      return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case ec:
    case nc:
      return (Math.max(i, 16) * Math.max(e, 8)) / 4;
    case Qo:
    case tc:
      return (Math.max(i, 8) * Math.max(e, 8)) / 2;
    case ic:
    case rc:
      return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case sc:
      return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case ac:
      return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case oc:
      return Math.floor((i + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case cc:
      return Math.floor((i + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case lc:
      return Math.floor((i + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case uc:
      return Math.floor((i + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case fc:
      return Math.floor((i + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case hc:
      return Math.floor((i + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case dc:
      return Math.floor((i + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case pc:
      return Math.floor((i + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case mc:
      return Math.floor((i + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case xc:
      return Math.floor((i + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case gc:
      return Math.floor((i + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case _c:
      return Math.floor((i + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case vc:
      return Math.floor((i + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case pa:
    case Ec:
    case yc:
      return Math.ceil(i / 4) * Math.ceil(e / 4) * 16;
    case ah:
    case Sc:
      return Math.ceil(i / 4) * Math.ceil(e / 4) * 8;
    case Mc:
    case Ac:
      return Math.ceil(i / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(`Unable to determine texture byte length for ${t} format.`);
}
function ox(i) {
  switch (i) {
    case Wn:
    case Zf:
      return { byteLength: 1, components: 1 };
    case zr:
    case Jf:
    case Vr:
      return { byteLength: 2, components: 1 };
    case Yc:
    case $c:
      return { byteLength: 2, components: 4 };
    case Ti:
    case qc:
    case kn:
      return { byteLength: 4, components: 1 };
    case Qf:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${i}.`);
}
typeof __THREE_DEVTOOLS__ != "undefined" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: Wc } }),
  );
typeof window != "undefined" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = Wc));
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ function Th() {
  let i = null,
    e = !1,
    t = null,
    n = null;
  function r(s, a) {
    t(s, a), (n = i.requestAnimationFrame(r));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((n = i.requestAnimationFrame(r)), (e = !0));
    },
    stop: function () {
      i.cancelAnimationFrame(n), (e = !1);
    },
    setAnimationLoop: function (s) {
      t = s;
    },
    setContext: function (s) {
      i = s;
    },
  };
}
function cx(i) {
  const e = new WeakMap();
  function t(o, l) {
    const c = o.array,
      u = o.usage,
      h = c.byteLength,
      f = i.createBuffer();
    i.bindBuffer(l, f), i.bufferData(l, c, u), o.onUploadCallback();
    let m;
    if (c instanceof Float32Array) m = i.FLOAT;
    else if (c instanceof Uint16Array)
      o.isFloat16BufferAttribute ? (m = i.HALF_FLOAT) : (m = i.UNSIGNED_SHORT);
    else if (c instanceof Int16Array) m = i.SHORT;
    else if (c instanceof Uint32Array) m = i.UNSIGNED_INT;
    else if (c instanceof Int32Array) m = i.INT;
    else if (c instanceof Int8Array) m = i.BYTE;
    else if (c instanceof Uint8Array) m = i.UNSIGNED_BYTE;
    else if (c instanceof Uint8ClampedArray) m = i.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + c,
      );
    return {
      buffer: f,
      type: m,
      bytesPerElement: c.BYTES_PER_ELEMENT,
      version: o.version,
      size: h,
    };
  }
  function n(o, l, c) {
    const u = l.array,
      h = l.updateRanges;
    if ((i.bindBuffer(c, o), h.length === 0)) i.bufferSubData(c, 0, u);
    else {
      h.sort((m, x) => m.start - x.start);
      let f = 0;
      for (let m = 1; m < h.length; m++) {
        const x = h[f],
          g = h[m];
        g.start <= x.start + x.count + 1
          ? (x.count = Math.max(x.count, g.start + g.count - x.start))
          : (++f, (h[f] = g));
      }
      h.length = f + 1;
      for (let m = 0, x = h.length; m < x; m++) {
        const g = h[m];
        i.bufferSubData(c, g.start * u.BYTES_PER_ELEMENT, u, g.start, g.count);
      }
      l.clearUpdateRanges();
    }
    l.onUploadCallback();
  }
  function r(o) {
    return o.isInterleavedBufferAttribute && (o = o.data), e.get(o);
  }
  function s(o) {
    o.isInterleavedBufferAttribute && (o = o.data);
    const l = e.get(o);
    l && (i.deleteBuffer(l.buffer), e.delete(o));
  }
  function a(o, l) {
    if (
      (o.isInterleavedBufferAttribute && (o = o.data), o.isGLBufferAttribute)
    ) {
      const u = e.get(o);
      (!u || u.version < o.version) &&
        e.set(o, {
          buffer: o.buffer,
          type: o.type,
          bytesPerElement: o.elementSize,
          version: o.version,
        });
      return;
    }
    const c = e.get(o);
    if (c === void 0) e.set(o, t(o, l));
    else if (c.version < o.version) {
      if (c.size !== o.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.",
        );
      n(c.buffer, o, l), (c.version = o.version);
    }
  }
  return { get: r, remove: s, update: a };
}
var lx = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  ux = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  fx = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  hx = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  dx = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
  px = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  mx = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  xx = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  gx = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
  _x = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
  vx = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  Ex = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  yx = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  Sx = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  Mx = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  Ax = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
  bx = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  Tx = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  Cx = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  wx = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  Rx = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  Dx = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
  Px = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
  Fx = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  Bx = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  Lx = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  Ux = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  Ix = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  Nx = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  Ox = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  zx = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  kx = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  Hx = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  Vx = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  Gx = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  Wx = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  Xx = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  qx = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  Yx = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  $x = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  jx = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  Kx = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  Zx = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  Jx = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  Qx = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  eg = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  tg = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  ng = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  ig = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  rg = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  sg = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  ag = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  og = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  cg = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  lg = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  ug = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  fg = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  hg = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  dg = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  pg = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
  mg = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  xg = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  gg = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  _g = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  vg = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  Eg = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  yg = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
  Sg = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  Mg = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  Ag = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
  bg = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  Tg = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  Cg = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  wg = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  Rg = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  Dg = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  Pg = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  Fg = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  Bg = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  Lg = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  Ug = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  Ig = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  Ng = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  Og = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  zg = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  kg = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  Hg = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  Vg = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  Gg = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  Wg = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
  Xg = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  qg = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  Yg = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  $g = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  jg = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  Kg = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  Zg = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  Jg = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  Qg = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  e_ = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  t_ = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  n_ = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  i_ = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  r_ = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  s_ = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  a_ = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  o_ = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const c_ = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  l_ = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  u_ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  f_ = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  h_ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  d_ = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  p_ = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  m_ = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
  x_ = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  g_ = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  __ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  v_ = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  E_ = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  y_ = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  S_ = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  M_ = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  A_ = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  b_ = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  T_ = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  C_ = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  w_ = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  R_ = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  D_ = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  P_ = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  F_ = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  B_ = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  L_ = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  U_ = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  I_ = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  N_ = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  O_ = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  z_ = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  k_ = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  H_ = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  Je = {
    alphahash_fragment: lx,
    alphahash_pars_fragment: ux,
    alphamap_fragment: fx,
    alphamap_pars_fragment: hx,
    alphatest_fragment: dx,
    alphatest_pars_fragment: px,
    aomap_fragment: mx,
    aomap_pars_fragment: xx,
    batching_pars_vertex: gx,
    batching_vertex: _x,
    begin_vertex: vx,
    beginnormal_vertex: Ex,
    bsdfs: yx,
    iridescence_fragment: Sx,
    bumpmap_pars_fragment: Mx,
    clipping_planes_fragment: Ax,
    clipping_planes_pars_fragment: bx,
    clipping_planes_pars_vertex: Tx,
    clipping_planes_vertex: Cx,
    color_fragment: wx,
    color_pars_fragment: Rx,
    color_pars_vertex: Dx,
    color_vertex: Px,
    common: Fx,
    cube_uv_reflection_fragment: Bx,
    defaultnormal_vertex: Lx,
    displacementmap_pars_vertex: Ux,
    displacementmap_vertex: Ix,
    emissivemap_fragment: Nx,
    emissivemap_pars_fragment: Ox,
    colorspace_fragment: zx,
    colorspace_pars_fragment: kx,
    envmap_fragment: Hx,
    envmap_common_pars_fragment: Vx,
    envmap_pars_fragment: Gx,
    envmap_pars_vertex: Wx,
    envmap_physical_pars_fragment: tg,
    envmap_vertex: Xx,
    fog_vertex: qx,
    fog_pars_vertex: Yx,
    fog_fragment: $x,
    fog_pars_fragment: jx,
    gradientmap_pars_fragment: Kx,
    lightmap_pars_fragment: Zx,
    lights_lambert_fragment: Jx,
    lights_lambert_pars_fragment: Qx,
    lights_pars_begin: eg,
    lights_toon_fragment: ng,
    lights_toon_pars_fragment: ig,
    lights_phong_fragment: rg,
    lights_phong_pars_fragment: sg,
    lights_physical_fragment: ag,
    lights_physical_pars_fragment: og,
    lights_fragment_begin: cg,
    lights_fragment_maps: lg,
    lights_fragment_end: ug,
    logdepthbuf_fragment: fg,
    logdepthbuf_pars_fragment: hg,
    logdepthbuf_pars_vertex: dg,
    logdepthbuf_vertex: pg,
    map_fragment: mg,
    map_pars_fragment: xg,
    map_particle_fragment: gg,
    map_particle_pars_fragment: _g,
    metalnessmap_fragment: vg,
    metalnessmap_pars_fragment: Eg,
    morphinstance_vertex: yg,
    morphcolor_vertex: Sg,
    morphnormal_vertex: Mg,
    morphtarget_pars_vertex: Ag,
    morphtarget_vertex: bg,
    normal_fragment_begin: Tg,
    normal_fragment_maps: Cg,
    normal_pars_fragment: wg,
    normal_pars_vertex: Rg,
    normal_vertex: Dg,
    normalmap_pars_fragment: Pg,
    clearcoat_normal_fragment_begin: Fg,
    clearcoat_normal_fragment_maps: Bg,
    clearcoat_pars_fragment: Lg,
    iridescence_pars_fragment: Ug,
    opaque_fragment: Ig,
    packing: Ng,
    premultiplied_alpha_fragment: Og,
    project_vertex: zg,
    dithering_fragment: kg,
    dithering_pars_fragment: Hg,
    roughnessmap_fragment: Vg,
    roughnessmap_pars_fragment: Gg,
    shadowmap_pars_fragment: Wg,
    shadowmap_pars_vertex: Xg,
    shadowmap_vertex: qg,
    shadowmask_pars_fragment: Yg,
    skinbase_vertex: $g,
    skinning_pars_vertex: jg,
    skinning_vertex: Kg,
    skinnormal_vertex: Zg,
    specularmap_fragment: Jg,
    specularmap_pars_fragment: Qg,
    tonemapping_fragment: e_,
    tonemapping_pars_fragment: t_,
    transmission_fragment: n_,
    transmission_pars_fragment: i_,
    uv_pars_fragment: r_,
    uv_pars_vertex: s_,
    uv_vertex: a_,
    worldpos_vertex: o_,
    background_vert: c_,
    background_frag: l_,
    backgroundCube_vert: u_,
    backgroundCube_frag: f_,
    cube_vert: h_,
    cube_frag: d_,
    depth_vert: p_,
    depth_frag: m_,
    distanceRGBA_vert: x_,
    distanceRGBA_frag: g_,
    equirect_vert: __,
    equirect_frag: v_,
    linedashed_vert: E_,
    linedashed_frag: y_,
    meshbasic_vert: S_,
    meshbasic_frag: M_,
    meshlambert_vert: A_,
    meshlambert_frag: b_,
    meshmatcap_vert: T_,
    meshmatcap_frag: C_,
    meshnormal_vert: w_,
    meshnormal_frag: R_,
    meshphong_vert: D_,
    meshphong_frag: P_,
    meshphysical_vert: F_,
    meshphysical_frag: B_,
    meshtoon_vert: L_,
    meshtoon_frag: U_,
    points_vert: I_,
    points_frag: N_,
    shadow_vert: O_,
    shadow_frag: z_,
    sprite_vert: k_,
    sprite_frag: H_,
  },
  ye = {
    common: {
      diffuse: { value: new ut(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new Ze() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Ze() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new Ze() },
    },
    envmap: {
      envMap: { value: null },
      envMapRotation: { value: new Ze() },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new Ze() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new Ze() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new Ze() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new Ze() },
      normalScale: { value: new it(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new Ze() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new Ze() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new Ze() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new Ze() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new ut(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new ut(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Ze() },
      alphaTest: { value: 0 },
      uvTransform: { value: new Ze() },
    },
    sprite: {
      diffuse: { value: new ut(16777215) },
      opacity: { value: 1 },
      center: { value: new it(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new Ze() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Ze() },
      alphaTest: { value: 0 },
    },
  },
  wn = {
    basic: {
      uniforms: Kt([
        ye.common,
        ye.specularmap,
        ye.envmap,
        ye.aomap,
        ye.lightmap,
        ye.fog,
      ]),
      vertexShader: Je.meshbasic_vert,
      fragmentShader: Je.meshbasic_frag,
    },
    lambert: {
      uniforms: Kt([
        ye.common,
        ye.specularmap,
        ye.envmap,
        ye.aomap,
        ye.lightmap,
        ye.emissivemap,
        ye.bumpmap,
        ye.normalmap,
        ye.displacementmap,
        ye.fog,
        ye.lights,
        { emissive: { value: new ut(0) } },
      ]),
      vertexShader: Je.meshlambert_vert,
      fragmentShader: Je.meshlambert_frag,
    },
    phong: {
      uniforms: Kt([
        ye.common,
        ye.specularmap,
        ye.envmap,
        ye.aomap,
        ye.lightmap,
        ye.emissivemap,
        ye.bumpmap,
        ye.normalmap,
        ye.displacementmap,
        ye.fog,
        ye.lights,
        {
          emissive: { value: new ut(0) },
          specular: { value: new ut(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: Je.meshphong_vert,
      fragmentShader: Je.meshphong_frag,
    },
    standard: {
      uniforms: Kt([
        ye.common,
        ye.envmap,
        ye.aomap,
        ye.lightmap,
        ye.emissivemap,
        ye.bumpmap,
        ye.normalmap,
        ye.displacementmap,
        ye.roughnessmap,
        ye.metalnessmap,
        ye.fog,
        ye.lights,
        {
          emissive: { value: new ut(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: Je.meshphysical_vert,
      fragmentShader: Je.meshphysical_frag,
    },
    toon: {
      uniforms: Kt([
        ye.common,
        ye.aomap,
        ye.lightmap,
        ye.emissivemap,
        ye.bumpmap,
        ye.normalmap,
        ye.displacementmap,
        ye.gradientmap,
        ye.fog,
        ye.lights,
        { emissive: { value: new ut(0) } },
      ]),
      vertexShader: Je.meshtoon_vert,
      fragmentShader: Je.meshtoon_frag,
    },
    matcap: {
      uniforms: Kt([
        ye.common,
        ye.bumpmap,
        ye.normalmap,
        ye.displacementmap,
        ye.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: Je.meshmatcap_vert,
      fragmentShader: Je.meshmatcap_frag,
    },
    points: {
      uniforms: Kt([ye.points, ye.fog]),
      vertexShader: Je.points_vert,
      fragmentShader: Je.points_frag,
    },
    dashed: {
      uniforms: Kt([
        ye.common,
        ye.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: Je.linedashed_vert,
      fragmentShader: Je.linedashed_frag,
    },
    depth: {
      uniforms: Kt([ye.common, ye.displacementmap]),
      vertexShader: Je.depth_vert,
      fragmentShader: Je.depth_frag,
    },
    normal: {
      uniforms: Kt([
        ye.common,
        ye.bumpmap,
        ye.normalmap,
        ye.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: Je.meshnormal_vert,
      fragmentShader: Je.meshnormal_frag,
    },
    sprite: {
      uniforms: Kt([ye.sprite, ye.fog]),
      vertexShader: Je.sprite_vert,
      fragmentShader: Je.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new Ze() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Je.background_vert,
      fragmentShader: Je.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
        backgroundRotation: { value: new Ze() },
      },
      vertexShader: Je.backgroundCube_vert,
      fragmentShader: Je.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: Je.cube_vert,
      fragmentShader: Je.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Je.equirect_vert,
      fragmentShader: Je.equirect_frag,
    },
    distanceRGBA: {
      uniforms: Kt([
        ye.common,
        ye.displacementmap,
        {
          referencePosition: { value: new W() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: Je.distanceRGBA_vert,
      fragmentShader: Je.distanceRGBA_frag,
    },
    shadow: {
      uniforms: Kt([
        ye.lights,
        ye.fog,
        { color: { value: new ut(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: Je.shadow_vert,
      fragmentShader: Je.shadow_frag,
    },
  };
wn.physical = {
  uniforms: Kt([
    wn.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new Ze() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new Ze() },
      clearcoatNormalScale: { value: new it(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new Ze() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new Ze() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new Ze() },
      sheen: { value: 0 },
      sheenColor: { value: new ut(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new Ze() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new Ze() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new Ze() },
      transmissionSamplerSize: { value: new it() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new Ze() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new ut(0) },
      specularColor: { value: new ut(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new Ze() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new Ze() },
      anisotropyVector: { value: new it() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new Ze() },
    },
  ]),
  vertexShader: Je.meshphysical_vert,
  fragmentShader: Je.meshphysical_frag,
};
const ys = { r: 0, b: 0, g: 0 },
  pi = new Pn(),
  V_ = new Tt();
function G_(i, e, t, n, r, s, a) {
  const o = new ut(0);
  let l = s === !0 ? 0 : 1,
    c,
    u,
    h = null,
    f = 0,
    m = null;
  function x(E) {
    let v = E.isScene === !0 ? E.background : null;
    return (
      v && v.isTexture && (v = (E.backgroundBlurriness > 0 ? t : e).get(v)), v
    );
  }
  function g(E) {
    let v = !1;
    const C = x(E);
    C === null ? p(o, l) : C && C.isColor && (p(C, 1), (v = !0));
    const A = i.xr.getEnvironmentBlendMode();
    A === "additive"
      ? n.buffers.color.setClear(0, 0, 0, 1, a)
      : A === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, a),
      (i.autoClear || v) &&
        (n.buffers.depth.setTest(!0),
        n.buffers.depth.setMask(!0),
        n.buffers.color.setMask(!0),
        i.clear(i.autoClearColor, i.autoClearDepth, i.autoClearStencil));
  }
  function d(E, v) {
    const C = x(v);
    C && (C.isCubeTexture || C.mapping === Pa)
      ? (u === void 0 &&
          ((u = new Vn(
            new Xr(1, 1, 1),
            new ai({
              name: "BackgroundCubeMaterial",
              uniforms: pr(wn.backgroundCube.uniforms),
              vertexShader: wn.backgroundCube.vertexShader,
              fragmentShader: wn.backgroundCube.fragmentShader,
              side: Qt,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            }),
          )),
          u.geometry.deleteAttribute("normal"),
          u.geometry.deleteAttribute("uv"),
          (u.onBeforeRender = function (A, S, R) {
            this.matrixWorld.copyPosition(R.matrixWorld);
          }),
          Object.defineProperty(u.material, "envMap", {
            get: function () {
              return this.uniforms.envMap.value;
            },
          }),
          r.update(u)),
        pi.copy(v.backgroundRotation),
        (pi.x *= -1),
        (pi.y *= -1),
        (pi.z *= -1),
        C.isCubeTexture &&
          C.isRenderTargetTexture === !1 &&
          ((pi.y *= -1), (pi.z *= -1)),
        (u.material.uniforms.envMap.value = C),
        (u.material.uniforms.flipEnvMap.value =
          C.isCubeTexture && C.isRenderTargetTexture === !1 ? -1 : 1),
        (u.material.uniforms.backgroundBlurriness.value =
          v.backgroundBlurriness),
        (u.material.uniforms.backgroundIntensity.value = v.backgroundIntensity),
        u.material.uniforms.backgroundRotation.value.setFromMatrix4(
          V_.makeRotationFromEuler(pi),
        ),
        (u.material.toneMapped = pt.getTransfer(C.colorSpace) !== vt),
        (h !== C || f !== C.version || m !== i.toneMapping) &&
          ((u.material.needsUpdate = !0),
          (h = C),
          (f = C.version),
          (m = i.toneMapping)),
        u.layers.enableAll(),
        E.unshift(u, u.geometry, u.material, 0, 0, null))
      : C &&
        C.isTexture &&
        (c === void 0 &&
          ((c = new Vn(
            new Ba(2, 2),
            new ai({
              name: "BackgroundMaterial",
              uniforms: pr(wn.background.uniforms),
              vertexShader: wn.background.vertexShader,
              fragmentShader: wn.background.fragmentShader,
              side: si,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            }),
          )),
          c.geometry.deleteAttribute("normal"),
          Object.defineProperty(c.material, "map", {
            get: function () {
              return this.uniforms.t2D.value;
            },
          }),
          r.update(c)),
        (c.material.uniforms.t2D.value = C),
        (c.material.uniforms.backgroundIntensity.value = v.backgroundIntensity),
        (c.material.toneMapped = pt.getTransfer(C.colorSpace) !== vt),
        C.matrixAutoUpdate === !0 && C.updateMatrix(),
        c.material.uniforms.uvTransform.value.copy(C.matrix),
        (h !== C || f !== C.version || m !== i.toneMapping) &&
          ((c.material.needsUpdate = !0),
          (h = C),
          (f = C.version),
          (m = i.toneMapping)),
        c.layers.enableAll(),
        E.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function p(E, v) {
    E.getRGB(ys, _h(i)), n.buffers.color.setClear(ys.r, ys.g, ys.b, v, a);
  }
  function y() {
    u !== void 0 && (u.geometry.dispose(), u.material.dispose(), (u = void 0)),
      c !== void 0 &&
        (c.geometry.dispose(), c.material.dispose(), (c = void 0));
  }
  return {
    getClearColor: function () {
      return o;
    },
    setClearColor: function (E, v = 1) {
      o.set(E), (l = v), p(o, l);
    },
    getClearAlpha: function () {
      return l;
    },
    setClearAlpha: function (E) {
      (l = E), p(o, l);
    },
    render: g,
    addToRenderList: d,
    dispose: y,
  };
}
function W_(i, e) {
  const t = i.getParameter(i.MAX_VERTEX_ATTRIBS),
    n = {},
    r = f(null);
  let s = r,
    a = !1;
  function o(_, T, F, P, I) {
    let X = !1;
    const V = h(P, F, T);
    s !== V && ((s = V), c(s.object)),
      (X = m(_, P, F, I)),
      X && x(_, P, F, I),
      I !== null && e.update(I, i.ELEMENT_ARRAY_BUFFER),
      (X || a) &&
        ((a = !1),
        v(_, T, F, P),
        I !== null && i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e.get(I).buffer));
  }
  function l() {
    return i.createVertexArray();
  }
  function c(_) {
    return i.bindVertexArray(_);
  }
  function u(_) {
    return i.deleteVertexArray(_);
  }
  function h(_, T, F) {
    const P = F.wireframe === !0;
    let I = n[_.id];
    I === void 0 && ((I = {}), (n[_.id] = I));
    let X = I[T.id];
    X === void 0 && ((X = {}), (I[T.id] = X));
    let V = X[P];
    return V === void 0 && ((V = f(l())), (X[P] = V)), V;
  }
  function f(_) {
    const T = [],
      F = [],
      P = [];
    for (let I = 0; I < t; I++) (T[I] = 0), (F[I] = 0), (P[I] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: T,
      enabledAttributes: F,
      attributeDivisors: P,
      object: _,
      attributes: {},
      index: null,
    };
  }
  function m(_, T, F, P) {
    const I = s.attributes,
      X = T.attributes;
    let V = 0;
    const ie = F.getAttributes();
    for (const k in ie)
      if (ie[k].location >= 0) {
        const ce = I[k];
        let H = X[k];
        if (
          (H === void 0 &&
            (k === "instanceMatrix" &&
              _.instanceMatrix &&
              (H = _.instanceMatrix),
            k === "instanceColor" && _.instanceColor && (H = _.instanceColor)),
          ce === void 0 || ce.attribute !== H || (H && ce.data !== H.data))
        )
          return !0;
        V++;
      }
    return s.attributesNum !== V || s.index !== P;
  }
  function x(_, T, F, P) {
    const I = {},
      X = T.attributes;
    let V = 0;
    const ie = F.getAttributes();
    for (const k in ie)
      if (ie[k].location >= 0) {
        let ce = X[k];
        ce === void 0 &&
          (k === "instanceMatrix" &&
            _.instanceMatrix &&
            (ce = _.instanceMatrix),
          k === "instanceColor" && _.instanceColor && (ce = _.instanceColor));
        const H = {};
        (H.attribute = ce),
          ce && ce.data && (H.data = ce.data),
          (I[k] = H),
          V++;
      }
    (s.attributes = I), (s.attributesNum = V), (s.index = P);
  }
  function g() {
    const _ = s.newAttributes;
    for (let T = 0, F = _.length; T < F; T++) _[T] = 0;
  }
  function d(_) {
    p(_, 0);
  }
  function p(_, T) {
    const F = s.newAttributes,
      P = s.enabledAttributes,
      I = s.attributeDivisors;
    (F[_] = 1),
      P[_] === 0 && (i.enableVertexAttribArray(_), (P[_] = 1)),
      I[_] !== T && (i.vertexAttribDivisor(_, T), (I[_] = T));
  }
  function y() {
    const _ = s.newAttributes,
      T = s.enabledAttributes;
    for (let F = 0, P = T.length; F < P; F++)
      T[F] !== _[F] && (i.disableVertexAttribArray(F), (T[F] = 0));
  }
  function E(_, T, F, P, I, X, V) {
    V === !0
      ? i.vertexAttribIPointer(_, T, F, I, X)
      : i.vertexAttribPointer(_, T, F, P, I, X);
  }
  function v(_, T, F, P) {
    g();
    const I = P.attributes,
      X = F.getAttributes(),
      V = T.defaultAttributeValues;
    for (const ie in X) {
      const k = X[ie];
      if (k.location >= 0) {
        let ae = I[ie];
        if (
          (ae === void 0 &&
            (ie === "instanceMatrix" &&
              _.instanceMatrix &&
              (ae = _.instanceMatrix),
            ie === "instanceColor" &&
              _.instanceColor &&
              (ae = _.instanceColor)),
          ae !== void 0)
        ) {
          const ce = ae.normalized,
            H = ae.itemSize,
            K = e.get(ae);
          if (K === void 0) continue;
          const Q = K.buffer,
            B = K.type,
            te = K.bytesPerElement,
            fe = B === i.INT || B === i.UNSIGNED_INT || ae.gpuType === qc;
          if (ae.isInterleavedBufferAttribute) {
            const he = ae.data,
              de = he.stride,
              Qe = ae.offset;
            if (he.isInstancedInterleavedBuffer) {
              for (let Oe = 0; Oe < k.locationSize; Oe++)
                p(k.location + Oe, he.meshPerAttribute);
              _.isInstancedMesh !== !0 &&
                P._maxInstanceCount === void 0 &&
                (P._maxInstanceCount = he.meshPerAttribute * he.count);
            } else
              for (let Oe = 0; Oe < k.locationSize; Oe++) d(k.location + Oe);
            i.bindBuffer(i.ARRAY_BUFFER, Q);
            for (let Oe = 0; Oe < k.locationSize; Oe++)
              E(
                k.location + Oe,
                H / k.locationSize,
                B,
                ce,
                de * te,
                (Qe + (H / k.locationSize) * Oe) * te,
                fe,
              );
          } else {
            if (ae.isInstancedBufferAttribute) {
              for (let he = 0; he < k.locationSize; he++)
                p(k.location + he, ae.meshPerAttribute);
              _.isInstancedMesh !== !0 &&
                P._maxInstanceCount === void 0 &&
                (P._maxInstanceCount = ae.meshPerAttribute * ae.count);
            } else
              for (let he = 0; he < k.locationSize; he++) d(k.location + he);
            i.bindBuffer(i.ARRAY_BUFFER, Q);
            for (let he = 0; he < k.locationSize; he++)
              E(
                k.location + he,
                H / k.locationSize,
                B,
                ce,
                H * te,
                (H / k.locationSize) * he * te,
                fe,
              );
          }
        } else if (V !== void 0) {
          const ce = V[ie];
          if (ce !== void 0)
            switch (ce.length) {
              case 2:
                i.vertexAttrib2fv(k.location, ce);
                break;
              case 3:
                i.vertexAttrib3fv(k.location, ce);
                break;
              case 4:
                i.vertexAttrib4fv(k.location, ce);
                break;
              default:
                i.vertexAttrib1fv(k.location, ce);
            }
        }
      }
    }
    y();
  }
  function C() {
    R();
    for (const _ in n) {
      const T = n[_];
      for (const F in T) {
        const P = T[F];
        for (const I in P) u(P[I].object), delete P[I];
        delete T[F];
      }
      delete n[_];
    }
  }
  function A(_) {
    if (n[_.id] === void 0) return;
    const T = n[_.id];
    for (const F in T) {
      const P = T[F];
      for (const I in P) u(P[I].object), delete P[I];
      delete T[F];
    }
    delete n[_.id];
  }
  function S(_) {
    for (const T in n) {
      const F = n[T];
      if (F[_.id] === void 0) continue;
      const P = F[_.id];
      for (const I in P) u(P[I].object), delete P[I];
      delete F[_.id];
    }
  }
  function R() {
    M(), (a = !0), s !== r && ((s = r), c(s.object));
  }
  function M() {
    (r.geometry = null), (r.program = null), (r.wireframe = !1);
  }
  return {
    setup: o,
    reset: R,
    resetDefaultState: M,
    dispose: C,
    releaseStatesOfGeometry: A,
    releaseStatesOfProgram: S,
    initAttributes: g,
    enableAttribute: d,
    disableUnusedAttributes: y,
  };
}
function X_(i, e, t) {
  let n;
  function r(c) {
    n = c;
  }
  function s(c, u) {
    i.drawArrays(n, c, u), t.update(u, n, 1);
  }
  function a(c, u, h) {
    h !== 0 && (i.drawArraysInstanced(n, c, u, h), t.update(u, n, h));
  }
  function o(c, u, h) {
    if (h === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, c, 0, u, 0, h);
    let m = 0;
    for (let x = 0; x < h; x++) m += u[x];
    t.update(m, n, 1);
  }
  function l(c, u, h, f) {
    if (h === 0) return;
    const m = e.get("WEBGL_multi_draw");
    if (m === null) for (let x = 0; x < c.length; x++) a(c[x], u[x], f[x]);
    else {
      m.multiDrawArraysInstancedWEBGL(n, c, 0, u, 0, f, 0, h);
      let x = 0;
      for (let g = 0; g < h; g++) x += u[g] * f[g];
      t.update(x, n, 1);
    }
  }
  (this.setMode = r),
    (this.render = s),
    (this.renderInstances = a),
    (this.renderMultiDraw = o),
    (this.renderMultiDrawInstances = l);
}
function q_(i, e, t, n) {
  let r;
  function s() {
    if (r !== void 0) return r;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const S = e.get("EXT_texture_filter_anisotropic");
      r = i.getParameter(S.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else r = 0;
    return r;
  }
  function a(S) {
    return !(
      S !== Sn &&
      n.convert(S) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_FORMAT)
    );
  }
  function o(S) {
    const R =
      S === Vr &&
      (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(
      S !== Wn &&
      n.convert(S) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_TYPE) &&
      S !== kn &&
      !R
    );
  }
  function l(S) {
    if (S === "highp") {
      if (
        i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.HIGH_FLOAT).precision >
          0 &&
        i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      S = "mediump";
    }
    return S === "mediump" &&
      i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.MEDIUM_FLOAT).precision >
        0 &&
      i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  let c = t.precision !== void 0 ? t.precision : "highp";
  const u = l(c);
  u !== c &&
    (console.warn(
      "THREE.WebGLRenderer:",
      c,
      "not supported, using",
      u,
      "instead.",
    ),
    (c = u));
  const h = t.logarithmicDepthBuffer === !0,
    f = t.reverseDepthBuffer === !0 && e.has("EXT_clip_control"),
    m = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS),
    x = i.getParameter(i.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    g = i.getParameter(i.MAX_TEXTURE_SIZE),
    d = i.getParameter(i.MAX_CUBE_MAP_TEXTURE_SIZE),
    p = i.getParameter(i.MAX_VERTEX_ATTRIBS),
    y = i.getParameter(i.MAX_VERTEX_UNIFORM_VECTORS),
    E = i.getParameter(i.MAX_VARYING_VECTORS),
    v = i.getParameter(i.MAX_FRAGMENT_UNIFORM_VECTORS),
    C = x > 0,
    A = i.getParameter(i.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    getMaxAnisotropy: s,
    getMaxPrecision: l,
    textureFormatReadable: a,
    textureTypeReadable: o,
    precision: c,
    logarithmicDepthBuffer: h,
    reverseDepthBuffer: f,
    maxTextures: m,
    maxVertexTextures: x,
    maxTextureSize: g,
    maxCubemapSize: d,
    maxAttributes: p,
    maxVertexUniforms: y,
    maxVaryings: E,
    maxFragmentUniforms: v,
    vertexTextures: C,
    maxSamples: A,
  };
}
function Y_(i) {
  const e = this;
  let t = null,
    n = 0,
    r = !1,
    s = !1;
  const a = new xi(),
    o = new Ze(),
    l = { value: null, needsUpdate: !1 };
  (this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (h, f) {
      const m = h.length !== 0 || f || n !== 0 || r;
      return (r = f), (n = h.length), m;
    }),
    (this.beginShadows = function () {
      (s = !0), u(null);
    }),
    (this.endShadows = function () {
      s = !1;
    }),
    (this.setGlobalState = function (h, f) {
      t = u(h, f, 0);
    }),
    (this.setState = function (h, f, m) {
      const x = h.clippingPlanes,
        g = h.clipIntersection,
        d = h.clipShadows,
        p = i.get(h);
      if (!r || x === null || x.length === 0 || (s && !d)) s ? u(null) : c();
      else {
        const y = s ? 0 : n,
          E = y * 4;
        let v = p.clippingState || null;
        (l.value = v), (v = u(x, f, E, m));
        for (let C = 0; C !== E; ++C) v[C] = t[C];
        (p.clippingState = v),
          (this.numIntersection = g ? this.numPlanes : 0),
          (this.numPlanes += y);
      }
    });
  function c() {
    l.value !== t && ((l.value = t), (l.needsUpdate = n > 0)),
      (e.numPlanes = n),
      (e.numIntersection = 0);
  }
  function u(h, f, m, x) {
    const g = h !== null ? h.length : 0;
    let d = null;
    if (g !== 0) {
      if (((d = l.value), x !== !0 || d === null)) {
        const p = m + g * 4,
          y = f.matrixWorldInverse;
        o.getNormalMatrix(y),
          (d === null || d.length < p) && (d = new Float32Array(p));
        for (let E = 0, v = m; E !== g; ++E, v += 4)
          a.copy(h[E]).applyMatrix4(y, o),
            a.normal.toArray(d, v),
            (d[v + 3] = a.constant);
      }
      (l.value = d), (l.needsUpdate = !0);
    }
    return (e.numPlanes = g), (e.numIntersection = 0), d;
  }
}
function $_(i) {
  let e = new WeakMap();
  function t(a, o) {
    return o === jo ? (a.mapping = lr) : o === Ko && (a.mapping = ur), a;
  }
  function n(a) {
    if (a && a.isTexture) {
      const o = a.mapping;
      if (o === jo || o === Ko)
        if (e.has(a)) {
          const l = e.get(a).texture;
          return t(l, a.mapping);
        } else {
          const l = a.image;
          if (l && l.height > 0) {
            const c = new Xm(l.height);
            return (
              c.fromEquirectangularTexture(i, a),
              e.set(a, c),
              a.addEventListener("dispose", r),
              t(c.texture, a.mapping)
            );
          } else return null;
        }
    }
    return a;
  }
  function r(a) {
    const o = a.target;
    o.removeEventListener("dispose", r);
    const l = e.get(o);
    l !== void 0 && (e.delete(o), l.dispose());
  }
  function s() {
    e = new WeakMap();
  }
  return { get: n, dispose: s };
}
const nr = 4,
  qu = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  Ei = 20,
  Mo = new sx(),
  Yu = new ut();
let Ao = null,
  bo = 0,
  To = 0,
  Co = !1;
const gi = (1 + Math.sqrt(5)) / 2,
  Qi = 1 / gi,
  $u = [
    new W(-gi, Qi, 0),
    new W(gi, Qi, 0),
    new W(-Qi, 0, gi),
    new W(Qi, 0, gi),
    new W(0, gi, -Qi),
    new W(0, gi, Qi),
    new W(-1, 1, -1),
    new W(1, 1, -1),
    new W(-1, 1, 1),
    new W(1, 1, 1),
  ];
class ju {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, n = 0.1, r = 100) {
    (Ao = this._renderer.getRenderTarget()),
      (bo = this._renderer.getActiveCubeFace()),
      (To = this._renderer.getActiveMipmapLevel()),
      (Co = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1),
      this._setSize(256);
    const s = this._allocateTargets();
    return (
      (s.depthBuffer = !0),
      this._sceneToCubeUV(e, n, r, s),
      t > 0 && this._blur(s, 0, 0, t),
      this._applyPMREM(s),
      this._cleanup(s),
      s
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = Ju()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = Zu()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(Ao, bo, To),
      (this._renderer.xr.enabled = Co),
      (e.scissorTest = !1),
      Ss(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === lr || e.mapping === ur
      ? this._setSize(
          e.image.length === 0
            ? 16
            : e.image[0].width || e.image[0].image.width,
        )
      : this._setSize(e.image.width / 4),
      (Ao = this._renderer.getRenderTarget()),
      (bo = this._renderer.getActiveCubeFace()),
      (To = this._renderer.getActiveMipmapLevel()),
      (Co = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1);
    const n = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      n = {
        magFilter: Dn,
        minFilter: Dn,
        generateMipmaps: !1,
        type: Vr,
        format: Sn,
        colorSpace: dr,
        depthBuffer: !1,
      },
      r = Ku(e, t, n);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = Ku(e, t, n));
      const { _lodMax: s } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = j_(s)),
        (this._blurMaterial = K_(s, e, t));
    }
    return r;
  }
  _compileMaterial(e) {
    const t = new Vn(this._lodPlanes[0], e);
    this._renderer.compile(t, Mo);
  }
  _sceneToCubeUV(e, t, n, r) {
    const o = new dn(90, 1, t, n),
      l = [1, -1, 1, 1, 1, 1],
      c = [1, 1, 1, -1, -1, -1],
      u = this._renderer,
      h = u.autoClear,
      f = u.toneMapping;
    u.getClearColor(Yu), (u.toneMapping = ni), (u.autoClear = !1);
    const m = new mh({
        name: "PMREM.Background",
        side: Qt,
        depthWrite: !1,
        depthTest: !1,
      }),
      x = new Vn(new Xr(), m);
    let g = !1;
    const d = e.background;
    d
      ? d.isColor && (m.color.copy(d), (e.background = null), (g = !0))
      : (m.color.copy(Yu), (g = !0));
    for (let p = 0; p < 6; p++) {
      const y = p % 3;
      y === 0
        ? (o.up.set(0, l[p], 0), o.lookAt(c[p], 0, 0))
        : y === 1
          ? (o.up.set(0, 0, l[p]), o.lookAt(0, c[p], 0))
          : (o.up.set(0, l[p], 0), o.lookAt(0, 0, c[p]));
      const E = this._cubeSize;
      Ss(r, y * E, p > 2 ? E : 0, E, E),
        u.setRenderTarget(r),
        g && u.render(x, o),
        u.render(e, o);
    }
    x.geometry.dispose(),
      x.material.dispose(),
      (u.toneMapping = f),
      (u.autoClear = h),
      (e.background = d);
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer,
      r = e.mapping === lr || e.mapping === ur;
    r
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = Ju()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = Zu());
    const s = r ? this._cubemapMaterial : this._equirectMaterial,
      a = new Vn(this._lodPlanes[0], s),
      o = s.uniforms;
    o.envMap.value = e;
    const l = this._cubeSize;
    Ss(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(a, Mo);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      n = t.autoClear;
    t.autoClear = !1;
    const r = this._lodPlanes.length;
    for (let s = 1; s < r; s++) {
      const a = Math.sqrt(
          this._sigmas[s] * this._sigmas[s] -
            this._sigmas[s - 1] * this._sigmas[s - 1],
        ),
        o = $u[(r - s - 1) % $u.length];
      this._blur(e, s - 1, s, a, o);
    }
    t.autoClear = n;
  }
  _blur(e, t, n, r, s) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(e, a, t, n, r, "latitudinal", s),
      this._halfBlur(a, e, n, n, r, "longitudinal", s);
  }
  _halfBlur(e, t, n, r, s, a, o) {
    const l = this._renderer,
      c = this._blurMaterial;
    a !== "latitudinal" &&
      a !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!",
      );
    const u = 3,
      h = new Vn(this._lodPlanes[r], c),
      f = c.uniforms,
      m = this._sizeLods[n] - 1,
      x = isFinite(s) ? Math.PI / (2 * m) : (2 * Math.PI) / (2 * Ei - 1),
      g = s / x,
      d = isFinite(s) ? 1 + Math.floor(u * g) : Ei;
    d > Ei &&
      console.warn(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${d} samples when the maximum is set to ${Ei}`,
      );
    const p = [];
    let y = 0;
    for (let S = 0; S < Ei; ++S) {
      const R = S / g,
        M = Math.exp((-R * R) / 2);
      p.push(M), S === 0 ? (y += M) : S < d && (y += 2 * M);
    }
    for (let S = 0; S < p.length; S++) p[S] = p[S] / y;
    (f.envMap.value = e.texture),
      (f.samples.value = d),
      (f.weights.value = p),
      (f.latitudinal.value = a === "latitudinal"),
      o && (f.poleAxis.value = o);
    const { _lodMax: E } = this;
    (f.dTheta.value = x), (f.mipInt.value = E - n);
    const v = this._sizeLods[r],
      C = 3 * v * (r > E - nr ? r - E + nr : 0),
      A = 4 * (this._cubeSize - v);
    Ss(t, C, A, 3 * v, 2 * v), l.setRenderTarget(t), l.render(h, Mo);
  }
}
function j_(i) {
  const e = [],
    t = [],
    n = [];
  let r = i;
  const s = i - nr + 1 + qu.length;
  for (let a = 0; a < s; a++) {
    const o = Math.pow(2, r);
    t.push(o);
    let l = 1 / o;
    a > i - nr ? (l = qu[a - i + nr - 1]) : a === 0 && (l = 0), n.push(l);
    const c = 1 / (o - 2),
      u = -c,
      h = 1 + c,
      f = [u, u, h, u, h, h, u, u, h, h, u, h],
      m = 6,
      x = 6,
      g = 3,
      d = 2,
      p = 1,
      y = new Float32Array(g * x * m),
      E = new Float32Array(d * x * m),
      v = new Float32Array(p * x * m);
    for (let A = 0; A < m; A++) {
      const S = ((A % 3) * 2) / 3 - 1,
        R = A > 2 ? 0 : -1,
        M = [
          S,
          R,
          0,
          S + 2 / 3,
          R,
          0,
          S + 2 / 3,
          R + 1,
          0,
          S,
          R,
          0,
          S + 2 / 3,
          R + 1,
          0,
          S,
          R + 1,
          0,
        ];
      y.set(M, g * x * A), E.set(f, d * x * A);
      const _ = [A, A, A, A, A, A];
      v.set(_, p * x * A);
    }
    const C = new bn();
    C.setAttribute("position", new An(y, g)),
      C.setAttribute("uv", new An(E, d)),
      C.setAttribute("faceIndex", new An(v, p)),
      e.push(C),
      r > nr && r--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: n };
}
function Ku(i, e, t) {
  const n = new Ci(i, e, t);
  return (
    (n.texture.mapping = Pa),
    (n.texture.name = "PMREM.cubeUv"),
    (n.scissorTest = !0),
    n
  );
}
function Ss(i, e, t, n, r) {
  i.viewport.set(e, t, n, r), i.scissor.set(e, t, n, r);
}
function K_(i, e, t) {
  const n = new Float32Array(Ei),
    r = new W(0, 1, 0);
  return new ai({
    name: "SphericalGaussianBlur",
    defines: {
      n: Ei,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${i}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r },
    },
    vertexShader: tl(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: ti,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Zu() {
  return new ai({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: tl(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: ti,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Ju() {
  return new ai({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: tl(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: ti,
    depthTest: !1,
    depthWrite: !1,
  });
}
function tl() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function Z_(i) {
  let e = new WeakMap(),
    t = null;
  function n(o) {
    if (o && o.isTexture) {
      const l = o.mapping,
        c = l === jo || l === Ko,
        u = l === lr || l === ur;
      if (c || u) {
        let h = e.get(o);
        const f = h !== void 0 ? h.texture.pmremVersion : 0;
        if (o.isRenderTargetTexture && o.pmremVersion !== f)
          return (
            t === null && (t = new ju(i)),
            (h = c ? t.fromEquirectangular(o, h) : t.fromCubemap(o, h)),
            (h.texture.pmremVersion = o.pmremVersion),
            e.set(o, h),
            h.texture
          );
        if (h !== void 0) return h.texture;
        {
          const m = o.image;
          return (c && m && m.height > 0) || (u && m && r(m))
            ? (t === null && (t = new ju(i)),
              (h = c ? t.fromEquirectangular(o) : t.fromCubemap(o)),
              (h.texture.pmremVersion = o.pmremVersion),
              e.set(o, h),
              o.addEventListener("dispose", s),
              h.texture)
            : null;
        }
      }
    }
    return o;
  }
  function r(o) {
    let l = 0;
    const c = 6;
    for (let u = 0; u < c; u++) o[u] !== void 0 && l++;
    return l === c;
  }
  function s(o) {
    const l = o.target;
    l.removeEventListener("dispose", s);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function a() {
    (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
  }
  return { get: n, dispose: a };
}
function J_(i) {
  const e = {};
  function t(n) {
    if (e[n] !== void 0) return e[n];
    let r;
    switch (n) {
      case "WEBGL_depth_texture":
        r =
          i.getExtension("WEBGL_depth_texture") ||
          i.getExtension("MOZ_WEBGL_depth_texture") ||
          i.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r =
          i.getExtension("EXT_texture_filter_anisotropic") ||
          i.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r =
          i.getExtension("WEBGL_compressed_texture_s3tc") ||
          i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r =
          i.getExtension("WEBGL_compressed_texture_pvrtc") ||
          i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = i.getExtension(n);
    }
    return (e[n] = r), r;
  }
  return {
    has: function (n) {
      return t(n) !== null;
    },
    init: function () {
      t("EXT_color_buffer_float"),
        t("WEBGL_clip_cull_distance"),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture"),
        t("WEBGL_render_shared_exponent");
    },
    get: function (n) {
      const r = t(n);
      return (
        r === null &&
          tr("THREE.WebGLRenderer: " + n + " extension not supported."),
        r
      );
    },
  };
}
function Q_(i, e, t, n) {
  const r = {},
    s = new WeakMap();
  function a(h) {
    const f = h.target;
    f.index !== null && e.remove(f.index);
    for (const x in f.attributes) e.remove(f.attributes[x]);
    f.removeEventListener("dispose", a), delete r[f.id];
    const m = s.get(f);
    m && (e.remove(m), s.delete(f)),
      n.releaseStatesOfGeometry(f),
      f.isInstancedBufferGeometry === !0 && delete f._maxInstanceCount,
      t.memory.geometries--;
  }
  function o(h, f) {
    return (
      r[f.id] === !0 ||
        (f.addEventListener("dispose", a),
        (r[f.id] = !0),
        t.memory.geometries++),
      f
    );
  }
  function l(h) {
    const f = h.attributes;
    for (const m in f) e.update(f[m], i.ARRAY_BUFFER);
  }
  function c(h) {
    const f = [],
      m = h.index,
      x = h.attributes.position;
    let g = 0;
    if (m !== null) {
      const y = m.array;
      g = m.version;
      for (let E = 0, v = y.length; E < v; E += 3) {
        const C = y[E + 0],
          A = y[E + 1],
          S = y[E + 2];
        f.push(C, A, A, S, S, C);
      }
    } else if (x !== void 0) {
      const y = x.array;
      g = x.version;
      for (let E = 0, v = y.length / 3 - 1; E < v; E += 3) {
        const C = E + 0,
          A = E + 1,
          S = E + 2;
        f.push(C, A, A, S, S, C);
      }
    } else return;
    const d = new (lh(f) ? gh : xh)(f, 1);
    d.version = g;
    const p = s.get(h);
    p && e.remove(p), s.set(h, d);
  }
  function u(h) {
    const f = s.get(h);
    if (f) {
      const m = h.index;
      m !== null && f.version < m.version && c(h);
    } else c(h);
    return s.get(h);
  }
  return { get: o, update: l, getWireframeAttribute: u };
}
function ev(i, e, t) {
  let n;
  function r(f) {
    n = f;
  }
  let s, a;
  function o(f) {
    (s = f.type), (a = f.bytesPerElement);
  }
  function l(f, m) {
    i.drawElements(n, m, s, f * a), t.update(m, n, 1);
  }
  function c(f, m, x) {
    x !== 0 && (i.drawElementsInstanced(n, m, s, f * a, x), t.update(m, n, x));
  }
  function u(f, m, x) {
    if (x === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, m, 0, s, f, 0, x);
    let d = 0;
    for (let p = 0; p < x; p++) d += m[p];
    t.update(d, n, 1);
  }
  function h(f, m, x, g) {
    if (x === 0) return;
    const d = e.get("WEBGL_multi_draw");
    if (d === null) for (let p = 0; p < f.length; p++) c(f[p] / a, m[p], g[p]);
    else {
      d.multiDrawElementsInstancedWEBGL(n, m, 0, s, f, 0, g, 0, x);
      let p = 0;
      for (let y = 0; y < x; y++) p += m[y] * g[y];
      t.update(p, n, 1);
    }
  }
  (this.setMode = r),
    (this.setIndex = o),
    (this.render = l),
    (this.renderInstances = c),
    (this.renderMultiDraw = u),
    (this.renderMultiDrawInstances = h);
}
function tv(i) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function n(s, a, o) {
    switch ((t.calls++, a)) {
      case i.TRIANGLES:
        t.triangles += o * (s / 3);
        break;
      case i.LINES:
        t.lines += o * (s / 2);
        break;
      case i.LINE_STRIP:
        t.lines += o * (s - 1);
        break;
      case i.LINE_LOOP:
        t.lines += o * s;
        break;
      case i.POINTS:
        t.points += o * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", a);
        break;
    }
  }
  function r() {
    (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: r,
    update: n,
  };
}
function nv(i, e, t) {
  const n = new WeakMap(),
    r = new yt();
  function s(a, o, l) {
    const c = a.morphTargetInfluences,
      u =
        o.morphAttributes.position ||
        o.morphAttributes.normal ||
        o.morphAttributes.color,
      h = u !== void 0 ? u.length : 0;
    let f = n.get(o);
    if (f === void 0 || f.count !== h) {
      let M = function () {
        S.dispose(), n.delete(o), o.removeEventListener("dispose", M);
      };
      f !== void 0 && f.texture.dispose();
      const m = o.morphAttributes.position !== void 0,
        x = o.morphAttributes.normal !== void 0,
        g = o.morphAttributes.color !== void 0,
        d = o.morphAttributes.position || [],
        p = o.morphAttributes.normal || [],
        y = o.morphAttributes.color || [];
      let E = 0;
      m === !0 && (E = 1), x === !0 && (E = 2), g === !0 && (E = 3);
      let v = o.attributes.position.count * E,
        C = 1;
      v > e.maxTextureSize &&
        ((C = Math.ceil(v / e.maxTextureSize)), (v = e.maxTextureSize));
      const A = new Float32Array(v * C * 4 * h),
        S = new fh(A, v, C, h);
      (S.type = kn), (S.needsUpdate = !0);
      const R = E * 4;
      for (let _ = 0; _ < h; _++) {
        const T = d[_],
          F = p[_],
          P = y[_],
          I = v * C * 4 * _;
        for (let X = 0; X < T.count; X++) {
          const V = X * R;
          m === !0 &&
            (r.fromBufferAttribute(T, X),
            (A[I + V + 0] = r.x),
            (A[I + V + 1] = r.y),
            (A[I + V + 2] = r.z),
            (A[I + V + 3] = 0)),
            x === !0 &&
              (r.fromBufferAttribute(F, X),
              (A[I + V + 4] = r.x),
              (A[I + V + 5] = r.y),
              (A[I + V + 6] = r.z),
              (A[I + V + 7] = 0)),
            g === !0 &&
              (r.fromBufferAttribute(P, X),
              (A[I + V + 8] = r.x),
              (A[I + V + 9] = r.y),
              (A[I + V + 10] = r.z),
              (A[I + V + 11] = P.itemSize === 4 ? r.w : 1));
        }
      }
      (f = { count: h, texture: S, size: new it(v, C) }),
        n.set(o, f),
        o.addEventListener("dispose", M);
    }
    if (a.isInstancedMesh === !0 && a.morphTexture !== null)
      l.getUniforms().setValue(i, "morphTexture", a.morphTexture, t);
    else {
      let m = 0;
      for (let g = 0; g < c.length; g++) m += c[g];
      const x = o.morphTargetsRelative ? 1 : 1 - m;
      l.getUniforms().setValue(i, "morphTargetBaseInfluence", x),
        l.getUniforms().setValue(i, "morphTargetInfluences", c);
    }
    l.getUniforms().setValue(i, "morphTargetsTexture", f.texture, t),
      l.getUniforms().setValue(i, "morphTargetsTextureSize", f.size);
  }
  return { update: s };
}
function iv(i, e, t, n) {
  let r = new WeakMap();
  function s(l) {
    const c = n.render.frame,
      u = l.geometry,
      h = e.get(l, u);
    if (
      (r.get(h) !== c && (e.update(h), r.set(h, c)),
      l.isInstancedMesh &&
        (l.hasEventListener("dispose", o) === !1 &&
          l.addEventListener("dispose", o),
        r.get(l) !== c &&
          (t.update(l.instanceMatrix, i.ARRAY_BUFFER),
          l.instanceColor !== null && t.update(l.instanceColor, i.ARRAY_BUFFER),
          r.set(l, c))),
      l.isSkinnedMesh)
    ) {
      const f = l.skeleton;
      r.get(f) !== c && (f.update(), r.set(f, c));
    }
    return h;
  }
  function a() {
    r = new WeakMap();
  }
  function o(l) {
    const c = l.target;
    c.removeEventListener("dispose", o),
      t.remove(c.instanceMatrix),
      c.instanceColor !== null && t.remove(c.instanceColor);
  }
  return { update: s, dispose: a };
}
const Ch = new qt(),
  Qu = new Sh(1, 1),
  wh = new fh(),
  Rh = new wm(),
  Dh = new Eh(),
  ef = [],
  tf = [],
  nf = new Float32Array(16),
  rf = new Float32Array(9),
  sf = new Float32Array(4);
function gr(i, e, t) {
  const n = i[0];
  if (n <= 0 || n > 0) return i;
  const r = e * t;
  let s = ef[r];
  if ((s === void 0 && ((s = new Float32Array(r)), (ef[r] = s)), e !== 0)) {
    n.toArray(s, 0);
    for (let a = 1, o = 0; a !== e; ++a) (o += t), i[a].toArray(s, o);
  }
  return s;
}
function Nt(i, e) {
  if (i.length !== e.length) return !1;
  for (let t = 0, n = i.length; t < n; t++) if (i[t] !== e[t]) return !1;
  return !0;
}
function Ot(i, e) {
  for (let t = 0, n = e.length; t < n; t++) i[t] = e[t];
}
function La(i, e) {
  let t = tf[e];
  t === void 0 && ((t = new Int32Array(e)), (tf[e] = t));
  for (let n = 0; n !== e; ++n) t[n] = i.allocateTextureUnit();
  return t;
}
function rv(i, e) {
  const t = this.cache;
  t[0] !== e && (i.uniform1f(this.addr, e), (t[0] = e));
}
function sv(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (i.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Nt(t, e)) return;
    i.uniform2fv(this.addr, e), Ot(t, e);
  }
}
function av(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (i.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (i.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (Nt(t, e)) return;
    i.uniform3fv(this.addr, e), Ot(t, e);
  }
}
function ov(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (i.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Nt(t, e)) return;
    i.uniform4fv(this.addr, e), Ot(t, e);
  }
}
function cv(i, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (Nt(t, e)) return;
    i.uniformMatrix2fv(this.addr, !1, e), Ot(t, e);
  } else {
    if (Nt(t, n)) return;
    sf.set(n), i.uniformMatrix2fv(this.addr, !1, sf), Ot(t, n);
  }
}
function lv(i, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (Nt(t, e)) return;
    i.uniformMatrix3fv(this.addr, !1, e), Ot(t, e);
  } else {
    if (Nt(t, n)) return;
    rf.set(n), i.uniformMatrix3fv(this.addr, !1, rf), Ot(t, n);
  }
}
function uv(i, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (Nt(t, e)) return;
    i.uniformMatrix4fv(this.addr, !1, e), Ot(t, e);
  } else {
    if (Nt(t, n)) return;
    nf.set(n), i.uniformMatrix4fv(this.addr, !1, nf), Ot(t, n);
  }
}
function fv(i, e) {
  const t = this.cache;
  t[0] !== e && (i.uniform1i(this.addr, e), (t[0] = e));
}
function hv(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (i.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Nt(t, e)) return;
    i.uniform2iv(this.addr, e), Ot(t, e);
  }
}
function dv(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (i.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Nt(t, e)) return;
    i.uniform3iv(this.addr, e), Ot(t, e);
  }
}
function pv(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (i.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Nt(t, e)) return;
    i.uniform4iv(this.addr, e), Ot(t, e);
  }
}
function mv(i, e) {
  const t = this.cache;
  t[0] !== e && (i.uniform1ui(this.addr, e), (t[0] = e));
}
function xv(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (i.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Nt(t, e)) return;
    i.uniform2uiv(this.addr, e), Ot(t, e);
  }
}
function gv(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (i.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Nt(t, e)) return;
    i.uniform3uiv(this.addr, e), Ot(t, e);
  }
}
function _v(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (i.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Nt(t, e)) return;
    i.uniform4uiv(this.addr, e), Ot(t, e);
  }
}
function vv(i, e, t) {
  const n = this.cache,
    r = t.allocateTextureUnit();
  n[0] !== r && (i.uniform1i(this.addr, r), (n[0] = r));
  let s;
  this.type === i.SAMPLER_2D_SHADOW
    ? ((Qu.compareFunction = ch), (s = Qu))
    : (s = Ch),
    t.setTexture2D(e || s, r);
}
function Ev(i, e, t) {
  const n = this.cache,
    r = t.allocateTextureUnit();
  n[0] !== r && (i.uniform1i(this.addr, r), (n[0] = r)),
    t.setTexture3D(e || Rh, r);
}
function yv(i, e, t) {
  const n = this.cache,
    r = t.allocateTextureUnit();
  n[0] !== r && (i.uniform1i(this.addr, r), (n[0] = r)),
    t.setTextureCube(e || Dh, r);
}
function Sv(i, e, t) {
  const n = this.cache,
    r = t.allocateTextureUnit();
  n[0] !== r && (i.uniform1i(this.addr, r), (n[0] = r)),
    t.setTexture2DArray(e || wh, r);
}
function Mv(i) {
  switch (i) {
    case 5126:
      return rv;
    case 35664:
      return sv;
    case 35665:
      return av;
    case 35666:
      return ov;
    case 35674:
      return cv;
    case 35675:
      return lv;
    case 35676:
      return uv;
    case 5124:
    case 35670:
      return fv;
    case 35667:
    case 35671:
      return hv;
    case 35668:
    case 35672:
      return dv;
    case 35669:
    case 35673:
      return pv;
    case 5125:
      return mv;
    case 36294:
      return xv;
    case 36295:
      return gv;
    case 36296:
      return _v;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return vv;
    case 35679:
    case 36299:
    case 36307:
      return Ev;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return yv;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return Sv;
  }
}
function Av(i, e) {
  i.uniform1fv(this.addr, e);
}
function bv(i, e) {
  const t = gr(e, this.size, 2);
  i.uniform2fv(this.addr, t);
}
function Tv(i, e) {
  const t = gr(e, this.size, 3);
  i.uniform3fv(this.addr, t);
}
function Cv(i, e) {
  const t = gr(e, this.size, 4);
  i.uniform4fv(this.addr, t);
}
function wv(i, e) {
  const t = gr(e, this.size, 4);
  i.uniformMatrix2fv(this.addr, !1, t);
}
function Rv(i, e) {
  const t = gr(e, this.size, 9);
  i.uniformMatrix3fv(this.addr, !1, t);
}
function Dv(i, e) {
  const t = gr(e, this.size, 16);
  i.uniformMatrix4fv(this.addr, !1, t);
}
function Pv(i, e) {
  i.uniform1iv(this.addr, e);
}
function Fv(i, e) {
  i.uniform2iv(this.addr, e);
}
function Bv(i, e) {
  i.uniform3iv(this.addr, e);
}
function Lv(i, e) {
  i.uniform4iv(this.addr, e);
}
function Uv(i, e) {
  i.uniform1uiv(this.addr, e);
}
function Iv(i, e) {
  i.uniform2uiv(this.addr, e);
}
function Nv(i, e) {
  i.uniform3uiv(this.addr, e);
}
function Ov(i, e) {
  i.uniform4uiv(this.addr, e);
}
function zv(i, e, t) {
  const n = this.cache,
    r = e.length,
    s = La(t, r);
  Nt(n, s) || (i.uniform1iv(this.addr, s), Ot(n, s));
  for (let a = 0; a !== r; ++a) t.setTexture2D(e[a] || Ch, s[a]);
}
function kv(i, e, t) {
  const n = this.cache,
    r = e.length,
    s = La(t, r);
  Nt(n, s) || (i.uniform1iv(this.addr, s), Ot(n, s));
  for (let a = 0; a !== r; ++a) t.setTexture3D(e[a] || Rh, s[a]);
}
function Hv(i, e, t) {
  const n = this.cache,
    r = e.length,
    s = La(t, r);
  Nt(n, s) || (i.uniform1iv(this.addr, s), Ot(n, s));
  for (let a = 0; a !== r; ++a) t.setTextureCube(e[a] || Dh, s[a]);
}
function Vv(i, e, t) {
  const n = this.cache,
    r = e.length,
    s = La(t, r);
  Nt(n, s) || (i.uniform1iv(this.addr, s), Ot(n, s));
  for (let a = 0; a !== r; ++a) t.setTexture2DArray(e[a] || wh, s[a]);
}
function Gv(i) {
  switch (i) {
    case 5126:
      return Av;
    case 35664:
      return bv;
    case 35665:
      return Tv;
    case 35666:
      return Cv;
    case 35674:
      return wv;
    case 35675:
      return Rv;
    case 35676:
      return Dv;
    case 5124:
    case 35670:
      return Pv;
    case 35667:
    case 35671:
      return Fv;
    case 35668:
    case 35672:
      return Bv;
    case 35669:
    case 35673:
      return Lv;
    case 5125:
      return Uv;
    case 36294:
      return Iv;
    case 36295:
      return Nv;
    case 36296:
      return Ov;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return zv;
    case 35679:
    case 36299:
    case 36307:
      return kv;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Hv;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return Vv;
  }
}
class Wv {
  constructor(e, t, n) {
    (this.id = e),
      (this.addr = n),
      (this.cache = []),
      (this.type = t.type),
      (this.setValue = Mv(t.type));
  }
}
class Xv {
  constructor(e, t, n) {
    (this.id = e),
      (this.addr = n),
      (this.cache = []),
      (this.type = t.type),
      (this.size = t.size),
      (this.setValue = Gv(t.type));
  }
}
class qv {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, n) {
    const r = this.seq;
    for (let s = 0, a = r.length; s !== a; ++s) {
      const o = r[s];
      o.setValue(e, t[o.id], n);
    }
  }
}
const wo = /(\w+)(\])?(\[|\.)?/g;
function af(i, e) {
  i.seq.push(e), (i.map[e.id] = e);
}
function Yv(i, e, t) {
  const n = i.name,
    r = n.length;
  for (wo.lastIndex = 0; ; ) {
    const s = wo.exec(n),
      a = wo.lastIndex;
    let o = s[1];
    const l = s[2] === "]",
      c = s[3];
    if ((l && (o = o | 0), c === void 0 || (c === "[" && a + 2 === r))) {
      af(t, c === void 0 ? new Wv(o, i, e) : new Xv(o, i, e));
      break;
    } else {
      let h = t.map[o];
      h === void 0 && ((h = new qv(o)), af(t, h)), (t = h);
    }
  }
}
class ma {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let r = 0; r < n; ++r) {
      const s = e.getActiveUniform(t, r),
        a = e.getUniformLocation(t, s.name);
      Yv(s, a, this);
    }
  }
  setValue(e, t, n, r) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, n, r);
  }
  setOptional(e, t, n) {
    const r = t[n];
    r !== void 0 && this.setValue(e, n, r);
  }
  static upload(e, t, n, r) {
    for (let s = 0, a = t.length; s !== a; ++s) {
      const o = t[s],
        l = n[o.id];
      l.needsUpdate !== !1 && o.setValue(e, l.value, r);
    }
  }
  static seqWithValue(e, t) {
    const n = [];
    for (let r = 0, s = e.length; r !== s; ++r) {
      const a = e[r];
      a.id in t && n.push(a);
    }
    return n;
  }
}
function of(i, e, t) {
  const n = i.createShader(e);
  return i.shaderSource(n, t), i.compileShader(n), n;
}
const $v = 37297;
let jv = 0;
function Kv(i, e) {
  const t = i.split(`
`),
    n = [],
    r = Math.max(e - 6, 0),
    s = Math.min(e + 6, t.length);
  for (let a = r; a < s; a++) {
    const o = a + 1;
    n.push(`${o === e ? ">" : " "} ${o}: ${t[a]}`);
  }
  return n.join(`
`);
}
const cf = new Ze();
function Zv(i) {
  pt._getMatrix(cf, pt.workingColorSpace, i);
  const e = `mat3( ${cf.elements.map((t) => t.toFixed(4))} )`;
  switch (pt.getTransfer(i)) {
    case ba:
      return [e, "LinearTransferOETF"];
    case vt:
      return [e, "sRGBTransferOETF"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space: ", i),
        [e, "LinearTransferOETF"]
      );
  }
}
function lf(i, e, t) {
  const n = i.getShaderParameter(e, i.COMPILE_STATUS),
    r = i.getShaderInfoLog(e).trim();
  if (n && r === "") return "";
  const s = /ERROR: 0:(\d+)/.exec(r);
  if (s) {
    const a = parseInt(s[1]);
    return (
      t.toUpperCase() +
      `

` +
      r +
      `

` +
      Kv(i.getShaderSource(e), a)
    );
  } else return r;
}
function Jv(i, e) {
  const t = Zv(e);
  return [
    `vec4 ${i}( vec4 value ) {`,
    `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,
    "}",
  ].join(`
`);
}
function Qv(i, e) {
  let t;
  switch (e) {
    case em:
      t = "Linear";
      break;
    case tm:
      t = "Reinhard";
      break;
    case nm:
      t = "Cineon";
      break;
    case im:
      t = "ACESFilmic";
      break;
    case sm:
      t = "AgX";
      break;
    case am:
      t = "Neutral";
      break;
    case rm:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear");
  }
  return (
    "vec3 " + i + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  );
}
const Ms = new W();
function e1() {
  pt.getLuminanceCoefficients(Ms);
  const i = Ms.x.toFixed(4),
    e = Ms.y.toFixed(4),
    t = Ms.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${i}, ${e}, ${t} );`,
    "	return dot( weights, rgb );",
    "}",
  ].join(`
`);
}
function t1(i) {
  return [
    i.extensionClipCullDistance
      ? "#extension GL_ANGLE_clip_cull_distance : require"
      : "",
    i.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : "",
  ].filter(Ur).join(`
`);
}
function n1(i) {
  const e = [];
  for (const t in i) {
    const n = i[t];
    n !== !1 && e.push("#define " + t + " " + n);
  }
  return e.join(`
`);
}
function i1(i, e) {
  const t = {},
    n = i.getProgramParameter(e, i.ACTIVE_ATTRIBUTES);
  for (let r = 0; r < n; r++) {
    const s = i.getActiveAttrib(e, r),
      a = s.name;
    let o = 1;
    s.type === i.FLOAT_MAT2 && (o = 2),
      s.type === i.FLOAT_MAT3 && (o = 3),
      s.type === i.FLOAT_MAT4 && (o = 4),
      (t[a] = {
        type: s.type,
        location: i.getAttribLocation(e, a),
        locationSize: o,
      });
  }
  return t;
}
function Ur(i) {
  return i !== "";
}
function uf(i, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return i
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function ff(i, e) {
  return i
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection,
    );
}
const r1 = /^[ \t]*#include +<([\w\d./]+)>/gm;
function wc(i) {
  return i.replace(r1, a1);
}
const s1 = new Map();
function a1(i, e) {
  let t = Je[e];
  if (t === void 0) {
    const n = s1.get(e);
    if (n !== void 0)
      (t = Je[n]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          n,
        );
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return wc(t);
}
const o1 =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function hf(i) {
  return i.replace(o1, c1);
}
function c1(i, e, t, n) {
  let r = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    r += n
      .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, s);
  return r;
}
function df(i) {
  let e = `precision ${i.precision} float;
	precision ${i.precision} int;
	precision ${i.precision} sampler2D;
	precision ${i.precision} samplerCube;
	precision ${i.precision} sampler3D;
	precision ${i.precision} sampler2DArray;
	precision ${i.precision} sampler2DShadow;
	precision ${i.precision} samplerCubeShadow;
	precision ${i.precision} sampler2DArrayShadow;
	precision ${i.precision} isampler2D;
	precision ${i.precision} isampler3D;
	precision ${i.precision} isamplerCube;
	precision ${i.precision} isampler2DArray;
	precision ${i.precision} usampler2D;
	precision ${i.precision} usampler3D;
	precision ${i.precision} usamplerCube;
	precision ${i.precision} usampler2DArray;
	`;
  return (
    i.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : i.precision === "mediump"
        ? (e += `
#define MEDIUM_PRECISION`)
        : i.precision === "lowp" &&
          (e += `
#define LOW_PRECISION`),
    e
  );
}
function l1(i) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    i.shadowMapType === jf
      ? (e = "SHADOWMAP_TYPE_PCF")
      : i.shadowMapType === Bp
        ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
        : i.shadowMapType === On && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function u1(i) {
  let e = "ENVMAP_TYPE_CUBE";
  if (i.envMap)
    switch (i.envMapMode) {
      case lr:
      case ur:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case Pa:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function f1(i) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (i.envMap)
    switch (i.envMapMode) {
      case ur:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function h1(i) {
  let e = "ENVMAP_BLENDING_NONE";
  if (i.envMap)
    switch (i.combine) {
      case Xc:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case Jp:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case Qp:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function d1(i) {
  const e = i.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    n = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 112)),
    texelHeight: n,
    maxMip: t,
  };
}
function p1(i, e, t, n) {
  const r = i.getContext(),
    s = t.defines;
  let a = t.vertexShader,
    o = t.fragmentShader;
  const l = l1(t),
    c = u1(t),
    u = f1(t),
    h = h1(t),
    f = d1(t),
    m = t1(t),
    x = n1(s),
    g = r.createProgram();
  let d,
    p,
    y = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  t.isRawShaderMaterial
    ? ((d = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        x,
      ].filter(Ur).join(`
`)),
      d.length > 0 &&
        (d += `
`),
      (p = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        x,
      ].filter(Ur).join(`
`)),
      p.length > 0 &&
        (p += `
`))
    : ((d = [
        df(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        x,
        t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
        t.batching ? "#define USE_BATCHING" : "",
        t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + u : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.mapUv ? "#define MAP_UV " + t.mapUv : "",
        t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
        t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
        t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
        t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
        t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
        t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
        t.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv
          : "",
        t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
        t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
        t.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv
          : "",
        t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
        t.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv
          : "",
        t.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv
          : "",
        t.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv
          : "",
        t.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv
          : "",
        t.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv
          : "",
        t.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv
          : "",
        t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
        t.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv
          : "",
        t.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv
          : "",
        t.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv
          : "",
        t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "#ifdef USE_INSTANCING_MORPH",
        "	uniform sampler2D morphTexture;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(Ur).join(`
`)),
      (p = [
        df(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        x,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + c : "",
        t.envMap ? "#define " + u : "",
        t.envMap ? "#define " + h : "",
        f ? "#define CUBEUV_TEXEL_WIDTH " + f.texelWidth : "",
        f ? "#define CUBEUV_TEXEL_HEIGHT " + f.texelHeight : "",
        f ? "#define CUBEUV_MAX_MIP " + f.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.dispersion ? "#define USE_DISPERSION" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor || t.batchingColor
          ? "#define USE_COLOR"
          : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.decodeVideoTextureEmissive
          ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE"
          : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== ni ? "#define TONE_MAPPING" : "",
        t.toneMapping !== ni ? Je.tonemapping_pars_fragment : "",
        t.toneMapping !== ni ? Qv("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        Je.colorspace_pars_fragment,
        Jv("linearToOutputTexel", t.outputColorSpace),
        e1(),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(Ur).join(`
`))),
    (a = wc(a)),
    (a = uf(a, t)),
    (a = ff(a, t)),
    (o = wc(o)),
    (o = uf(o, t)),
    (o = ff(o, t)),
    (a = hf(a)),
    (o = hf(o)),
    t.isRawShaderMaterial !== !0 &&
      ((y = `#version 300 es
`),
      (d =
        [
          m,
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        d),
      (p =
        [
          "#define varying in",
          t.glslVersion === vu
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === vu ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        p));
  const E = y + d + a,
    v = y + p + o,
    C = of(r, r.VERTEX_SHADER, E),
    A = of(r, r.FRAGMENT_SHADER, v);
  r.attachShader(g, C),
    r.attachShader(g, A),
    t.index0AttributeName !== void 0
      ? r.bindAttribLocation(g, 0, t.index0AttributeName)
      : t.morphTargets === !0 && r.bindAttribLocation(g, 0, "position"),
    r.linkProgram(g);
  function S(T) {
    if (i.debug.checkShaderErrors) {
      const F = r.getProgramInfoLog(g).trim(),
        P = r.getShaderInfoLog(C).trim(),
        I = r.getShaderInfoLog(A).trim();
      let X = !0,
        V = !0;
      if (r.getProgramParameter(g, r.LINK_STATUS) === !1)
        if (((X = !1), typeof i.debug.onShaderError == "function"))
          i.debug.onShaderError(r, g, C, A);
        else {
          const ie = lf(r, C, "vertex"),
            k = lf(r, A, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              r.getError() +
              " - VALIDATE_STATUS " +
              r.getProgramParameter(g, r.VALIDATE_STATUS) +
              `

Material Name: ` +
              T.name +
              `
Material Type: ` +
              T.type +
              `

Program Info Log: ` +
              F +
              `
` +
              ie +
              `
` +
              k,
          );
        }
      else
        F !== ""
          ? console.warn("THREE.WebGLProgram: Program Info Log:", F)
          : (P === "" || I === "") && (V = !1);
      V &&
        (T.diagnostics = {
          runnable: X,
          programLog: F,
          vertexShader: { log: P, prefix: d },
          fragmentShader: { log: I, prefix: p },
        });
    }
    r.deleteShader(C), r.deleteShader(A), (R = new ma(r, g)), (M = i1(r, g));
  }
  let R;
  this.getUniforms = function () {
    return R === void 0 && S(this), R;
  };
  let M;
  this.getAttributes = function () {
    return M === void 0 && S(this), M;
  };
  let _ = t.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return _ === !1 && (_ = r.getProgramParameter(g, $v)), _;
    }),
    (this.destroy = function () {
      n.releaseStatesOfProgram(this),
        r.deleteProgram(g),
        (this.program = void 0);
    }),
    (this.type = t.shaderType),
    (this.name = t.shaderName),
    (this.id = jv++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = g),
    (this.vertexShader = C),
    (this.fragmentShader = A),
    this
  );
}
let m1 = 0;
class x1 {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      n = e.fragmentShader,
      r = this._getShaderStage(t),
      s = this._getShaderStage(n),
      a = this._getShaderCacheForMaterial(e);
    return (
      a.has(r) === !1 && (a.add(r), r.usedTimes++),
      a.has(s) === !1 && (a.add(s), s.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const n of t)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let n = t.get(e);
    return n === void 0 && ((n = new Set()), t.set(e, n)), n;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let n = t.get(e);
    return n === void 0 && ((n = new g1(e)), t.set(e, n)), n;
  }
}
class g1 {
  constructor(e) {
    (this.id = m1++), (this.code = e), (this.usedTimes = 0);
  }
}
function _1(i, e, t, n, r, s, a) {
  const o = new dh(),
    l = new x1(),
    c = new Set(),
    u = [],
    h = r.logarithmicDepthBuffer,
    f = r.vertexTextures;
  let m = r.precision;
  const x = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function g(M) {
    return c.add(M), M === 0 ? "uv" : `uv${M}`;
  }
  function d(M, _, T, F, P) {
    const I = F.fog,
      X = P.geometry,
      V = M.isMeshStandardMaterial ? F.environment : null,
      ie = (M.isMeshStandardMaterial ? t : e).get(M.envMap || V),
      k = ie && ie.mapping === Pa ? ie.image.height : null,
      ae = x[M.type];
    M.precision !== null &&
      ((m = r.getMaxPrecision(M.precision)),
      m !== M.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          M.precision,
          "not supported, using",
          m,
          "instead.",
        ));
    const ce =
        X.morphAttributes.position ||
        X.morphAttributes.normal ||
        X.morphAttributes.color,
      H = ce !== void 0 ? ce.length : 0;
    let K = 0;
    X.morphAttributes.position !== void 0 && (K = 1),
      X.morphAttributes.normal !== void 0 && (K = 2),
      X.morphAttributes.color !== void 0 && (K = 3);
    let Q, B, te, fe;
    if (ae) {
      const rt = wn[ae];
      (Q = rt.vertexShader), (B = rt.fragmentShader);
    } else
      (Q = M.vertexShader),
        (B = M.fragmentShader),
        l.update(M),
        (te = l.getVertexShaderID(M)),
        (fe = l.getFragmentShaderID(M));
    const he = i.getRenderTarget(),
      de = i.state.buffers.depth.getReversed(),
      Qe = P.isInstancedMesh === !0,
      Oe = P.isBatchedMesh === !0,
      St = !!M.map,
      Xe = !!M.matcap,
      ze = !!ie,
      L = !!M.aoMap,
      Lt = !!M.lightMap,
      We = !!M.bumpMap,
      Ke = !!M.normalMap,
      Be = !!M.displacementMap,
      ht = !!M.emissiveMap,
      Fe = !!M.metalnessMap,
      D = !!M.roughnessMap,
      b = M.anisotropy > 0,
      q = M.clearcoat > 0,
      ne = M.dispersion > 0,
      se = M.iridescence > 0,
      ee = M.sheen > 0,
      Re = M.transmission > 0,
      pe = b && !!M.anisotropyMap,
      ve = q && !!M.clearcoatMap,
      et = q && !!M.clearcoatNormalMap,
      le = q && !!M.clearcoatRoughnessMap,
      Me = se && !!M.iridescenceMap,
      Le = se && !!M.iridescenceThicknessMap,
      ke = ee && !!M.sheenColorMap,
      be = ee && !!M.sheenRoughnessMap,
      tt = !!M.specularMap,
      Ye = !!M.specularColorMap,
      dt = !!M.specularIntensityMap,
      N = Re && !!M.transmissionMap,
      ge = Re && !!M.thicknessMap,
      J = !!M.gradientMap,
      re = !!M.alphaMap,
      Se = M.alphaTest > 0,
      Ee = !!M.alphaHash,
      qe = !!M.extensions;
    let gt = ni;
    M.toneMapped &&
      (he === null || he.isXRRenderTarget === !0) &&
      (gt = i.toneMapping);
    const Dt = {
      shaderID: ae,
      shaderType: M.type,
      shaderName: M.name,
      vertexShader: Q,
      fragmentShader: B,
      defines: M.defines,
      customVertexShaderID: te,
      customFragmentShaderID: fe,
      isRawShaderMaterial: M.isRawShaderMaterial === !0,
      glslVersion: M.glslVersion,
      precision: m,
      batching: Oe,
      batchingColor: Oe && P._colorsTexture !== null,
      instancing: Qe,
      instancingColor: Qe && P.instanceColor !== null,
      instancingMorph: Qe && P.morphTexture !== null,
      supportsVertexTextures: f,
      outputColorSpace:
        he === null
          ? i.outputColorSpace
          : he.isXRRenderTarget === !0
            ? he.texture.colorSpace
            : dr,
      alphaToCoverage: !!M.alphaToCoverage,
      map: St,
      matcap: Xe,
      envMap: ze,
      envMapMode: ze && ie.mapping,
      envMapCubeUVHeight: k,
      aoMap: L,
      lightMap: Lt,
      bumpMap: We,
      normalMap: Ke,
      displacementMap: f && Be,
      emissiveMap: ht,
      normalMapObjectSpace: Ke && M.normalMapType === um,
      normalMapTangentSpace: Ke && M.normalMapType === oh,
      metalnessMap: Fe,
      roughnessMap: D,
      anisotropy: b,
      anisotropyMap: pe,
      clearcoat: q,
      clearcoatMap: ve,
      clearcoatNormalMap: et,
      clearcoatRoughnessMap: le,
      dispersion: ne,
      iridescence: se,
      iridescenceMap: Me,
      iridescenceThicknessMap: Le,
      sheen: ee,
      sheenColorMap: ke,
      sheenRoughnessMap: be,
      specularMap: tt,
      specularColorMap: Ye,
      specularIntensityMap: dt,
      transmission: Re,
      transmissionMap: N,
      thicknessMap: ge,
      gradientMap: J,
      opaque:
        M.transparent === !1 && M.blending === ir && M.alphaToCoverage === !1,
      alphaMap: re,
      alphaTest: Se,
      alphaHash: Ee,
      combine: M.combine,
      mapUv: St && g(M.map.channel),
      aoMapUv: L && g(M.aoMap.channel),
      lightMapUv: Lt && g(M.lightMap.channel),
      bumpMapUv: We && g(M.bumpMap.channel),
      normalMapUv: Ke && g(M.normalMap.channel),
      displacementMapUv: Be && g(M.displacementMap.channel),
      emissiveMapUv: ht && g(M.emissiveMap.channel),
      metalnessMapUv: Fe && g(M.metalnessMap.channel),
      roughnessMapUv: D && g(M.roughnessMap.channel),
      anisotropyMapUv: pe && g(M.anisotropyMap.channel),
      clearcoatMapUv: ve && g(M.clearcoatMap.channel),
      clearcoatNormalMapUv: et && g(M.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: le && g(M.clearcoatRoughnessMap.channel),
      iridescenceMapUv: Me && g(M.iridescenceMap.channel),
      iridescenceThicknessMapUv: Le && g(M.iridescenceThicknessMap.channel),
      sheenColorMapUv: ke && g(M.sheenColorMap.channel),
      sheenRoughnessMapUv: be && g(M.sheenRoughnessMap.channel),
      specularMapUv: tt && g(M.specularMap.channel),
      specularColorMapUv: Ye && g(M.specularColorMap.channel),
      specularIntensityMapUv: dt && g(M.specularIntensityMap.channel),
      transmissionMapUv: N && g(M.transmissionMap.channel),
      thicknessMapUv: ge && g(M.thicknessMap.channel),
      alphaMapUv: re && g(M.alphaMap.channel),
      vertexTangents: !!X.attributes.tangent && (Ke || b),
      vertexColors: M.vertexColors,
      vertexAlphas:
        M.vertexColors === !0 &&
        !!X.attributes.color &&
        X.attributes.color.itemSize === 4,
      pointsUvs: P.isPoints === !0 && !!X.attributes.uv && (St || re),
      fog: !!I,
      useFog: M.fog === !0,
      fogExp2: !!I && I.isFogExp2,
      flatShading: M.flatShading === !0,
      sizeAttenuation: M.sizeAttenuation === !0,
      logarithmicDepthBuffer: h,
      reverseDepthBuffer: de,
      skinning: P.isSkinnedMesh === !0,
      morphTargets: X.morphAttributes.position !== void 0,
      morphNormals: X.morphAttributes.normal !== void 0,
      morphColors: X.morphAttributes.color !== void 0,
      morphTargetsCount: H,
      morphTextureStride: K,
      numDirLights: _.directional.length,
      numPointLights: _.point.length,
      numSpotLights: _.spot.length,
      numSpotLightMaps: _.spotLightMap.length,
      numRectAreaLights: _.rectArea.length,
      numHemiLights: _.hemi.length,
      numDirLightShadows: _.directionalShadowMap.length,
      numPointLightShadows: _.pointShadowMap.length,
      numSpotLightShadows: _.spotShadowMap.length,
      numSpotLightShadowsWithMaps: _.numSpotLightShadowsWithMaps,
      numLightProbes: _.numLightProbes,
      numClippingPlanes: a.numPlanes,
      numClipIntersection: a.numIntersection,
      dithering: M.dithering,
      shadowMapEnabled: i.shadowMap.enabled && T.length > 0,
      shadowMapType: i.shadowMap.type,
      toneMapping: gt,
      decodeVideoTexture:
        St &&
        M.map.isVideoTexture === !0 &&
        pt.getTransfer(M.map.colorSpace) === vt,
      decodeVideoTextureEmissive:
        ht &&
        M.emissiveMap.isVideoTexture === !0 &&
        pt.getTransfer(M.emissiveMap.colorSpace) === vt,
      premultipliedAlpha: M.premultipliedAlpha,
      doubleSided: M.side === zn,
      flipSided: M.side === Qt,
      useDepthPacking: M.depthPacking >= 0,
      depthPacking: M.depthPacking || 0,
      index0AttributeName: M.index0AttributeName,
      extensionClipCullDistance:
        qe &&
        M.extensions.clipCullDistance === !0 &&
        n.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw:
        ((qe && M.extensions.multiDraw === !0) || Oe) &&
        n.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: n.has(
        "KHR_parallel_shader_compile",
      ),
      customProgramCacheKey: M.customProgramCacheKey(),
    };
    return (
      (Dt.vertexUv1s = c.has(1)),
      (Dt.vertexUv2s = c.has(2)),
      (Dt.vertexUv3s = c.has(3)),
      c.clear(),
      Dt
    );
  }
  function p(M) {
    const _ = [];
    if (
      (M.shaderID
        ? _.push(M.shaderID)
        : (_.push(M.customVertexShaderID), _.push(M.customFragmentShaderID)),
      M.defines !== void 0)
    )
      for (const T in M.defines) _.push(T), _.push(M.defines[T]);
    return (
      M.isRawShaderMaterial === !1 &&
        (y(_, M), E(_, M), _.push(i.outputColorSpace)),
      _.push(M.customProgramCacheKey),
      _.join()
    );
  }
  function y(M, _) {
    M.push(_.precision),
      M.push(_.outputColorSpace),
      M.push(_.envMapMode),
      M.push(_.envMapCubeUVHeight),
      M.push(_.mapUv),
      M.push(_.alphaMapUv),
      M.push(_.lightMapUv),
      M.push(_.aoMapUv),
      M.push(_.bumpMapUv),
      M.push(_.normalMapUv),
      M.push(_.displacementMapUv),
      M.push(_.emissiveMapUv),
      M.push(_.metalnessMapUv),
      M.push(_.roughnessMapUv),
      M.push(_.anisotropyMapUv),
      M.push(_.clearcoatMapUv),
      M.push(_.clearcoatNormalMapUv),
      M.push(_.clearcoatRoughnessMapUv),
      M.push(_.iridescenceMapUv),
      M.push(_.iridescenceThicknessMapUv),
      M.push(_.sheenColorMapUv),
      M.push(_.sheenRoughnessMapUv),
      M.push(_.specularMapUv),
      M.push(_.specularColorMapUv),
      M.push(_.specularIntensityMapUv),
      M.push(_.transmissionMapUv),
      M.push(_.thicknessMapUv),
      M.push(_.combine),
      M.push(_.fogExp2),
      M.push(_.sizeAttenuation),
      M.push(_.morphTargetsCount),
      M.push(_.morphAttributeCount),
      M.push(_.numDirLights),
      M.push(_.numPointLights),
      M.push(_.numSpotLights),
      M.push(_.numSpotLightMaps),
      M.push(_.numHemiLights),
      M.push(_.numRectAreaLights),
      M.push(_.numDirLightShadows),
      M.push(_.numPointLightShadows),
      M.push(_.numSpotLightShadows),
      M.push(_.numSpotLightShadowsWithMaps),
      M.push(_.numLightProbes),
      M.push(_.shadowMapType),
      M.push(_.toneMapping),
      M.push(_.numClippingPlanes),
      M.push(_.numClipIntersection),
      M.push(_.depthPacking);
  }
  function E(M, _) {
    o.disableAll(),
      _.supportsVertexTextures && o.enable(0),
      _.instancing && o.enable(1),
      _.instancingColor && o.enable(2),
      _.instancingMorph && o.enable(3),
      _.matcap && o.enable(4),
      _.envMap && o.enable(5),
      _.normalMapObjectSpace && o.enable(6),
      _.normalMapTangentSpace && o.enable(7),
      _.clearcoat && o.enable(8),
      _.iridescence && o.enable(9),
      _.alphaTest && o.enable(10),
      _.vertexColors && o.enable(11),
      _.vertexAlphas && o.enable(12),
      _.vertexUv1s && o.enable(13),
      _.vertexUv2s && o.enable(14),
      _.vertexUv3s && o.enable(15),
      _.vertexTangents && o.enable(16),
      _.anisotropy && o.enable(17),
      _.alphaHash && o.enable(18),
      _.batching && o.enable(19),
      _.dispersion && o.enable(20),
      _.batchingColor && o.enable(21),
      M.push(o.mask),
      o.disableAll(),
      _.fog && o.enable(0),
      _.useFog && o.enable(1),
      _.flatShading && o.enable(2),
      _.logarithmicDepthBuffer && o.enable(3),
      _.reverseDepthBuffer && o.enable(4),
      _.skinning && o.enable(5),
      _.morphTargets && o.enable(6),
      _.morphNormals && o.enable(7),
      _.morphColors && o.enable(8),
      _.premultipliedAlpha && o.enable(9),
      _.shadowMapEnabled && o.enable(10),
      _.doubleSided && o.enable(11),
      _.flipSided && o.enable(12),
      _.useDepthPacking && o.enable(13),
      _.dithering && o.enable(14),
      _.transmission && o.enable(15),
      _.sheen && o.enable(16),
      _.opaque && o.enable(17),
      _.pointsUvs && o.enable(18),
      _.decodeVideoTexture && o.enable(19),
      _.decodeVideoTextureEmissive && o.enable(20),
      _.alphaToCoverage && o.enable(21),
      M.push(o.mask);
  }
  function v(M) {
    const _ = x[M.type];
    let T;
    if (_) {
      const F = wn[_];
      T = Hm.clone(F.uniforms);
    } else T = M.uniforms;
    return T;
  }
  function C(M, _) {
    let T;
    for (let F = 0, P = u.length; F < P; F++) {
      const I = u[F];
      if (I.cacheKey === _) {
        (T = I), ++T.usedTimes;
        break;
      }
    }
    return T === void 0 && ((T = new p1(i, _, M, s)), u.push(T)), T;
  }
  function A(M) {
    if (--M.usedTimes === 0) {
      const _ = u.indexOf(M);
      (u[_] = u[u.length - 1]), u.pop(), M.destroy();
    }
  }
  function S(M) {
    l.remove(M);
  }
  function R() {
    l.dispose();
  }
  return {
    getParameters: d,
    getProgramCacheKey: p,
    getUniforms: v,
    acquireProgram: C,
    releaseProgram: A,
    releaseShaderCache: S,
    programs: u,
    dispose: R,
  };
}
function v1() {
  let i = new WeakMap();
  function e(a) {
    return i.has(a);
  }
  function t(a) {
    let o = i.get(a);
    return o === void 0 && ((o = {}), i.set(a, o)), o;
  }
  function n(a) {
    i.delete(a);
  }
  function r(a, o, l) {
    i.get(a)[o] = l;
  }
  function s() {
    i = new WeakMap();
  }
  return { has: e, get: t, remove: n, update: r, dispose: s };
}
function E1(i, e) {
  return i.groupOrder !== e.groupOrder
    ? i.groupOrder - e.groupOrder
    : i.renderOrder !== e.renderOrder
      ? i.renderOrder - e.renderOrder
      : i.material.id !== e.material.id
        ? i.material.id - e.material.id
        : i.z !== e.z
          ? i.z - e.z
          : i.id - e.id;
}
function pf(i, e) {
  return i.groupOrder !== e.groupOrder
    ? i.groupOrder - e.groupOrder
    : i.renderOrder !== e.renderOrder
      ? i.renderOrder - e.renderOrder
      : i.z !== e.z
        ? e.z - i.z
        : i.id - e.id;
}
function mf() {
  const i = [];
  let e = 0;
  const t = [],
    n = [],
    r = [];
  function s() {
    (e = 0), (t.length = 0), (n.length = 0), (r.length = 0);
  }
  function a(h, f, m, x, g, d) {
    let p = i[e];
    return (
      p === void 0
        ? ((p = {
            id: h.id,
            object: h,
            geometry: f,
            material: m,
            groupOrder: x,
            renderOrder: h.renderOrder,
            z: g,
            group: d,
          }),
          (i[e] = p))
        : ((p.id = h.id),
          (p.object = h),
          (p.geometry = f),
          (p.material = m),
          (p.groupOrder = x),
          (p.renderOrder = h.renderOrder),
          (p.z = g),
          (p.group = d)),
      e++,
      p
    );
  }
  function o(h, f, m, x, g, d) {
    const p = a(h, f, m, x, g, d);
    m.transmission > 0
      ? n.push(p)
      : m.transparent === !0
        ? r.push(p)
        : t.push(p);
  }
  function l(h, f, m, x, g, d) {
    const p = a(h, f, m, x, g, d);
    m.transmission > 0
      ? n.unshift(p)
      : m.transparent === !0
        ? r.unshift(p)
        : t.unshift(p);
  }
  function c(h, f) {
    t.length > 1 && t.sort(h || E1),
      n.length > 1 && n.sort(f || pf),
      r.length > 1 && r.sort(f || pf);
  }
  function u() {
    for (let h = e, f = i.length; h < f; h++) {
      const m = i[h];
      if (m.id === null) break;
      (m.id = null),
        (m.object = null),
        (m.geometry = null),
        (m.material = null),
        (m.group = null);
    }
  }
  return {
    opaque: t,
    transmissive: n,
    transparent: r,
    init: s,
    push: o,
    unshift: l,
    finish: u,
    sort: c,
  };
}
function y1() {
  let i = new WeakMap();
  function e(n, r) {
    const s = i.get(n);
    let a;
    return (
      s === void 0
        ? ((a = new mf()), i.set(n, [a]))
        : r >= s.length
          ? ((a = new mf()), s.push(a))
          : (a = s[r]),
      a
    );
  }
  function t() {
    i = new WeakMap();
  }
  return { get: e, dispose: t };
}
function S1() {
  const i = {};
  return {
    get: function (e) {
      if (i[e.id] !== void 0) return i[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new W(), color: new ut() };
          break;
        case "SpotLight":
          t = {
            position: new W(),
            direction: new W(),
            color: new ut(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new W(), color: new ut(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = { direction: new W(), skyColor: new ut(), groundColor: new ut() };
          break;
        case "RectAreaLight":
          t = {
            color: new ut(),
            position: new W(),
            halfWidth: new W(),
            halfHeight: new W(),
          };
          break;
      }
      return (i[e.id] = t), t;
    },
  };
}
function M1() {
  const i = {};
  return {
    get: function (e) {
      if (i[e.id] !== void 0) return i[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new it(),
          };
          break;
        case "SpotLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new it(),
          };
          break;
        case "PointLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new it(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (i[e.id] = t), t;
    },
  };
}
let A1 = 0;
function b1(i, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (i.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (i.map ? 1 : 0)
  );
}
function T1(i) {
  const e = new S1(),
    t = M1(),
    n = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let c = 0; c < 9; c++) n.probe.push(new W());
  const r = new W(),
    s = new Tt(),
    a = new Tt();
  function o(c) {
    let u = 0,
      h = 0,
      f = 0;
    for (let M = 0; M < 9; M++) n.probe[M].set(0, 0, 0);
    let m = 0,
      x = 0,
      g = 0,
      d = 0,
      p = 0,
      y = 0,
      E = 0,
      v = 0,
      C = 0,
      A = 0,
      S = 0;
    c.sort(b1);
    for (let M = 0, _ = c.length; M < _; M++) {
      const T = c[M],
        F = T.color,
        P = T.intensity,
        I = T.distance,
        X = T.shadow && T.shadow.map ? T.shadow.map.texture : null;
      if (T.isAmbientLight) (u += F.r * P), (h += F.g * P), (f += F.b * P);
      else if (T.isLightProbe) {
        for (let V = 0; V < 9; V++)
          n.probe[V].addScaledVector(T.sh.coefficients[V], P);
        S++;
      } else if (T.isDirectionalLight) {
        const V = e.get(T);
        if ((V.color.copy(T.color).multiplyScalar(T.intensity), T.castShadow)) {
          const ie = T.shadow,
            k = t.get(T);
          (k.shadowIntensity = ie.intensity),
            (k.shadowBias = ie.bias),
            (k.shadowNormalBias = ie.normalBias),
            (k.shadowRadius = ie.radius),
            (k.shadowMapSize = ie.mapSize),
            (n.directionalShadow[m] = k),
            (n.directionalShadowMap[m] = X),
            (n.directionalShadowMatrix[m] = T.shadow.matrix),
            y++;
        }
        (n.directional[m] = V), m++;
      } else if (T.isSpotLight) {
        const V = e.get(T);
        V.position.setFromMatrixPosition(T.matrixWorld),
          V.color.copy(F).multiplyScalar(P),
          (V.distance = I),
          (V.coneCos = Math.cos(T.angle)),
          (V.penumbraCos = Math.cos(T.angle * (1 - T.penumbra))),
          (V.decay = T.decay),
          (n.spot[g] = V);
        const ie = T.shadow;
        if (
          (T.map &&
            ((n.spotLightMap[C] = T.map),
            C++,
            ie.updateMatrices(T),
            T.castShadow && A++),
          (n.spotLightMatrix[g] = ie.matrix),
          T.castShadow)
        ) {
          const k = t.get(T);
          (k.shadowIntensity = ie.intensity),
            (k.shadowBias = ie.bias),
            (k.shadowNormalBias = ie.normalBias),
            (k.shadowRadius = ie.radius),
            (k.shadowMapSize = ie.mapSize),
            (n.spotShadow[g] = k),
            (n.spotShadowMap[g] = X),
            v++;
        }
        g++;
      } else if (T.isRectAreaLight) {
        const V = e.get(T);
        V.color.copy(F).multiplyScalar(P),
          V.halfWidth.set(T.width * 0.5, 0, 0),
          V.halfHeight.set(0, T.height * 0.5, 0),
          (n.rectArea[d] = V),
          d++;
      } else if (T.isPointLight) {
        const V = e.get(T);
        if (
          (V.color.copy(T.color).multiplyScalar(T.intensity),
          (V.distance = T.distance),
          (V.decay = T.decay),
          T.castShadow)
        ) {
          const ie = T.shadow,
            k = t.get(T);
          (k.shadowIntensity = ie.intensity),
            (k.shadowBias = ie.bias),
            (k.shadowNormalBias = ie.normalBias),
            (k.shadowRadius = ie.radius),
            (k.shadowMapSize = ie.mapSize),
            (k.shadowCameraNear = ie.camera.near),
            (k.shadowCameraFar = ie.camera.far),
            (n.pointShadow[x] = k),
            (n.pointShadowMap[x] = X),
            (n.pointShadowMatrix[x] = T.shadow.matrix),
            E++;
        }
        (n.point[x] = V), x++;
      } else if (T.isHemisphereLight) {
        const V = e.get(T);
        V.skyColor.copy(T.color).multiplyScalar(P),
          V.groundColor.copy(T.groundColor).multiplyScalar(P),
          (n.hemi[p] = V),
          p++;
      }
    }
    d > 0 &&
      (i.has("OES_texture_float_linear") === !0
        ? ((n.rectAreaLTC1 = ye.LTC_FLOAT_1), (n.rectAreaLTC2 = ye.LTC_FLOAT_2))
        : ((n.rectAreaLTC1 = ye.LTC_HALF_1), (n.rectAreaLTC2 = ye.LTC_HALF_2))),
      (n.ambient[0] = u),
      (n.ambient[1] = h),
      (n.ambient[2] = f);
    const R = n.hash;
    (R.directionalLength !== m ||
      R.pointLength !== x ||
      R.spotLength !== g ||
      R.rectAreaLength !== d ||
      R.hemiLength !== p ||
      R.numDirectionalShadows !== y ||
      R.numPointShadows !== E ||
      R.numSpotShadows !== v ||
      R.numSpotMaps !== C ||
      R.numLightProbes !== S) &&
      ((n.directional.length = m),
      (n.spot.length = g),
      (n.rectArea.length = d),
      (n.point.length = x),
      (n.hemi.length = p),
      (n.directionalShadow.length = y),
      (n.directionalShadowMap.length = y),
      (n.pointShadow.length = E),
      (n.pointShadowMap.length = E),
      (n.spotShadow.length = v),
      (n.spotShadowMap.length = v),
      (n.directionalShadowMatrix.length = y),
      (n.pointShadowMatrix.length = E),
      (n.spotLightMatrix.length = v + C - A),
      (n.spotLightMap.length = C),
      (n.numSpotLightShadowsWithMaps = A),
      (n.numLightProbes = S),
      (R.directionalLength = m),
      (R.pointLength = x),
      (R.spotLength = g),
      (R.rectAreaLength = d),
      (R.hemiLength = p),
      (R.numDirectionalShadows = y),
      (R.numPointShadows = E),
      (R.numSpotShadows = v),
      (R.numSpotMaps = C),
      (R.numLightProbes = S),
      (n.version = A1++));
  }
  function l(c, u) {
    let h = 0,
      f = 0,
      m = 0,
      x = 0,
      g = 0;
    const d = u.matrixWorldInverse;
    for (let p = 0, y = c.length; p < y; p++) {
      const E = c[p];
      if (E.isDirectionalLight) {
        const v = n.directional[h];
        v.direction.setFromMatrixPosition(E.matrixWorld),
          r.setFromMatrixPosition(E.target.matrixWorld),
          v.direction.sub(r),
          v.direction.transformDirection(d),
          h++;
      } else if (E.isSpotLight) {
        const v = n.spot[m];
        v.position.setFromMatrixPosition(E.matrixWorld),
          v.position.applyMatrix4(d),
          v.direction.setFromMatrixPosition(E.matrixWorld),
          r.setFromMatrixPosition(E.target.matrixWorld),
          v.direction.sub(r),
          v.direction.transformDirection(d),
          m++;
      } else if (E.isRectAreaLight) {
        const v = n.rectArea[x];
        v.position.setFromMatrixPosition(E.matrixWorld),
          v.position.applyMatrix4(d),
          a.identity(),
          s.copy(E.matrixWorld),
          s.premultiply(d),
          a.extractRotation(s),
          v.halfWidth.set(E.width * 0.5, 0, 0),
          v.halfHeight.set(0, E.height * 0.5, 0),
          v.halfWidth.applyMatrix4(a),
          v.halfHeight.applyMatrix4(a),
          x++;
      } else if (E.isPointLight) {
        const v = n.point[f];
        v.position.setFromMatrixPosition(E.matrixWorld),
          v.position.applyMatrix4(d),
          f++;
      } else if (E.isHemisphereLight) {
        const v = n.hemi[g];
        v.direction.setFromMatrixPosition(E.matrixWorld),
          v.direction.transformDirection(d),
          g++;
      }
    }
  }
  return { setup: o, setupView: l, state: n };
}
function xf(i) {
  const e = new T1(i),
    t = [],
    n = [];
  function r(u) {
    (c.camera = u), (t.length = 0), (n.length = 0);
  }
  function s(u) {
    t.push(u);
  }
  function a(u) {
    n.push(u);
  }
  function o() {
    e.setup(t);
  }
  function l(u) {
    e.setupView(t, u);
  }
  const c = {
    lightsArray: t,
    shadowsArray: n,
    camera: null,
    lights: e,
    transmissionRenderTarget: {},
  };
  return {
    init: r,
    state: c,
    setupLights: o,
    setupLightsView: l,
    pushLight: s,
    pushShadow: a,
  };
}
function C1(i) {
  let e = new WeakMap();
  function t(r, s = 0) {
    const a = e.get(r);
    let o;
    return (
      a === void 0
        ? ((o = new xf(i)), e.set(r, [o]))
        : s >= a.length
          ? ((o = new xf(i)), a.push(o))
          : (o = a[s]),
      o
    );
  }
  function n() {
    e = new WeakMap();
  }
  return { get: t, dispose: n };
}
const w1 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  R1 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function D1(i, e, t) {
  let n = new Jc();
  const r = new it(),
    s = new it(),
    a = new yt(),
    o = new Jm({ depthPacking: lm }),
    l = new Qm(),
    c = {},
    u = t.maxTextureSize,
    h = { [si]: Qt, [Qt]: si, [zn]: zn },
    f = new ai({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new it() },
        radius: { value: 4 },
      },
      vertexShader: w1,
      fragmentShader: R1,
    }),
    m = f.clone();
  m.defines.HORIZONTAL_PASS = 1;
  const x = new bn();
  x.setAttribute(
    "position",
    new An(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3),
  );
  const g = new Vn(x, f),
    d = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = jf);
  let p = this.type;
  this.render = function (A, S, R) {
    if (
      d.enabled === !1 ||
      (d.autoUpdate === !1 && d.needsUpdate === !1) ||
      A.length === 0
    )
      return;
    const M = i.getRenderTarget(),
      _ = i.getActiveCubeFace(),
      T = i.getActiveMipmapLevel(),
      F = i.state;
    F.setBlending(ti),
      F.buffers.color.setClear(1, 1, 1, 1),
      F.buffers.depth.setTest(!0),
      F.setScissorTest(!1);
    const P = p !== On && this.type === On,
      I = p === On && this.type !== On;
    for (let X = 0, V = A.length; X < V; X++) {
      const ie = A[X],
        k = ie.shadow;
      if (k === void 0) {
        console.warn("THREE.WebGLShadowMap:", ie, "has no shadow.");
        continue;
      }
      if (k.autoUpdate === !1 && k.needsUpdate === !1) continue;
      r.copy(k.mapSize);
      const ae = k.getFrameExtents();
      if (
        (r.multiply(ae),
        s.copy(k.mapSize),
        (r.x > u || r.y > u) &&
          (r.x > u &&
            ((s.x = Math.floor(u / ae.x)),
            (r.x = s.x * ae.x),
            (k.mapSize.x = s.x)),
          r.y > u &&
            ((s.y = Math.floor(u / ae.y)),
            (r.y = s.y * ae.y),
            (k.mapSize.y = s.y))),
        k.map === null || P === !0 || I === !0)
      ) {
        const H = this.type !== On ? { minFilter: Mn, magFilter: Mn } : {};
        k.map !== null && k.map.dispose(),
          (k.map = new Ci(r.x, r.y, H)),
          (k.map.texture.name = ie.name + ".shadowMap"),
          k.camera.updateProjectionMatrix();
      }
      i.setRenderTarget(k.map), i.clear();
      const ce = k.getViewportCount();
      for (let H = 0; H < ce; H++) {
        const K = k.getViewport(H);
        a.set(s.x * K.x, s.y * K.y, s.x * K.z, s.y * K.w),
          F.viewport(a),
          k.updateMatrices(ie, H),
          (n = k.getFrustum()),
          v(S, R, k.camera, ie, this.type);
      }
      k.isPointLightShadow !== !0 && this.type === On && y(k, R),
        (k.needsUpdate = !1);
    }
    (p = this.type), (d.needsUpdate = !1), i.setRenderTarget(M, _, T);
  };
  function y(A, S) {
    const R = e.update(g);
    f.defines.VSM_SAMPLES !== A.blurSamples &&
      ((f.defines.VSM_SAMPLES = A.blurSamples),
      (m.defines.VSM_SAMPLES = A.blurSamples),
      (f.needsUpdate = !0),
      (m.needsUpdate = !0)),
      A.mapPass === null && (A.mapPass = new Ci(r.x, r.y)),
      (f.uniforms.shadow_pass.value = A.map.texture),
      (f.uniforms.resolution.value = A.mapSize),
      (f.uniforms.radius.value = A.radius),
      i.setRenderTarget(A.mapPass),
      i.clear(),
      i.renderBufferDirect(S, null, R, f, g, null),
      (m.uniforms.shadow_pass.value = A.mapPass.texture),
      (m.uniforms.resolution.value = A.mapSize),
      (m.uniforms.radius.value = A.radius),
      i.setRenderTarget(A.map),
      i.clear(),
      i.renderBufferDirect(S, null, R, m, g, null);
  }
  function E(A, S, R, M) {
    let _ = null;
    const T =
      R.isPointLight === !0 ? A.customDistanceMaterial : A.customDepthMaterial;
    if (T !== void 0) _ = T;
    else if (
      ((_ = R.isPointLight === !0 ? l : o),
      (i.localClippingEnabled &&
        S.clipShadows === !0 &&
        Array.isArray(S.clippingPlanes) &&
        S.clippingPlanes.length !== 0) ||
        (S.displacementMap && S.displacementScale !== 0) ||
        (S.alphaMap && S.alphaTest > 0) ||
        (S.map && S.alphaTest > 0))
    ) {
      const F = _.uuid,
        P = S.uuid;
      let I = c[F];
      I === void 0 && ((I = {}), (c[F] = I));
      let X = I[P];
      X === void 0 &&
        ((X = _.clone()), (I[P] = X), S.addEventListener("dispose", C)),
        (_ = X);
    }
    if (
      ((_.visible = S.visible),
      (_.wireframe = S.wireframe),
      M === On
        ? (_.side = S.shadowSide !== null ? S.shadowSide : S.side)
        : (_.side = S.shadowSide !== null ? S.shadowSide : h[S.side]),
      (_.alphaMap = S.alphaMap),
      (_.alphaTest = S.alphaTest),
      (_.map = S.map),
      (_.clipShadows = S.clipShadows),
      (_.clippingPlanes = S.clippingPlanes),
      (_.clipIntersection = S.clipIntersection),
      (_.displacementMap = S.displacementMap),
      (_.displacementScale = S.displacementScale),
      (_.displacementBias = S.displacementBias),
      (_.wireframeLinewidth = S.wireframeLinewidth),
      (_.linewidth = S.linewidth),
      R.isPointLight === !0 && _.isMeshDistanceMaterial === !0)
    ) {
      const F = i.properties.get(_);
      F.light = R;
    }
    return _;
  }
  function v(A, S, R, M, _) {
    if (A.visible === !1) return;
    if (
      A.layers.test(S.layers) &&
      (A.isMesh || A.isLine || A.isPoints) &&
      (A.castShadow || (A.receiveShadow && _ === On)) &&
      (!A.frustumCulled || n.intersectsObject(A))
    ) {
      A.modelViewMatrix.multiplyMatrices(R.matrixWorldInverse, A.matrixWorld);
      const P = e.update(A),
        I = A.material;
      if (Array.isArray(I)) {
        const X = P.groups;
        for (let V = 0, ie = X.length; V < ie; V++) {
          const k = X[V],
            ae = I[k.materialIndex];
          if (ae && ae.visible) {
            const ce = E(A, ae, M, _);
            A.onBeforeShadow(i, A, S, R, P, ce, k),
              i.renderBufferDirect(R, null, P, ce, A, k),
              A.onAfterShadow(i, A, S, R, P, ce, k);
          }
        }
      } else if (I.visible) {
        const X = E(A, I, M, _);
        A.onBeforeShadow(i, A, S, R, P, X, null),
          i.renderBufferDirect(R, null, P, X, A, null),
          A.onAfterShadow(i, A, S, R, P, X, null);
      }
    }
    const F = A.children;
    for (let P = 0, I = F.length; P < I; P++) v(F[P], S, R, M, _);
  }
  function C(A) {
    A.target.removeEventListener("dispose", C);
    for (const R in c) {
      const M = c[R],
        _ = A.target.uuid;
      _ in M && (M[_].dispose(), delete M[_]);
    }
  }
}
const P1 = {
  [Vo]: Go,
  [Wo]: Yo,
  [Xo]: $o,
  [cr]: qo,
  [Go]: Vo,
  [Yo]: Wo,
  [$o]: Xo,
  [qo]: cr,
};
function F1(i, e) {
  function t() {
    let N = !1;
    const ge = new yt();
    let J = null;
    const re = new yt(0, 0, 0, 0);
    return {
      setMask: function (Se) {
        J !== Se && !N && (i.colorMask(Se, Se, Se, Se), (J = Se));
      },
      setLocked: function (Se) {
        N = Se;
      },
      setClear: function (Se, Ee, qe, gt, Dt) {
        Dt === !0 && ((Se *= gt), (Ee *= gt), (qe *= gt)),
          ge.set(Se, Ee, qe, gt),
          re.equals(ge) === !1 && (i.clearColor(Se, Ee, qe, gt), re.copy(ge));
      },
      reset: function () {
        (N = !1), (J = null), re.set(-1, 0, 0, 0);
      },
    };
  }
  function n() {
    let N = !1,
      ge = !1,
      J = null,
      re = null,
      Se = null;
    return {
      setReversed: function (Ee) {
        if (ge !== Ee) {
          const qe = e.get("EXT_clip_control");
          ge
            ? qe.clipControlEXT(qe.LOWER_LEFT_EXT, qe.ZERO_TO_ONE_EXT)
            : qe.clipControlEXT(qe.LOWER_LEFT_EXT, qe.NEGATIVE_ONE_TO_ONE_EXT);
          const gt = Se;
          (Se = null), this.setClear(gt);
        }
        ge = Ee;
      },
      getReversed: function () {
        return ge;
      },
      setTest: function (Ee) {
        Ee ? he(i.DEPTH_TEST) : de(i.DEPTH_TEST);
      },
      setMask: function (Ee) {
        J !== Ee && !N && (i.depthMask(Ee), (J = Ee));
      },
      setFunc: function (Ee) {
        if ((ge && (Ee = P1[Ee]), re !== Ee)) {
          switch (Ee) {
            case Vo:
              i.depthFunc(i.NEVER);
              break;
            case Go:
              i.depthFunc(i.ALWAYS);
              break;
            case Wo:
              i.depthFunc(i.LESS);
              break;
            case cr:
              i.depthFunc(i.LEQUAL);
              break;
            case Xo:
              i.depthFunc(i.EQUAL);
              break;
            case qo:
              i.depthFunc(i.GEQUAL);
              break;
            case Yo:
              i.depthFunc(i.GREATER);
              break;
            case $o:
              i.depthFunc(i.NOTEQUAL);
              break;
            default:
              i.depthFunc(i.LEQUAL);
          }
          re = Ee;
        }
      },
      setLocked: function (Ee) {
        N = Ee;
      },
      setClear: function (Ee) {
        Se !== Ee && (ge && (Ee = 1 - Ee), i.clearDepth(Ee), (Se = Ee));
      },
      reset: function () {
        (N = !1), (J = null), (re = null), (Se = null), (ge = !1);
      },
    };
  }
  function r() {
    let N = !1,
      ge = null,
      J = null,
      re = null,
      Se = null,
      Ee = null,
      qe = null,
      gt = null,
      Dt = null;
    return {
      setTest: function (rt) {
        N || (rt ? he(i.STENCIL_TEST) : de(i.STENCIL_TEST));
      },
      setMask: function (rt) {
        ge !== rt && !N && (i.stencilMask(rt), (ge = rt));
      },
      setFunc: function (rt, Vt, nn) {
        (J !== rt || re !== Vt || Se !== nn) &&
          (i.stencilFunc(rt, Vt, nn), (J = rt), (re = Vt), (Se = nn));
      },
      setOp: function (rt, Vt, nn) {
        (Ee !== rt || qe !== Vt || gt !== nn) &&
          (i.stencilOp(rt, Vt, nn), (Ee = rt), (qe = Vt), (gt = nn));
      },
      setLocked: function (rt) {
        N = rt;
      },
      setClear: function (rt) {
        Dt !== rt && (i.clearStencil(rt), (Dt = rt));
      },
      reset: function () {
        (N = !1),
          (ge = null),
          (J = null),
          (re = null),
          (Se = null),
          (Ee = null),
          (qe = null),
          (gt = null),
          (Dt = null);
      },
    };
  }
  const s = new t(),
    a = new n(),
    o = new r(),
    l = new WeakMap(),
    c = new WeakMap();
  let u = {},
    h = {},
    f = new WeakMap(),
    m = [],
    x = null,
    g = !1,
    d = null,
    p = null,
    y = null,
    E = null,
    v = null,
    C = null,
    A = null,
    S = new ut(0, 0, 0),
    R = 0,
    M = !1,
    _ = null,
    T = null,
    F = null,
    P = null,
    I = null;
  const X = i.getParameter(i.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let V = !1,
    ie = 0;
  const k = i.getParameter(i.VERSION);
  k.indexOf("WebGL") !== -1
    ? ((ie = parseFloat(/^WebGL (\d)/.exec(k)[1])), (V = ie >= 1))
    : k.indexOf("OpenGL ES") !== -1 &&
      ((ie = parseFloat(/^OpenGL ES (\d)/.exec(k)[1])), (V = ie >= 2));
  let ae = null,
    ce = {};
  const H = i.getParameter(i.SCISSOR_BOX),
    K = i.getParameter(i.VIEWPORT),
    Q = new yt().fromArray(H),
    B = new yt().fromArray(K);
  function te(N, ge, J, re) {
    const Se = new Uint8Array(4),
      Ee = i.createTexture();
    i.bindTexture(N, Ee),
      i.texParameteri(N, i.TEXTURE_MIN_FILTER, i.NEAREST),
      i.texParameteri(N, i.TEXTURE_MAG_FILTER, i.NEAREST);
    for (let qe = 0; qe < J; qe++)
      N === i.TEXTURE_3D || N === i.TEXTURE_2D_ARRAY
        ? i.texImage3D(ge, 0, i.RGBA, 1, 1, re, 0, i.RGBA, i.UNSIGNED_BYTE, Se)
        : i.texImage2D(
            ge + qe,
            0,
            i.RGBA,
            1,
            1,
            0,
            i.RGBA,
            i.UNSIGNED_BYTE,
            Se,
          );
    return Ee;
  }
  const fe = {};
  (fe[i.TEXTURE_2D] = te(i.TEXTURE_2D, i.TEXTURE_2D, 1)),
    (fe[i.TEXTURE_CUBE_MAP] = te(
      i.TEXTURE_CUBE_MAP,
      i.TEXTURE_CUBE_MAP_POSITIVE_X,
      6,
    )),
    (fe[i.TEXTURE_2D_ARRAY] = te(i.TEXTURE_2D_ARRAY, i.TEXTURE_2D_ARRAY, 1, 1)),
    (fe[i.TEXTURE_3D] = te(i.TEXTURE_3D, i.TEXTURE_3D, 1, 1)),
    s.setClear(0, 0, 0, 1),
    a.setClear(1),
    o.setClear(0),
    he(i.DEPTH_TEST),
    a.setFunc(cr),
    We(!1),
    Ke(pu),
    he(i.CULL_FACE),
    L(ti);
  function he(N) {
    u[N] !== !0 && (i.enable(N), (u[N] = !0));
  }
  function de(N) {
    u[N] !== !1 && (i.disable(N), (u[N] = !1));
  }
  function Qe(N, ge) {
    return h[N] !== ge
      ? (i.bindFramebuffer(N, ge),
        (h[N] = ge),
        N === i.DRAW_FRAMEBUFFER && (h[i.FRAMEBUFFER] = ge),
        N === i.FRAMEBUFFER && (h[i.DRAW_FRAMEBUFFER] = ge),
        !0)
      : !1;
  }
  function Oe(N, ge) {
    let J = m,
      re = !1;
    if (N) {
      (J = f.get(ge)), J === void 0 && ((J = []), f.set(ge, J));
      const Se = N.textures;
      if (J.length !== Se.length || J[0] !== i.COLOR_ATTACHMENT0) {
        for (let Ee = 0, qe = Se.length; Ee < qe; Ee++)
          J[Ee] = i.COLOR_ATTACHMENT0 + Ee;
        (J.length = Se.length), (re = !0);
      }
    } else J[0] !== i.BACK && ((J[0] = i.BACK), (re = !0));
    re && i.drawBuffers(J);
  }
  function St(N) {
    return x !== N ? (i.useProgram(N), (x = N), !0) : !1;
  }
  const Xe = {
    [vi]: i.FUNC_ADD,
    [Up]: i.FUNC_SUBTRACT,
    [Ip]: i.FUNC_REVERSE_SUBTRACT,
  };
  (Xe[Np] = i.MIN), (Xe[Op] = i.MAX);
  const ze = {
    [zp]: i.ZERO,
    [kp]: i.ONE,
    [Hp]: i.SRC_COLOR,
    [ko]: i.SRC_ALPHA,
    [Yp]: i.SRC_ALPHA_SATURATE,
    [Xp]: i.DST_COLOR,
    [Gp]: i.DST_ALPHA,
    [Vp]: i.ONE_MINUS_SRC_COLOR,
    [Ho]: i.ONE_MINUS_SRC_ALPHA,
    [qp]: i.ONE_MINUS_DST_COLOR,
    [Wp]: i.ONE_MINUS_DST_ALPHA,
    [$p]: i.CONSTANT_COLOR,
    [jp]: i.ONE_MINUS_CONSTANT_COLOR,
    [Kp]: i.CONSTANT_ALPHA,
    [Zp]: i.ONE_MINUS_CONSTANT_ALPHA,
  };
  function L(N, ge, J, re, Se, Ee, qe, gt, Dt, rt) {
    if (N === ti) {
      g === !0 && (de(i.BLEND), (g = !1));
      return;
    }
    if ((g === !1 && (he(i.BLEND), (g = !0)), N !== Lp)) {
      if (N !== d || rt !== M) {
        if (
          ((p !== vi || v !== vi) &&
            (i.blendEquation(i.FUNC_ADD), (p = vi), (v = vi)),
          rt)
        )
          switch (N) {
            case ir:
              i.blendFuncSeparate(
                i.ONE,
                i.ONE_MINUS_SRC_ALPHA,
                i.ONE,
                i.ONE_MINUS_SRC_ALPHA,
              );
              break;
            case mu:
              i.blendFunc(i.ONE, i.ONE);
              break;
            case xu:
              i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
              break;
            case gu:
              i.blendFuncSeparate(i.ZERO, i.SRC_COLOR, i.ZERO, i.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", N);
              break;
          }
        else
          switch (N) {
            case ir:
              i.blendFuncSeparate(
                i.SRC_ALPHA,
                i.ONE_MINUS_SRC_ALPHA,
                i.ONE,
                i.ONE_MINUS_SRC_ALPHA,
              );
              break;
            case mu:
              i.blendFunc(i.SRC_ALPHA, i.ONE);
              break;
            case xu:
              i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
              break;
            case gu:
              i.blendFunc(i.ZERO, i.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", N);
              break;
          }
        (y = null),
          (E = null),
          (C = null),
          (A = null),
          S.set(0, 0, 0),
          (R = 0),
          (d = N),
          (M = rt);
      }
      return;
    }
    (Se = Se || ge),
      (Ee = Ee || J),
      (qe = qe || re),
      (ge !== p || Se !== v) &&
        (i.blendEquationSeparate(Xe[ge], Xe[Se]), (p = ge), (v = Se)),
      (J !== y || re !== E || Ee !== C || qe !== A) &&
        (i.blendFuncSeparate(ze[J], ze[re], ze[Ee], ze[qe]),
        (y = J),
        (E = re),
        (C = Ee),
        (A = qe)),
      (gt.equals(S) === !1 || Dt !== R) &&
        (i.blendColor(gt.r, gt.g, gt.b, Dt), S.copy(gt), (R = Dt)),
      (d = N),
      (M = !1);
  }
  function Lt(N, ge) {
    N.side === zn ? de(i.CULL_FACE) : he(i.CULL_FACE);
    let J = N.side === Qt;
    ge && (J = !J),
      We(J),
      N.blending === ir && N.transparent === !1
        ? L(ti)
        : L(
            N.blending,
            N.blendEquation,
            N.blendSrc,
            N.blendDst,
            N.blendEquationAlpha,
            N.blendSrcAlpha,
            N.blendDstAlpha,
            N.blendColor,
            N.blendAlpha,
            N.premultipliedAlpha,
          ),
      a.setFunc(N.depthFunc),
      a.setTest(N.depthTest),
      a.setMask(N.depthWrite),
      s.setMask(N.colorWrite);
    const re = N.stencilWrite;
    o.setTest(re),
      re &&
        (o.setMask(N.stencilWriteMask),
        o.setFunc(N.stencilFunc, N.stencilRef, N.stencilFuncMask),
        o.setOp(N.stencilFail, N.stencilZFail, N.stencilZPass)),
      ht(N.polygonOffset, N.polygonOffsetFactor, N.polygonOffsetUnits),
      N.alphaToCoverage === !0
        ? he(i.SAMPLE_ALPHA_TO_COVERAGE)
        : de(i.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function We(N) {
    _ !== N && (N ? i.frontFace(i.CW) : i.frontFace(i.CCW), (_ = N));
  }
  function Ke(N) {
    N !== Pp
      ? (he(i.CULL_FACE),
        N !== T &&
          (N === pu
            ? i.cullFace(i.BACK)
            : N === Fp
              ? i.cullFace(i.FRONT)
              : i.cullFace(i.FRONT_AND_BACK)))
      : de(i.CULL_FACE),
      (T = N);
  }
  function Be(N) {
    N !== F && (V && i.lineWidth(N), (F = N));
  }
  function ht(N, ge, J) {
    N
      ? (he(i.POLYGON_OFFSET_FILL),
        (P !== ge || I !== J) && (i.polygonOffset(ge, J), (P = ge), (I = J)))
      : de(i.POLYGON_OFFSET_FILL);
  }
  function Fe(N) {
    N ? he(i.SCISSOR_TEST) : de(i.SCISSOR_TEST);
  }
  function D(N) {
    N === void 0 && (N = i.TEXTURE0 + X - 1),
      ae !== N && (i.activeTexture(N), (ae = N));
  }
  function b(N, ge, J) {
    J === void 0 && (ae === null ? (J = i.TEXTURE0 + X - 1) : (J = ae));
    let re = ce[J];
    re === void 0 && ((re = { type: void 0, texture: void 0 }), (ce[J] = re)),
      (re.type !== N || re.texture !== ge) &&
        (ae !== J && (i.activeTexture(J), (ae = J)),
        i.bindTexture(N, ge || fe[N]),
        (re.type = N),
        (re.texture = ge));
  }
  function q() {
    const N = ce[ae];
    N !== void 0 &&
      N.type !== void 0 &&
      (i.bindTexture(N.type, null), (N.type = void 0), (N.texture = void 0));
  }
  function ne() {
    try {
      i.compressedTexImage2D.apply(i, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function se() {
    try {
      i.compressedTexImage3D.apply(i, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function ee() {
    try {
      i.texSubImage2D.apply(i, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function Re() {
    try {
      i.texSubImage3D.apply(i, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function pe() {
    try {
      i.compressedTexSubImage2D.apply(i, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function ve() {
    try {
      i.compressedTexSubImage3D.apply(i, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function et() {
    try {
      i.texStorage2D.apply(i, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function le() {
    try {
      i.texStorage3D.apply(i, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function Me() {
    try {
      i.texImage2D.apply(i, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function Le() {
    try {
      i.texImage3D.apply(i, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function ke(N) {
    Q.equals(N) === !1 && (i.scissor(N.x, N.y, N.z, N.w), Q.copy(N));
  }
  function be(N) {
    B.equals(N) === !1 && (i.viewport(N.x, N.y, N.z, N.w), B.copy(N));
  }
  function tt(N, ge) {
    let J = c.get(ge);
    J === void 0 && ((J = new WeakMap()), c.set(ge, J));
    let re = J.get(N);
    re === void 0 && ((re = i.getUniformBlockIndex(ge, N.name)), J.set(N, re));
  }
  function Ye(N, ge) {
    const re = c.get(ge).get(N);
    l.get(ge) !== re &&
      (i.uniformBlockBinding(ge, re, N.__bindingPointIndex), l.set(ge, re));
  }
  function dt() {
    i.disable(i.BLEND),
      i.disable(i.CULL_FACE),
      i.disable(i.DEPTH_TEST),
      i.disable(i.POLYGON_OFFSET_FILL),
      i.disable(i.SCISSOR_TEST),
      i.disable(i.STENCIL_TEST),
      i.disable(i.SAMPLE_ALPHA_TO_COVERAGE),
      i.blendEquation(i.FUNC_ADD),
      i.blendFunc(i.ONE, i.ZERO),
      i.blendFuncSeparate(i.ONE, i.ZERO, i.ONE, i.ZERO),
      i.blendColor(0, 0, 0, 0),
      i.colorMask(!0, !0, !0, !0),
      i.clearColor(0, 0, 0, 0),
      i.depthMask(!0),
      i.depthFunc(i.LESS),
      a.setReversed(!1),
      i.clearDepth(1),
      i.stencilMask(4294967295),
      i.stencilFunc(i.ALWAYS, 0, 4294967295),
      i.stencilOp(i.KEEP, i.KEEP, i.KEEP),
      i.clearStencil(0),
      i.cullFace(i.BACK),
      i.frontFace(i.CCW),
      i.polygonOffset(0, 0),
      i.activeTexture(i.TEXTURE0),
      i.bindFramebuffer(i.FRAMEBUFFER, null),
      i.bindFramebuffer(i.DRAW_FRAMEBUFFER, null),
      i.bindFramebuffer(i.READ_FRAMEBUFFER, null),
      i.useProgram(null),
      i.lineWidth(1),
      i.scissor(0, 0, i.canvas.width, i.canvas.height),
      i.viewport(0, 0, i.canvas.width, i.canvas.height),
      (u = {}),
      (ae = null),
      (ce = {}),
      (h = {}),
      (f = new WeakMap()),
      (m = []),
      (x = null),
      (g = !1),
      (d = null),
      (p = null),
      (y = null),
      (E = null),
      (v = null),
      (C = null),
      (A = null),
      (S = new ut(0, 0, 0)),
      (R = 0),
      (M = !1),
      (_ = null),
      (T = null),
      (F = null),
      (P = null),
      (I = null),
      Q.set(0, 0, i.canvas.width, i.canvas.height),
      B.set(0, 0, i.canvas.width, i.canvas.height),
      s.reset(),
      a.reset(),
      o.reset();
  }
  return {
    buffers: { color: s, depth: a, stencil: o },
    enable: he,
    disable: de,
    bindFramebuffer: Qe,
    drawBuffers: Oe,
    useProgram: St,
    setBlending: L,
    setMaterial: Lt,
    setFlipSided: We,
    setCullFace: Ke,
    setLineWidth: Be,
    setPolygonOffset: ht,
    setScissorTest: Fe,
    activeTexture: D,
    bindTexture: b,
    unbindTexture: q,
    compressedTexImage2D: ne,
    compressedTexImage3D: se,
    texImage2D: Me,
    texImage3D: Le,
    updateUBOMapping: tt,
    uniformBlockBinding: Ye,
    texStorage2D: et,
    texStorage3D: le,
    texSubImage2D: ee,
    texSubImage3D: Re,
    compressedTexSubImage2D: pe,
    compressedTexSubImage3D: ve,
    scissor: ke,
    viewport: be,
    reset: dt,
  };
}
function B1(i, e, t, n, r, s, a) {
  const o = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    l =
      typeof navigator == "undefined"
        ? !1
        : /OculusBrowser/g.test(navigator.userAgent),
    c = new it(),
    u = new WeakMap();
  let h;
  const f = new WeakMap();
  let m = !1;
  try {
    m =
      typeof OffscreenCanvas != "undefined" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (D) {}
  function x(D, b) {
    return m ? new OffscreenCanvas(D, b) : kr("canvas");
  }
  function g(D, b, q) {
    let ne = 1;
    const se = Fe(D);
    if (
      ((se.width > q || se.height > q) &&
        (ne = q / Math.max(se.width, se.height)),
      ne < 1)
    )
      if (
        (typeof HTMLImageElement != "undefined" &&
          D instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement != "undefined" &&
          D instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap != "undefined" && D instanceof ImageBitmap) ||
        (typeof VideoFrame != "undefined" && D instanceof VideoFrame)
      ) {
        const ee = Math.floor(ne * se.width),
          Re = Math.floor(ne * se.height);
        h === void 0 && (h = x(ee, Re));
        const pe = b ? x(ee, Re) : h;
        return (
          (pe.width = ee),
          (pe.height = Re),
          pe.getContext("2d").drawImage(D, 0, 0, ee, Re),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              se.width +
              "x" +
              se.height +
              ") to (" +
              ee +
              "x" +
              Re +
              ").",
          ),
          pe
        );
      } else
        return (
          "data" in D &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                se.width +
                "x" +
                se.height +
                ").",
            ),
          D
        );
    return D;
  }
  function d(D) {
    return D.generateMipmaps;
  }
  function p(D) {
    i.generateMipmap(D);
  }
  function y(D) {
    return D.isWebGLCubeRenderTarget
      ? i.TEXTURE_CUBE_MAP
      : D.isWebGL3DRenderTarget
        ? i.TEXTURE_3D
        : D.isWebGLArrayRenderTarget || D.isCompressedArrayTexture
          ? i.TEXTURE_2D_ARRAY
          : i.TEXTURE_2D;
  }
  function E(D, b, q, ne, se = !1) {
    if (D !== null) {
      if (i[D] !== void 0) return i[D];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          D +
          "'",
      );
    }
    let ee = b;
    if (
      (b === i.RED &&
        (q === i.FLOAT && (ee = i.R32F),
        q === i.HALF_FLOAT && (ee = i.R16F),
        q === i.UNSIGNED_BYTE && (ee = i.R8)),
      b === i.RED_INTEGER &&
        (q === i.UNSIGNED_BYTE && (ee = i.R8UI),
        q === i.UNSIGNED_SHORT && (ee = i.R16UI),
        q === i.UNSIGNED_INT && (ee = i.R32UI),
        q === i.BYTE && (ee = i.R8I),
        q === i.SHORT && (ee = i.R16I),
        q === i.INT && (ee = i.R32I)),
      b === i.RG &&
        (q === i.FLOAT && (ee = i.RG32F),
        q === i.HALF_FLOAT && (ee = i.RG16F),
        q === i.UNSIGNED_BYTE && (ee = i.RG8)),
      b === i.RG_INTEGER &&
        (q === i.UNSIGNED_BYTE && (ee = i.RG8UI),
        q === i.UNSIGNED_SHORT && (ee = i.RG16UI),
        q === i.UNSIGNED_INT && (ee = i.RG32UI),
        q === i.BYTE && (ee = i.RG8I),
        q === i.SHORT && (ee = i.RG16I),
        q === i.INT && (ee = i.RG32I)),
      b === i.RGB_INTEGER &&
        (q === i.UNSIGNED_BYTE && (ee = i.RGB8UI),
        q === i.UNSIGNED_SHORT && (ee = i.RGB16UI),
        q === i.UNSIGNED_INT && (ee = i.RGB32UI),
        q === i.BYTE && (ee = i.RGB8I),
        q === i.SHORT && (ee = i.RGB16I),
        q === i.INT && (ee = i.RGB32I)),
      b === i.RGBA_INTEGER &&
        (q === i.UNSIGNED_BYTE && (ee = i.RGBA8UI),
        q === i.UNSIGNED_SHORT && (ee = i.RGBA16UI),
        q === i.UNSIGNED_INT && (ee = i.RGBA32UI),
        q === i.BYTE && (ee = i.RGBA8I),
        q === i.SHORT && (ee = i.RGBA16I),
        q === i.INT && (ee = i.RGBA32I)),
      b === i.RGB && q === i.UNSIGNED_INT_5_9_9_9_REV && (ee = i.RGB9_E5),
      b === i.RGBA)
    ) {
      const Re = se ? ba : pt.getTransfer(ne);
      q === i.FLOAT && (ee = i.RGBA32F),
        q === i.HALF_FLOAT && (ee = i.RGBA16F),
        q === i.UNSIGNED_BYTE && (ee = Re === vt ? i.SRGB8_ALPHA8 : i.RGBA8),
        q === i.UNSIGNED_SHORT_4_4_4_4 && (ee = i.RGBA4),
        q === i.UNSIGNED_SHORT_5_5_5_1 && (ee = i.RGB5_A1);
    }
    return (
      (ee === i.R16F ||
        ee === i.R32F ||
        ee === i.RG16F ||
        ee === i.RG32F ||
        ee === i.RGBA16F ||
        ee === i.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      ee
    );
  }
  function v(D, b) {
    let q;
    return (
      D
        ? b === null || b === Ti || b === fr
          ? (q = i.DEPTH24_STENCIL8)
          : b === kn
            ? (q = i.DEPTH32F_STENCIL8)
            : b === zr &&
              ((q = i.DEPTH24_STENCIL8),
              console.warn(
                "DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.",
              ))
        : b === null || b === Ti || b === fr
          ? (q = i.DEPTH_COMPONENT24)
          : b === kn
            ? (q = i.DEPTH_COMPONENT32F)
            : b === zr && (q = i.DEPTH_COMPONENT16),
      q
    );
  }
  function C(D, b) {
    return d(D) === !0 ||
      (D.isFramebufferTexture && D.minFilter !== Mn && D.minFilter !== Dn)
      ? Math.log2(Math.max(b.width, b.height)) + 1
      : D.mipmaps !== void 0 && D.mipmaps.length > 0
        ? D.mipmaps.length
        : D.isCompressedTexture && Array.isArray(D.image)
          ? b.mipmaps.length
          : 1;
  }
  function A(D) {
    const b = D.target;
    b.removeEventListener("dispose", A), R(b), b.isVideoTexture && u.delete(b);
  }
  function S(D) {
    const b = D.target;
    b.removeEventListener("dispose", S), _(b);
  }
  function R(D) {
    const b = n.get(D);
    if (b.__webglInit === void 0) return;
    const q = D.source,
      ne = f.get(q);
    if (ne) {
      const se = ne[b.__cacheKey];
      se.usedTimes--,
        se.usedTimes === 0 && M(D),
        Object.keys(ne).length === 0 && f.delete(q);
    }
    n.remove(D);
  }
  function M(D) {
    const b = n.get(D);
    i.deleteTexture(b.__webglTexture);
    const q = D.source,
      ne = f.get(q);
    delete ne[b.__cacheKey], a.memory.textures--;
  }
  function _(D) {
    const b = n.get(D);
    if (
      (D.depthTexture && (D.depthTexture.dispose(), n.remove(D.depthTexture)),
      D.isWebGLCubeRenderTarget)
    )
      for (let ne = 0; ne < 6; ne++) {
        if (Array.isArray(b.__webglFramebuffer[ne]))
          for (let se = 0; se < b.__webglFramebuffer[ne].length; se++)
            i.deleteFramebuffer(b.__webglFramebuffer[ne][se]);
        else i.deleteFramebuffer(b.__webglFramebuffer[ne]);
        b.__webglDepthbuffer && i.deleteRenderbuffer(b.__webglDepthbuffer[ne]);
      }
    else {
      if (Array.isArray(b.__webglFramebuffer))
        for (let ne = 0; ne < b.__webglFramebuffer.length; ne++)
          i.deleteFramebuffer(b.__webglFramebuffer[ne]);
      else i.deleteFramebuffer(b.__webglFramebuffer);
      if (
        (b.__webglDepthbuffer && i.deleteRenderbuffer(b.__webglDepthbuffer),
        b.__webglMultisampledFramebuffer &&
          i.deleteFramebuffer(b.__webglMultisampledFramebuffer),
        b.__webglColorRenderbuffer)
      )
        for (let ne = 0; ne < b.__webglColorRenderbuffer.length; ne++)
          b.__webglColorRenderbuffer[ne] &&
            i.deleteRenderbuffer(b.__webglColorRenderbuffer[ne]);
      b.__webglDepthRenderbuffer &&
        i.deleteRenderbuffer(b.__webglDepthRenderbuffer);
    }
    const q = D.textures;
    for (let ne = 0, se = q.length; ne < se; ne++) {
      const ee = n.get(q[ne]);
      ee.__webglTexture &&
        (i.deleteTexture(ee.__webglTexture), a.memory.textures--),
        n.remove(q[ne]);
    }
    n.remove(D);
  }
  let T = 0;
  function F() {
    T = 0;
  }
  function P() {
    const D = T;
    return (
      D >= r.maxTextures &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            D +
            " texture units while this GPU supports only " +
            r.maxTextures,
        ),
      (T += 1),
      D
    );
  }
  function I(D) {
    const b = [];
    return (
      b.push(D.wrapS),
      b.push(D.wrapT),
      b.push(D.wrapR || 0),
      b.push(D.magFilter),
      b.push(D.minFilter),
      b.push(D.anisotropy),
      b.push(D.internalFormat),
      b.push(D.format),
      b.push(D.type),
      b.push(D.generateMipmaps),
      b.push(D.premultiplyAlpha),
      b.push(D.flipY),
      b.push(D.unpackAlignment),
      b.push(D.colorSpace),
      b.join()
    );
  }
  function X(D, b) {
    const q = n.get(D);
    if (
      (D.isVideoTexture && Be(D),
      D.isRenderTargetTexture === !1 &&
        D.version > 0 &&
        q.__version !== D.version)
    ) {
      const ne = D.image;
      if (ne === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found.",
        );
      else if (ne.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete",
        );
      else {
        B(q, D, b);
        return;
      }
    }
    t.bindTexture(i.TEXTURE_2D, q.__webglTexture, i.TEXTURE0 + b);
  }
  function V(D, b) {
    const q = n.get(D);
    if (D.version > 0 && q.__version !== D.version) {
      B(q, D, b);
      return;
    }
    t.bindTexture(i.TEXTURE_2D_ARRAY, q.__webglTexture, i.TEXTURE0 + b);
  }
  function ie(D, b) {
    const q = n.get(D);
    if (D.version > 0 && q.__version !== D.version) {
      B(q, D, b);
      return;
    }
    t.bindTexture(i.TEXTURE_3D, q.__webglTexture, i.TEXTURE0 + b);
  }
  function k(D, b) {
    const q = n.get(D);
    if (D.version > 0 && q.__version !== D.version) {
      te(q, D, b);
      return;
    }
    t.bindTexture(i.TEXTURE_CUBE_MAP, q.__webglTexture, i.TEXTURE0 + b);
  }
  const ae = { [Zo]: i.REPEAT, [Si]: i.CLAMP_TO_EDGE, [Jo]: i.MIRRORED_REPEAT },
    ce = {
      [Mn]: i.NEAREST,
      [om]: i.NEAREST_MIPMAP_NEAREST,
      [Zr]: i.NEAREST_MIPMAP_LINEAR,
      [Dn]: i.LINEAR,
      [ja]: i.LINEAR_MIPMAP_NEAREST,
      [Mi]: i.LINEAR_MIPMAP_LINEAR,
    },
    H = {
      [fm]: i.NEVER,
      [gm]: i.ALWAYS,
      [hm]: i.LESS,
      [ch]: i.LEQUAL,
      [dm]: i.EQUAL,
      [xm]: i.GEQUAL,
      [pm]: i.GREATER,
      [mm]: i.NOTEQUAL,
    };
  function K(D, b) {
    if (
      (b.type === kn &&
        e.has("OES_texture_float_linear") === !1 &&
        (b.magFilter === Dn ||
          b.magFilter === ja ||
          b.magFilter === Zr ||
          b.magFilter === Mi ||
          b.minFilter === Dn ||
          b.minFilter === ja ||
          b.minFilter === Zr ||
          b.minFilter === Mi) &&
        console.warn(
          "THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.",
        ),
      i.texParameteri(D, i.TEXTURE_WRAP_S, ae[b.wrapS]),
      i.texParameteri(D, i.TEXTURE_WRAP_T, ae[b.wrapT]),
      (D === i.TEXTURE_3D || D === i.TEXTURE_2D_ARRAY) &&
        i.texParameteri(D, i.TEXTURE_WRAP_R, ae[b.wrapR]),
      i.texParameteri(D, i.TEXTURE_MAG_FILTER, ce[b.magFilter]),
      i.texParameteri(D, i.TEXTURE_MIN_FILTER, ce[b.minFilter]),
      b.compareFunction &&
        (i.texParameteri(D, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE),
        i.texParameteri(D, i.TEXTURE_COMPARE_FUNC, H[b.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      if (
        b.magFilter === Mn ||
        (b.minFilter !== Zr && b.minFilter !== Mi) ||
        (b.type === kn && e.has("OES_texture_float_linear") === !1)
      )
        return;
      if (b.anisotropy > 1 || n.get(b).__currentAnisotropy) {
        const q = e.get("EXT_texture_filter_anisotropic");
        i.texParameterf(
          D,
          q.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(b.anisotropy, r.getMaxAnisotropy()),
        ),
          (n.get(b).__currentAnisotropy = b.anisotropy);
      }
    }
  }
  function Q(D, b) {
    let q = !1;
    D.__webglInit === void 0 &&
      ((D.__webglInit = !0), b.addEventListener("dispose", A));
    const ne = b.source;
    let se = f.get(ne);
    se === void 0 && ((se = {}), f.set(ne, se));
    const ee = I(b);
    if (ee !== D.__cacheKey) {
      se[ee] === void 0 &&
        ((se[ee] = { texture: i.createTexture(), usedTimes: 0 }),
        a.memory.textures++,
        (q = !0)),
        se[ee].usedTimes++;
      const Re = se[D.__cacheKey];
      Re !== void 0 &&
        (se[D.__cacheKey].usedTimes--, Re.usedTimes === 0 && M(b)),
        (D.__cacheKey = ee),
        (D.__webglTexture = se[ee].texture);
    }
    return q;
  }
  function B(D, b, q) {
    let ne = i.TEXTURE_2D;
    (b.isDataArrayTexture || b.isCompressedArrayTexture) &&
      (ne = i.TEXTURE_2D_ARRAY),
      b.isData3DTexture && (ne = i.TEXTURE_3D);
    const se = Q(D, b),
      ee = b.source;
    t.bindTexture(ne, D.__webglTexture, i.TEXTURE0 + q);
    const Re = n.get(ee);
    if (ee.version !== Re.__version || se === !0) {
      t.activeTexture(i.TEXTURE0 + q);
      const pe = pt.getPrimaries(pt.workingColorSpace),
        ve = b.colorSpace === Qn ? null : pt.getPrimaries(b.colorSpace),
        et =
          b.colorSpace === Qn || pe === ve ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
      i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, b.flipY),
        i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, b.premultiplyAlpha),
        i.pixelStorei(i.UNPACK_ALIGNMENT, b.unpackAlignment),
        i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, et);
      let le = g(b.image, !1, r.maxTextureSize);
      le = ht(b, le);
      const Me = s.convert(b.format, b.colorSpace),
        Le = s.convert(b.type);
      let ke = E(b.internalFormat, Me, Le, b.colorSpace, b.isVideoTexture);
      K(ne, b);
      let be;
      const tt = b.mipmaps,
        Ye = b.isVideoTexture !== !0,
        dt = Re.__version === void 0 || se === !0,
        N = ee.dataReady,
        ge = C(b, le);
      if (b.isDepthTexture)
        (ke = v(b.format === hr, b.type)),
          dt &&
            (Ye
              ? t.texStorage2D(i.TEXTURE_2D, 1, ke, le.width, le.height)
              : t.texImage2D(
                  i.TEXTURE_2D,
                  0,
                  ke,
                  le.width,
                  le.height,
                  0,
                  Me,
                  Le,
                  null,
                ));
      else if (b.isDataTexture)
        if (tt.length > 0) {
          Ye &&
            dt &&
            t.texStorage2D(i.TEXTURE_2D, ge, ke, tt[0].width, tt[0].height);
          for (let J = 0, re = tt.length; J < re; J++)
            (be = tt[J]),
              Ye
                ? N &&
                  t.texSubImage2D(
                    i.TEXTURE_2D,
                    J,
                    0,
                    0,
                    be.width,
                    be.height,
                    Me,
                    Le,
                    be.data,
                  )
                : t.texImage2D(
                    i.TEXTURE_2D,
                    J,
                    ke,
                    be.width,
                    be.height,
                    0,
                    Me,
                    Le,
                    be.data,
                  );
          b.generateMipmaps = !1;
        } else
          Ye
            ? (dt && t.texStorage2D(i.TEXTURE_2D, ge, ke, le.width, le.height),
              N &&
                t.texSubImage2D(
                  i.TEXTURE_2D,
                  0,
                  0,
                  0,
                  le.width,
                  le.height,
                  Me,
                  Le,
                  le.data,
                ))
            : t.texImage2D(
                i.TEXTURE_2D,
                0,
                ke,
                le.width,
                le.height,
                0,
                Me,
                Le,
                le.data,
              );
      else if (b.isCompressedTexture)
        if (b.isCompressedArrayTexture) {
          Ye &&
            dt &&
            t.texStorage3D(
              i.TEXTURE_2D_ARRAY,
              ge,
              ke,
              tt[0].width,
              tt[0].height,
              le.depth,
            );
          for (let J = 0, re = tt.length; J < re; J++)
            if (((be = tt[J]), b.format !== Sn))
              if (Me !== null)
                if (Ye) {
                  if (N)
                    if (b.layerUpdates.size > 0) {
                      const Se = Xu(be.width, be.height, b.format, b.type);
                      for (const Ee of b.layerUpdates) {
                        const qe = be.data.subarray(
                          (Ee * Se) / be.data.BYTES_PER_ELEMENT,
                          ((Ee + 1) * Se) / be.data.BYTES_PER_ELEMENT,
                        );
                        t.compressedTexSubImage3D(
                          i.TEXTURE_2D_ARRAY,
                          J,
                          0,
                          0,
                          Ee,
                          be.width,
                          be.height,
                          1,
                          Me,
                          qe,
                        );
                      }
                      b.clearLayerUpdates();
                    } else
                      t.compressedTexSubImage3D(
                        i.TEXTURE_2D_ARRAY,
                        J,
                        0,
                        0,
                        0,
                        be.width,
                        be.height,
                        le.depth,
                        Me,
                        be.data,
                      );
                } else
                  t.compressedTexImage3D(
                    i.TEXTURE_2D_ARRAY,
                    J,
                    ke,
                    be.width,
                    be.height,
                    le.depth,
                    0,
                    be.data,
                    0,
                    0,
                  );
              else
                console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()",
                );
            else
              Ye
                ? N &&
                  t.texSubImage3D(
                    i.TEXTURE_2D_ARRAY,
                    J,
                    0,
                    0,
                    0,
                    be.width,
                    be.height,
                    le.depth,
                    Me,
                    Le,
                    be.data,
                  )
                : t.texImage3D(
                    i.TEXTURE_2D_ARRAY,
                    J,
                    ke,
                    be.width,
                    be.height,
                    le.depth,
                    0,
                    Me,
                    Le,
                    be.data,
                  );
        } else {
          Ye &&
            dt &&
            t.texStorage2D(i.TEXTURE_2D, ge, ke, tt[0].width, tt[0].height);
          for (let J = 0, re = tt.length; J < re; J++)
            (be = tt[J]),
              b.format !== Sn
                ? Me !== null
                  ? Ye
                    ? N &&
                      t.compressedTexSubImage2D(
                        i.TEXTURE_2D,
                        J,
                        0,
                        0,
                        be.width,
                        be.height,
                        Me,
                        be.data,
                      )
                    : t.compressedTexImage2D(
                        i.TEXTURE_2D,
                        J,
                        ke,
                        be.width,
                        be.height,
                        0,
                        be.data,
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()",
                    )
                : Ye
                  ? N &&
                    t.texSubImage2D(
                      i.TEXTURE_2D,
                      J,
                      0,
                      0,
                      be.width,
                      be.height,
                      Me,
                      Le,
                      be.data,
                    )
                  : t.texImage2D(
                      i.TEXTURE_2D,
                      J,
                      ke,
                      be.width,
                      be.height,
                      0,
                      Me,
                      Le,
                      be.data,
                    );
        }
      else if (b.isDataArrayTexture)
        if (Ye) {
          if (
            (dt &&
              t.texStorage3D(
                i.TEXTURE_2D_ARRAY,
                ge,
                ke,
                le.width,
                le.height,
                le.depth,
              ),
            N)
          )
            if (b.layerUpdates.size > 0) {
              const J = Xu(le.width, le.height, b.format, b.type);
              for (const re of b.layerUpdates) {
                const Se = le.data.subarray(
                  (re * J) / le.data.BYTES_PER_ELEMENT,
                  ((re + 1) * J) / le.data.BYTES_PER_ELEMENT,
                );
                t.texSubImage3D(
                  i.TEXTURE_2D_ARRAY,
                  0,
                  0,
                  0,
                  re,
                  le.width,
                  le.height,
                  1,
                  Me,
                  Le,
                  Se,
                );
              }
              b.clearLayerUpdates();
            } else
              t.texSubImage3D(
                i.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                le.width,
                le.height,
                le.depth,
                Me,
                Le,
                le.data,
              );
        } else
          t.texImage3D(
            i.TEXTURE_2D_ARRAY,
            0,
            ke,
            le.width,
            le.height,
            le.depth,
            0,
            Me,
            Le,
            le.data,
          );
      else if (b.isData3DTexture)
        Ye
          ? (dt &&
              t.texStorage3D(
                i.TEXTURE_3D,
                ge,
                ke,
                le.width,
                le.height,
                le.depth,
              ),
            N &&
              t.texSubImage3D(
                i.TEXTURE_3D,
                0,
                0,
                0,
                0,
                le.width,
                le.height,
                le.depth,
                Me,
                Le,
                le.data,
              ))
          : t.texImage3D(
              i.TEXTURE_3D,
              0,
              ke,
              le.width,
              le.height,
              le.depth,
              0,
              Me,
              Le,
              le.data,
            );
      else if (b.isFramebufferTexture) {
        if (dt)
          if (Ye) t.texStorage2D(i.TEXTURE_2D, ge, ke, le.width, le.height);
          else {
            let J = le.width,
              re = le.height;
            for (let Se = 0; Se < ge; Se++)
              t.texImage2D(i.TEXTURE_2D, Se, ke, J, re, 0, Me, Le, null),
                (J >>= 1),
                (re >>= 1);
          }
      } else if (tt.length > 0) {
        if (Ye && dt) {
          const J = Fe(tt[0]);
          t.texStorage2D(i.TEXTURE_2D, ge, ke, J.width, J.height);
        }
        for (let J = 0, re = tt.length; J < re; J++)
          (be = tt[J]),
            Ye
              ? N && t.texSubImage2D(i.TEXTURE_2D, J, 0, 0, Me, Le, be)
              : t.texImage2D(i.TEXTURE_2D, J, ke, Me, Le, be);
        b.generateMipmaps = !1;
      } else if (Ye) {
        if (dt) {
          const J = Fe(le);
          t.texStorage2D(i.TEXTURE_2D, ge, ke, J.width, J.height);
        }
        N && t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, Me, Le, le);
      } else t.texImage2D(i.TEXTURE_2D, 0, ke, Me, Le, le);
      d(b) && p(ne), (Re.__version = ee.version), b.onUpdate && b.onUpdate(b);
    }
    D.__version = b.version;
  }
  function te(D, b, q) {
    if (b.image.length !== 6) return;
    const ne = Q(D, b),
      se = b.source;
    t.bindTexture(i.TEXTURE_CUBE_MAP, D.__webglTexture, i.TEXTURE0 + q);
    const ee = n.get(se);
    if (se.version !== ee.__version || ne === !0) {
      t.activeTexture(i.TEXTURE0 + q);
      const Re = pt.getPrimaries(pt.workingColorSpace),
        pe = b.colorSpace === Qn ? null : pt.getPrimaries(b.colorSpace),
        ve =
          b.colorSpace === Qn || Re === pe ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
      i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, b.flipY),
        i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, b.premultiplyAlpha),
        i.pixelStorei(i.UNPACK_ALIGNMENT, b.unpackAlignment),
        i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, ve);
      const et = b.isCompressedTexture || b.image[0].isCompressedTexture,
        le = b.image[0] && b.image[0].isDataTexture,
        Me = [];
      for (let re = 0; re < 6; re++)
        !et && !le
          ? (Me[re] = g(b.image[re], !0, r.maxCubemapSize))
          : (Me[re] = le ? b.image[re].image : b.image[re]),
          (Me[re] = ht(b, Me[re]));
      const Le = Me[0],
        ke = s.convert(b.format, b.colorSpace),
        be = s.convert(b.type),
        tt = E(b.internalFormat, ke, be, b.colorSpace),
        Ye = b.isVideoTexture !== !0,
        dt = ee.__version === void 0 || ne === !0,
        N = se.dataReady;
      let ge = C(b, Le);
      K(i.TEXTURE_CUBE_MAP, b);
      let J;
      if (et) {
        Ye &&
          dt &&
          t.texStorage2D(i.TEXTURE_CUBE_MAP, ge, tt, Le.width, Le.height);
        for (let re = 0; re < 6; re++) {
          J = Me[re].mipmaps;
          for (let Se = 0; Se < J.length; Se++) {
            const Ee = J[Se];
            b.format !== Sn
              ? ke !== null
                ? Ye
                  ? N &&
                    t.compressedTexSubImage2D(
                      i.TEXTURE_CUBE_MAP_POSITIVE_X + re,
                      Se,
                      0,
                      0,
                      Ee.width,
                      Ee.height,
                      ke,
                      Ee.data,
                    )
                  : t.compressedTexImage2D(
                      i.TEXTURE_CUBE_MAP_POSITIVE_X + re,
                      Se,
                      tt,
                      Ee.width,
                      Ee.height,
                      0,
                      Ee.data,
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()",
                  )
              : Ye
                ? N &&
                  t.texSubImage2D(
                    i.TEXTURE_CUBE_MAP_POSITIVE_X + re,
                    Se,
                    0,
                    0,
                    Ee.width,
                    Ee.height,
                    ke,
                    be,
                    Ee.data,
                  )
                : t.texImage2D(
                    i.TEXTURE_CUBE_MAP_POSITIVE_X + re,
                    Se,
                    tt,
                    Ee.width,
                    Ee.height,
                    0,
                    ke,
                    be,
                    Ee.data,
                  );
          }
        }
      } else {
        if (((J = b.mipmaps), Ye && dt)) {
          J.length > 0 && ge++;
          const re = Fe(Me[0]);
          t.texStorage2D(i.TEXTURE_CUBE_MAP, ge, tt, re.width, re.height);
        }
        for (let re = 0; re < 6; re++)
          if (le) {
            Ye
              ? N &&
                t.texSubImage2D(
                  i.TEXTURE_CUBE_MAP_POSITIVE_X + re,
                  0,
                  0,
                  0,
                  Me[re].width,
                  Me[re].height,
                  ke,
                  be,
                  Me[re].data,
                )
              : t.texImage2D(
                  i.TEXTURE_CUBE_MAP_POSITIVE_X + re,
                  0,
                  tt,
                  Me[re].width,
                  Me[re].height,
                  0,
                  ke,
                  be,
                  Me[re].data,
                );
            for (let Se = 0; Se < J.length; Se++) {
              const qe = J[Se].image[re].image;
              Ye
                ? N &&
                  t.texSubImage2D(
                    i.TEXTURE_CUBE_MAP_POSITIVE_X + re,
                    Se + 1,
                    0,
                    0,
                    qe.width,
                    qe.height,
                    ke,
                    be,
                    qe.data,
                  )
                : t.texImage2D(
                    i.TEXTURE_CUBE_MAP_POSITIVE_X + re,
                    Se + 1,
                    tt,
                    qe.width,
                    qe.height,
                    0,
                    ke,
                    be,
                    qe.data,
                  );
            }
          } else {
            Ye
              ? N &&
                t.texSubImage2D(
                  i.TEXTURE_CUBE_MAP_POSITIVE_X + re,
                  0,
                  0,
                  0,
                  ke,
                  be,
                  Me[re],
                )
              : t.texImage2D(
                  i.TEXTURE_CUBE_MAP_POSITIVE_X + re,
                  0,
                  tt,
                  ke,
                  be,
                  Me[re],
                );
            for (let Se = 0; Se < J.length; Se++) {
              const Ee = J[Se];
              Ye
                ? N &&
                  t.texSubImage2D(
                    i.TEXTURE_CUBE_MAP_POSITIVE_X + re,
                    Se + 1,
                    0,
                    0,
                    ke,
                    be,
                    Ee.image[re],
                  )
                : t.texImage2D(
                    i.TEXTURE_CUBE_MAP_POSITIVE_X + re,
                    Se + 1,
                    tt,
                    ke,
                    be,
                    Ee.image[re],
                  );
            }
          }
      }
      d(b) && p(i.TEXTURE_CUBE_MAP),
        (ee.__version = se.version),
        b.onUpdate && b.onUpdate(b);
    }
    D.__version = b.version;
  }
  function fe(D, b, q, ne, se, ee) {
    const Re = s.convert(q.format, q.colorSpace),
      pe = s.convert(q.type),
      ve = E(q.internalFormat, Re, pe, q.colorSpace),
      et = n.get(b),
      le = n.get(q);
    if (((le.__renderTarget = b), !et.__hasExternalTextures)) {
      const Me = Math.max(1, b.width >> ee),
        Le = Math.max(1, b.height >> ee);
      se === i.TEXTURE_3D || se === i.TEXTURE_2D_ARRAY
        ? t.texImage3D(se, ee, ve, Me, Le, b.depth, 0, Re, pe, null)
        : t.texImage2D(se, ee, ve, Me, Le, 0, Re, pe, null);
    }
    t.bindFramebuffer(i.FRAMEBUFFER, D),
      Ke(b)
        ? o.framebufferTexture2DMultisampleEXT(
            i.FRAMEBUFFER,
            ne,
            se,
            le.__webglTexture,
            0,
            We(b),
          )
        : (se === i.TEXTURE_2D ||
            (se >= i.TEXTURE_CUBE_MAP_POSITIVE_X &&
              se <= i.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          i.framebufferTexture2D(i.FRAMEBUFFER, ne, se, le.__webglTexture, ee),
      t.bindFramebuffer(i.FRAMEBUFFER, null);
  }
  function he(D, b, q) {
    if ((i.bindRenderbuffer(i.RENDERBUFFER, D), b.depthBuffer)) {
      const ne = b.depthTexture,
        se = ne && ne.isDepthTexture ? ne.type : null,
        ee = v(b.stencilBuffer, se),
        Re = b.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT,
        pe = We(b);
      Ke(b)
        ? o.renderbufferStorageMultisampleEXT(
            i.RENDERBUFFER,
            pe,
            ee,
            b.width,
            b.height,
          )
        : q
          ? i.renderbufferStorageMultisample(
              i.RENDERBUFFER,
              pe,
              ee,
              b.width,
              b.height,
            )
          : i.renderbufferStorage(i.RENDERBUFFER, ee, b.width, b.height),
        i.framebufferRenderbuffer(i.FRAMEBUFFER, Re, i.RENDERBUFFER, D);
    } else {
      const ne = b.textures;
      for (let se = 0; se < ne.length; se++) {
        const ee = ne[se],
          Re = s.convert(ee.format, ee.colorSpace),
          pe = s.convert(ee.type),
          ve = E(ee.internalFormat, Re, pe, ee.colorSpace),
          et = We(b);
        q && Ke(b) === !1
          ? i.renderbufferStorageMultisample(
              i.RENDERBUFFER,
              et,
              ve,
              b.width,
              b.height,
            )
          : Ke(b)
            ? o.renderbufferStorageMultisampleEXT(
                i.RENDERBUFFER,
                et,
                ve,
                b.width,
                b.height,
              )
            : i.renderbufferStorage(i.RENDERBUFFER, ve, b.width, b.height);
      }
    }
    i.bindRenderbuffer(i.RENDERBUFFER, null);
  }
  function de(D, b) {
    if (b && b.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported",
      );
    if (
      (t.bindFramebuffer(i.FRAMEBUFFER, D),
      !(b.depthTexture && b.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture",
      );
    const ne = n.get(b.depthTexture);
    (ne.__renderTarget = b),
      (!ne.__webglTexture ||
        b.depthTexture.image.width !== b.width ||
        b.depthTexture.image.height !== b.height) &&
        ((b.depthTexture.image.width = b.width),
        (b.depthTexture.image.height = b.height),
        (b.depthTexture.needsUpdate = !0)),
      X(b.depthTexture, 0);
    const se = ne.__webglTexture,
      ee = We(b);
    if (b.depthTexture.format === rr)
      Ke(b)
        ? o.framebufferTexture2DMultisampleEXT(
            i.FRAMEBUFFER,
            i.DEPTH_ATTACHMENT,
            i.TEXTURE_2D,
            se,
            0,
            ee,
          )
        : i.framebufferTexture2D(
            i.FRAMEBUFFER,
            i.DEPTH_ATTACHMENT,
            i.TEXTURE_2D,
            se,
            0,
          );
    else if (b.depthTexture.format === hr)
      Ke(b)
        ? o.framebufferTexture2DMultisampleEXT(
            i.FRAMEBUFFER,
            i.DEPTH_STENCIL_ATTACHMENT,
            i.TEXTURE_2D,
            se,
            0,
            ee,
          )
        : i.framebufferTexture2D(
            i.FRAMEBUFFER,
            i.DEPTH_STENCIL_ATTACHMENT,
            i.TEXTURE_2D,
            se,
            0,
          );
    else throw new Error("Unknown depthTexture format");
  }
  function Qe(D) {
    const b = n.get(D),
      q = D.isWebGLCubeRenderTarget === !0;
    if (b.__boundDepthTexture !== D.depthTexture) {
      const ne = D.depthTexture;
      if ((b.__depthDisposeCallback && b.__depthDisposeCallback(), ne)) {
        const se = () => {
          delete b.__boundDepthTexture,
            delete b.__depthDisposeCallback,
            ne.removeEventListener("dispose", se);
        };
        ne.addEventListener("dispose", se), (b.__depthDisposeCallback = se);
      }
      b.__boundDepthTexture = ne;
    }
    if (D.depthTexture && !b.__autoAllocateDepthBuffer) {
      if (q)
        throw new Error(
          "target.depthTexture not supported in Cube render targets",
        );
      de(b.__webglFramebuffer, D);
    } else if (q) {
      b.__webglDepthbuffer = [];
      for (let ne = 0; ne < 6; ne++)
        if (
          (t.bindFramebuffer(i.FRAMEBUFFER, b.__webglFramebuffer[ne]),
          b.__webglDepthbuffer[ne] === void 0)
        )
          (b.__webglDepthbuffer[ne] = i.createRenderbuffer()),
            he(b.__webglDepthbuffer[ne], D, !1);
        else {
          const se = D.stencilBuffer
              ? i.DEPTH_STENCIL_ATTACHMENT
              : i.DEPTH_ATTACHMENT,
            ee = b.__webglDepthbuffer[ne];
          i.bindRenderbuffer(i.RENDERBUFFER, ee),
            i.framebufferRenderbuffer(i.FRAMEBUFFER, se, i.RENDERBUFFER, ee);
        }
    } else if (
      (t.bindFramebuffer(i.FRAMEBUFFER, b.__webglFramebuffer),
      b.__webglDepthbuffer === void 0)
    )
      (b.__webglDepthbuffer = i.createRenderbuffer()),
        he(b.__webglDepthbuffer, D, !1);
    else {
      const ne = D.stencilBuffer
          ? i.DEPTH_STENCIL_ATTACHMENT
          : i.DEPTH_ATTACHMENT,
        se = b.__webglDepthbuffer;
      i.bindRenderbuffer(i.RENDERBUFFER, se),
        i.framebufferRenderbuffer(i.FRAMEBUFFER, ne, i.RENDERBUFFER, se);
    }
    t.bindFramebuffer(i.FRAMEBUFFER, null);
  }
  function Oe(D, b, q) {
    const ne = n.get(D);
    b !== void 0 &&
      fe(
        ne.__webglFramebuffer,
        D,
        D.texture,
        i.COLOR_ATTACHMENT0,
        i.TEXTURE_2D,
        0,
      ),
      q !== void 0 && Qe(D);
  }
  function St(D) {
    const b = D.texture,
      q = n.get(D),
      ne = n.get(b);
    D.addEventListener("dispose", S);
    const se = D.textures,
      ee = D.isWebGLCubeRenderTarget === !0,
      Re = se.length > 1;
    if (
      (Re ||
        (ne.__webglTexture === void 0 &&
          (ne.__webglTexture = i.createTexture()),
        (ne.__version = b.version),
        a.memory.textures++),
      ee)
    ) {
      q.__webglFramebuffer = [];
      for (let pe = 0; pe < 6; pe++)
        if (b.mipmaps && b.mipmaps.length > 0) {
          q.__webglFramebuffer[pe] = [];
          for (let ve = 0; ve < b.mipmaps.length; ve++)
            q.__webglFramebuffer[pe][ve] = i.createFramebuffer();
        } else q.__webglFramebuffer[pe] = i.createFramebuffer();
    } else {
      if (b.mipmaps && b.mipmaps.length > 0) {
        q.__webglFramebuffer = [];
        for (let pe = 0; pe < b.mipmaps.length; pe++)
          q.__webglFramebuffer[pe] = i.createFramebuffer();
      } else q.__webglFramebuffer = i.createFramebuffer();
      if (Re)
        for (let pe = 0, ve = se.length; pe < ve; pe++) {
          const et = n.get(se[pe]);
          et.__webglTexture === void 0 &&
            ((et.__webglTexture = i.createTexture()), a.memory.textures++);
        }
      if (D.samples > 0 && Ke(D) === !1) {
        (q.__webglMultisampledFramebuffer = i.createFramebuffer()),
          (q.__webglColorRenderbuffer = []),
          t.bindFramebuffer(i.FRAMEBUFFER, q.__webglMultisampledFramebuffer);
        for (let pe = 0; pe < se.length; pe++) {
          const ve = se[pe];
          (q.__webglColorRenderbuffer[pe] = i.createRenderbuffer()),
            i.bindRenderbuffer(i.RENDERBUFFER, q.__webglColorRenderbuffer[pe]);
          const et = s.convert(ve.format, ve.colorSpace),
            le = s.convert(ve.type),
            Me = E(
              ve.internalFormat,
              et,
              le,
              ve.colorSpace,
              D.isXRRenderTarget === !0,
            ),
            Le = We(D);
          i.renderbufferStorageMultisample(
            i.RENDERBUFFER,
            Le,
            Me,
            D.width,
            D.height,
          ),
            i.framebufferRenderbuffer(
              i.FRAMEBUFFER,
              i.COLOR_ATTACHMENT0 + pe,
              i.RENDERBUFFER,
              q.__webglColorRenderbuffer[pe],
            );
        }
        i.bindRenderbuffer(i.RENDERBUFFER, null),
          D.depthBuffer &&
            ((q.__webglDepthRenderbuffer = i.createRenderbuffer()),
            he(q.__webglDepthRenderbuffer, D, !0)),
          t.bindFramebuffer(i.FRAMEBUFFER, null);
      }
    }
    if (ee) {
      t.bindTexture(i.TEXTURE_CUBE_MAP, ne.__webglTexture),
        K(i.TEXTURE_CUBE_MAP, b);
      for (let pe = 0; pe < 6; pe++)
        if (b.mipmaps && b.mipmaps.length > 0)
          for (let ve = 0; ve < b.mipmaps.length; ve++)
            fe(
              q.__webglFramebuffer[pe][ve],
              D,
              b,
              i.COLOR_ATTACHMENT0,
              i.TEXTURE_CUBE_MAP_POSITIVE_X + pe,
              ve,
            );
        else
          fe(
            q.__webglFramebuffer[pe],
            D,
            b,
            i.COLOR_ATTACHMENT0,
            i.TEXTURE_CUBE_MAP_POSITIVE_X + pe,
            0,
          );
      d(b) && p(i.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (Re) {
      for (let pe = 0, ve = se.length; pe < ve; pe++) {
        const et = se[pe],
          le = n.get(et);
        t.bindTexture(i.TEXTURE_2D, le.__webglTexture),
          K(i.TEXTURE_2D, et),
          fe(
            q.__webglFramebuffer,
            D,
            et,
            i.COLOR_ATTACHMENT0 + pe,
            i.TEXTURE_2D,
            0,
          ),
          d(et) && p(i.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let pe = i.TEXTURE_2D;
      if (
        ((D.isWebGL3DRenderTarget || D.isWebGLArrayRenderTarget) &&
          (pe = D.isWebGL3DRenderTarget ? i.TEXTURE_3D : i.TEXTURE_2D_ARRAY),
        t.bindTexture(pe, ne.__webglTexture),
        K(pe, b),
        b.mipmaps && b.mipmaps.length > 0)
      )
        for (let ve = 0; ve < b.mipmaps.length; ve++)
          fe(q.__webglFramebuffer[ve], D, b, i.COLOR_ATTACHMENT0, pe, ve);
      else fe(q.__webglFramebuffer, D, b, i.COLOR_ATTACHMENT0, pe, 0);
      d(b) && p(pe), t.unbindTexture();
    }
    D.depthBuffer && Qe(D);
  }
  function Xe(D) {
    const b = D.textures;
    for (let q = 0, ne = b.length; q < ne; q++) {
      const se = b[q];
      if (d(se)) {
        const ee = y(D),
          Re = n.get(se).__webglTexture;
        t.bindTexture(ee, Re), p(ee), t.unbindTexture();
      }
    }
  }
  const ze = [],
    L = [];
  function Lt(D) {
    if (D.samples > 0) {
      if (Ke(D) === !1) {
        const b = D.textures,
          q = D.width,
          ne = D.height;
        let se = i.COLOR_BUFFER_BIT;
        const ee = D.stencilBuffer
            ? i.DEPTH_STENCIL_ATTACHMENT
            : i.DEPTH_ATTACHMENT,
          Re = n.get(D),
          pe = b.length > 1;
        if (pe)
          for (let ve = 0; ve < b.length; ve++)
            t.bindFramebuffer(i.FRAMEBUFFER, Re.__webglMultisampledFramebuffer),
              i.framebufferRenderbuffer(
                i.FRAMEBUFFER,
                i.COLOR_ATTACHMENT0 + ve,
                i.RENDERBUFFER,
                null,
              ),
              t.bindFramebuffer(i.FRAMEBUFFER, Re.__webglFramebuffer),
              i.framebufferTexture2D(
                i.DRAW_FRAMEBUFFER,
                i.COLOR_ATTACHMENT0 + ve,
                i.TEXTURE_2D,
                null,
                0,
              );
        t.bindFramebuffer(
          i.READ_FRAMEBUFFER,
          Re.__webglMultisampledFramebuffer,
        ),
          t.bindFramebuffer(i.DRAW_FRAMEBUFFER, Re.__webglFramebuffer);
        for (let ve = 0; ve < b.length; ve++) {
          if (
            (D.resolveDepthBuffer &&
              (D.depthBuffer && (se |= i.DEPTH_BUFFER_BIT),
              D.stencilBuffer &&
                D.resolveStencilBuffer &&
                (se |= i.STENCIL_BUFFER_BIT)),
            pe)
          ) {
            i.framebufferRenderbuffer(
              i.READ_FRAMEBUFFER,
              i.COLOR_ATTACHMENT0,
              i.RENDERBUFFER,
              Re.__webglColorRenderbuffer[ve],
            );
            const et = n.get(b[ve]).__webglTexture;
            i.framebufferTexture2D(
              i.DRAW_FRAMEBUFFER,
              i.COLOR_ATTACHMENT0,
              i.TEXTURE_2D,
              et,
              0,
            );
          }
          i.blitFramebuffer(0, 0, q, ne, 0, 0, q, ne, se, i.NEAREST),
            l === !0 &&
              ((ze.length = 0),
              (L.length = 0),
              ze.push(i.COLOR_ATTACHMENT0 + ve),
              D.depthBuffer &&
                D.resolveDepthBuffer === !1 &&
                (ze.push(ee),
                L.push(ee),
                i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, L)),
              i.invalidateFramebuffer(i.READ_FRAMEBUFFER, ze));
        }
        if (
          (t.bindFramebuffer(i.READ_FRAMEBUFFER, null),
          t.bindFramebuffer(i.DRAW_FRAMEBUFFER, null),
          pe)
        )
          for (let ve = 0; ve < b.length; ve++) {
            t.bindFramebuffer(i.FRAMEBUFFER, Re.__webglMultisampledFramebuffer),
              i.framebufferRenderbuffer(
                i.FRAMEBUFFER,
                i.COLOR_ATTACHMENT0 + ve,
                i.RENDERBUFFER,
                Re.__webglColorRenderbuffer[ve],
              );
            const et = n.get(b[ve]).__webglTexture;
            t.bindFramebuffer(i.FRAMEBUFFER, Re.__webglFramebuffer),
              i.framebufferTexture2D(
                i.DRAW_FRAMEBUFFER,
                i.COLOR_ATTACHMENT0 + ve,
                i.TEXTURE_2D,
                et,
                0,
              );
          }
        t.bindFramebuffer(
          i.DRAW_FRAMEBUFFER,
          Re.__webglMultisampledFramebuffer,
        );
      } else if (D.depthBuffer && D.resolveDepthBuffer === !1 && l) {
        const b = D.stencilBuffer
          ? i.DEPTH_STENCIL_ATTACHMENT
          : i.DEPTH_ATTACHMENT;
        i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, [b]);
      }
    }
  }
  function We(D) {
    return Math.min(r.maxSamples, D.samples);
  }
  function Ke(D) {
    const b = n.get(D);
    return (
      D.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      b.__useRenderToTexture !== !1
    );
  }
  function Be(D) {
    const b = a.render.frame;
    u.get(D) !== b && (u.set(D, b), D.update());
  }
  function ht(D, b) {
    const q = D.colorSpace,
      ne = D.format,
      se = D.type;
    return (
      D.isCompressedTexture === !0 ||
        D.isVideoTexture === !0 ||
        (q !== dr &&
          q !== Qn &&
          (pt.getTransfer(q) === vt
            ? (ne !== Sn || se !== Wn) &&
              console.warn(
                "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.",
              )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                q,
              ))),
      b
    );
  }
  function Fe(D) {
    return (
      typeof HTMLImageElement != "undefined" && D instanceof HTMLImageElement
        ? ((c.width = D.naturalWidth || D.width),
          (c.height = D.naturalHeight || D.height))
        : typeof VideoFrame != "undefined" && D instanceof VideoFrame
          ? ((c.width = D.displayWidth), (c.height = D.displayHeight))
          : ((c.width = D.width), (c.height = D.height)),
      c
    );
  }
  (this.allocateTextureUnit = P),
    (this.resetTextureUnits = F),
    (this.setTexture2D = X),
    (this.setTexture2DArray = V),
    (this.setTexture3D = ie),
    (this.setTextureCube = k),
    (this.rebindTextures = Oe),
    (this.setupRenderTarget = St),
    (this.updateRenderTargetMipmap = Xe),
    (this.updateMultisampleRenderTarget = Lt),
    (this.setupDepthRenderbuffer = Qe),
    (this.setupFrameBufferTexture = fe),
    (this.useMultisampledRTT = Ke);
}
function L1(i, e) {
  function t(n, r = Qn) {
    let s;
    const a = pt.getTransfer(r);
    if (n === Wn) return i.UNSIGNED_BYTE;
    if (n === Yc) return i.UNSIGNED_SHORT_4_4_4_4;
    if (n === $c) return i.UNSIGNED_SHORT_5_5_5_1;
    if (n === Qf) return i.UNSIGNED_INT_5_9_9_9_REV;
    if (n === Zf) return i.BYTE;
    if (n === Jf) return i.SHORT;
    if (n === zr) return i.UNSIGNED_SHORT;
    if (n === qc) return i.INT;
    if (n === Ti) return i.UNSIGNED_INT;
    if (n === kn) return i.FLOAT;
    if (n === Vr) return i.HALF_FLOAT;
    if (n === eh) return i.ALPHA;
    if (n === th) return i.RGB;
    if (n === Sn) return i.RGBA;
    if (n === nh) return i.LUMINANCE;
    if (n === ih) return i.LUMINANCE_ALPHA;
    if (n === rr) return i.DEPTH_COMPONENT;
    if (n === hr) return i.DEPTH_STENCIL;
    if (n === rh) return i.RED;
    if (n === jc) return i.RED_INTEGER;
    if (n === sh) return i.RG;
    if (n === Kc) return i.RG_INTEGER;
    if (n === Zc) return i.RGBA_INTEGER;
    if (n === ua || n === fa || n === ha || n === da)
      if (a === vt)
        if (((s = e.get("WEBGL_compressed_texture_s3tc_srgb")), s !== null)) {
          if (n === ua) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (n === fa) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (n === ha) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (n === da) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((s = e.get("WEBGL_compressed_texture_s3tc")), s !== null)) {
        if (n === ua) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (n === fa) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (n === ha) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (n === da) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (n === Qo || n === ec || n === tc || n === nc)
      if (((s = e.get("WEBGL_compressed_texture_pvrtc")), s !== null)) {
        if (n === Qo) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (n === ec) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (n === tc) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (n === nc) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (n === ic || n === rc || n === sc)
      if (((s = e.get("WEBGL_compressed_texture_etc")), s !== null)) {
        if (n === ic || n === rc)
          return a === vt ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
        if (n === sc)
          return a === vt
            ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : s.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      n === ac ||
      n === oc ||
      n === cc ||
      n === lc ||
      n === uc ||
      n === fc ||
      n === hc ||
      n === dc ||
      n === pc ||
      n === mc ||
      n === xc ||
      n === gc ||
      n === _c ||
      n === vc
    )
      if (((s = e.get("WEBGL_compressed_texture_astc")), s !== null)) {
        if (n === ac)
          return a === vt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (n === oc)
          return a === vt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (n === cc)
          return a === vt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (n === lc)
          return a === vt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (n === uc)
          return a === vt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (n === fc)
          return a === vt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (n === hc)
          return a === vt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (n === dc)
          return a === vt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (n === pc)
          return a === vt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (n === mc)
          return a === vt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (n === xc)
          return a === vt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (n === gc)
          return a === vt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (n === _c)
          return a === vt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (n === vc)
          return a === vt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (n === pa || n === Ec || n === yc)
      if (((s = e.get("EXT_texture_compression_bptc")), s !== null)) {
        if (n === pa)
          return a === vt
            ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (n === Ec) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (n === yc) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (n === ah || n === Sc || n === Mc || n === Ac)
      if (((s = e.get("EXT_texture_compression_rgtc")), s !== null)) {
        if (n === pa) return s.COMPRESSED_RED_RGTC1_EXT;
        if (n === Sc) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (n === Mc) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (n === Ac) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return n === fr ? i.UNSIGNED_INT_24_8 : i[n] !== void 0 ? i[n] : null;
  }
  return { convert: t };
}
const U1 = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
  I1 = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class N1 {
  constructor() {
    (this.texture = null),
      (this.mesh = null),
      (this.depthNear = 0),
      (this.depthFar = 0);
  }
  init(e, t, n) {
    if (this.texture === null) {
      const r = new qt(),
        s = e.properties.get(r);
      (s.__webglTexture = t.texture),
        (t.depthNear !== n.depthNear || t.depthFar !== n.depthFar) &&
          ((this.depthNear = t.depthNear), (this.depthFar = t.depthFar)),
        (this.texture = r);
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const t = e.cameras[0].viewport,
        n = new ai({
          vertexShader: U1,
          fragmentShader: I1,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: t.z },
            depthHeight: { value: t.w },
          },
        });
      this.mesh = new Vn(new Ba(20, 20), n);
    }
    return this.mesh;
  }
  reset() {
    (this.texture = null), (this.mesh = null);
  }
  getDepthTexture() {
    return this.texture;
  }
}
class O1 extends xr {
  constructor(e, t) {
    super();
    const n = this;
    let r = null,
      s = 1,
      a = null,
      o = "local-floor",
      l = 1,
      c = null,
      u = null,
      h = null,
      f = null,
      m = null,
      x = null;
    const g = new N1(),
      d = t.getContextAttributes();
    let p = null,
      y = null;
    const E = [],
      v = [],
      C = new it();
    let A = null;
    const S = new dn();
    S.viewport = new yt();
    const R = new dn();
    R.viewport = new yt();
    const M = [S, R],
      _ = new ax();
    let T = null,
      F = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (B) {
        let te = E[B];
        return (
          te === void 0 && ((te = new _o()), (E[B] = te)),
          te.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (B) {
        let te = E[B];
        return (
          te === void 0 && ((te = new _o()), (E[B] = te)), te.getGripSpace()
        );
      }),
      (this.getHand = function (B) {
        let te = E[B];
        return (
          te === void 0 && ((te = new _o()), (E[B] = te)), te.getHandSpace()
        );
      });
    function P(B) {
      const te = v.indexOf(B.inputSource);
      if (te === -1) return;
      const fe = E[te];
      fe !== void 0 &&
        (fe.update(B.inputSource, B.frame, c || a),
        fe.dispatchEvent({ type: B.type, data: B.inputSource }));
    }
    function I() {
      r.removeEventListener("select", P),
        r.removeEventListener("selectstart", P),
        r.removeEventListener("selectend", P),
        r.removeEventListener("squeeze", P),
        r.removeEventListener("squeezestart", P),
        r.removeEventListener("squeezeend", P),
        r.removeEventListener("end", I),
        r.removeEventListener("inputsourceschange", X);
      for (let B = 0; B < E.length; B++) {
        const te = v[B];
        te !== null && ((v[B] = null), E[B].disconnect(te));
      }
      (T = null),
        (F = null),
        g.reset(),
        e.setRenderTarget(p),
        (m = null),
        (f = null),
        (h = null),
        (r = null),
        (y = null),
        Q.stop(),
        (n.isPresenting = !1),
        e.setPixelRatio(A),
        e.setSize(C.width, C.height, !1),
        n.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (B) {
      (s = B),
        n.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting.",
          );
    }),
      (this.setReferenceSpaceType = function (B) {
        (o = B),
          n.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting.",
            );
      }),
      (this.getReferenceSpace = function () {
        return c || a;
      }),
      (this.setReferenceSpace = function (B) {
        c = B;
      }),
      (this.getBaseLayer = function () {
        return f !== null ? f : m;
      }),
      (this.getBinding = function () {
        return h;
      }),
      (this.getFrame = function () {
        return x;
      }),
      (this.getSession = function () {
        return r;
      }),
      (this.setSession = async function (B) {
        if (((r = B), r !== null)) {
          if (
            ((p = e.getRenderTarget()),
            r.addEventListener("select", P),
            r.addEventListener("selectstart", P),
            r.addEventListener("selectend", P),
            r.addEventListener("squeeze", P),
            r.addEventListener("squeezestart", P),
            r.addEventListener("squeezeend", P),
            r.addEventListener("end", I),
            r.addEventListener("inputsourceschange", X),
            d.xrCompatible !== !0 && (await t.makeXRCompatible()),
            (A = e.getPixelRatio()),
            e.getSize(C),
            typeof XRWebGLBinding != "undefined" &&
              "createProjectionLayer" in XRWebGLBinding.prototype)
          ) {
            let fe = null,
              he = null,
              de = null;
            d.depth &&
              ((de = d.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (fe = d.stencil ? hr : rr),
              (he = d.stencil ? fr : Ti));
            const Qe = {
              colorFormat: t.RGBA8,
              depthFormat: de,
              scaleFactor: s,
            };
            (h = new XRWebGLBinding(r, t)),
              (f = h.createProjectionLayer(Qe)),
              r.updateRenderState({ layers: [f] }),
              e.setPixelRatio(1),
              e.setSize(f.textureWidth, f.textureHeight, !1),
              (y = new Ci(f.textureWidth, f.textureHeight, {
                format: Sn,
                type: Wn,
                depthTexture: new Sh(
                  f.textureWidth,
                  f.textureHeight,
                  he,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  fe,
                ),
                stencilBuffer: d.stencil,
                colorSpace: e.outputColorSpace,
                samples: d.antialias ? 4 : 0,
                resolveDepthBuffer: f.ignoreDepthValues === !1,
              }));
          } else {
            const fe = {
              antialias: d.antialias,
              alpha: !0,
              depth: d.depth,
              stencil: d.stencil,
              framebufferScaleFactor: s,
            };
            (m = new XRWebGLLayer(r, t, fe)),
              r.updateRenderState({ baseLayer: m }),
              e.setPixelRatio(1),
              e.setSize(m.framebufferWidth, m.framebufferHeight, !1),
              (y = new Ci(m.framebufferWidth, m.framebufferHeight, {
                format: Sn,
                type: Wn,
                colorSpace: e.outputColorSpace,
                stencilBuffer: d.stencil,
              }));
          }
          (y.isXRRenderTarget = !0),
            this.setFoveation(l),
            (c = null),
            (a = await r.requestReferenceSpace(o)),
            Q.setContext(r),
            Q.start(),
            (n.isPresenting = !0),
            n.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (r !== null) return r.environmentBlendMode;
      }),
      (this.getDepthTexture = function () {
        return g.getDepthTexture();
      });
    function X(B) {
      for (let te = 0; te < B.removed.length; te++) {
        const fe = B.removed[te],
          he = v.indexOf(fe);
        he >= 0 && ((v[he] = null), E[he].disconnect(fe));
      }
      for (let te = 0; te < B.added.length; te++) {
        const fe = B.added[te];
        let he = v.indexOf(fe);
        if (he === -1) {
          for (let Qe = 0; Qe < E.length; Qe++)
            if (Qe >= v.length) {
              v.push(fe), (he = Qe);
              break;
            } else if (v[Qe] === null) {
              (v[Qe] = fe), (he = Qe);
              break;
            }
          if (he === -1) break;
        }
        const de = E[he];
        de && de.connect(fe);
      }
    }
    const V = new W(),
      ie = new W();
    function k(B, te, fe) {
      V.setFromMatrixPosition(te.matrixWorld),
        ie.setFromMatrixPosition(fe.matrixWorld);
      const he = V.distanceTo(ie),
        de = te.projectionMatrix.elements,
        Qe = fe.projectionMatrix.elements,
        Oe = de[14] / (de[10] - 1),
        St = de[14] / (de[10] + 1),
        Xe = (de[9] + 1) / de[5],
        ze = (de[9] - 1) / de[5],
        L = (de[8] - 1) / de[0],
        Lt = (Qe[8] + 1) / Qe[0],
        We = Oe * L,
        Ke = Oe * Lt,
        Be = he / (-L + Lt),
        ht = Be * -L;
      if (
        (te.matrixWorld.decompose(B.position, B.quaternion, B.scale),
        B.translateX(ht),
        B.translateZ(Be),
        B.matrixWorld.compose(B.position, B.quaternion, B.scale),
        B.matrixWorldInverse.copy(B.matrixWorld).invert(),
        de[10] === -1)
      )
        B.projectionMatrix.copy(te.projectionMatrix),
          B.projectionMatrixInverse.copy(te.projectionMatrixInverse);
      else {
        const Fe = Oe + Be,
          D = St + Be,
          b = We - ht,
          q = Ke + (he - ht),
          ne = ((Xe * St) / D) * Fe,
          se = ((ze * St) / D) * Fe;
        B.projectionMatrix.makePerspective(b, q, ne, se, Fe, D),
          B.projectionMatrixInverse.copy(B.projectionMatrix).invert();
      }
    }
    function ae(B, te) {
      te === null
        ? B.matrixWorld.copy(B.matrix)
        : B.matrixWorld.multiplyMatrices(te.matrixWorld, B.matrix),
        B.matrixWorldInverse.copy(B.matrixWorld).invert();
    }
    this.updateCamera = function (B) {
      if (r === null) return;
      let te = B.near,
        fe = B.far;
      g.texture !== null &&
        (g.depthNear > 0 && (te = g.depthNear),
        g.depthFar > 0 && (fe = g.depthFar)),
        (_.near = R.near = S.near = te),
        (_.far = R.far = S.far = fe),
        (T !== _.near || F !== _.far) &&
          (r.updateRenderState({ depthNear: _.near, depthFar: _.far }),
          (T = _.near),
          (F = _.far)),
        (S.layers.mask = B.layers.mask | 2),
        (R.layers.mask = B.layers.mask | 4),
        (_.layers.mask = S.layers.mask | R.layers.mask);
      const he = B.parent,
        de = _.cameras;
      ae(_, he);
      for (let Qe = 0; Qe < de.length; Qe++) ae(de[Qe], he);
      de.length === 2
        ? k(_, S, R)
        : _.projectionMatrix.copy(S.projectionMatrix),
        ce(B, _, he);
    };
    function ce(B, te, fe) {
      fe === null
        ? B.matrix.copy(te.matrixWorld)
        : (B.matrix.copy(fe.matrixWorld),
          B.matrix.invert(),
          B.matrix.multiply(te.matrixWorld)),
        B.matrix.decompose(B.position, B.quaternion, B.scale),
        B.updateMatrixWorld(!0),
        B.projectionMatrix.copy(te.projectionMatrix),
        B.projectionMatrixInverse.copy(te.projectionMatrixInverse),
        B.isPerspectiveCamera &&
          ((B.fov = Tc * 2 * Math.atan(1 / B.projectionMatrix.elements[5])),
          (B.zoom = 1));
    }
    (this.getCamera = function () {
      return _;
    }),
      (this.getFoveation = function () {
        if (!(f === null && m === null)) return l;
      }),
      (this.setFoveation = function (B) {
        (l = B),
          f !== null && (f.fixedFoveation = B),
          m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = B);
      }),
      (this.hasDepthSensing = function () {
        return g.texture !== null;
      }),
      (this.getDepthSensingMesh = function () {
        return g.getMesh(_);
      });
    let H = null;
    function K(B, te) {
      if (((u = te.getViewerPose(c || a)), (x = te), u !== null)) {
        const fe = u.views;
        m !== null &&
          (e.setRenderTargetFramebuffer(y, m.framebuffer),
          e.setRenderTarget(y));
        let he = !1;
        fe.length !== _.cameras.length && ((_.cameras.length = 0), (he = !0));
        for (let Oe = 0; Oe < fe.length; Oe++) {
          const St = fe[Oe];
          let Xe = null;
          if (m !== null) Xe = m.getViewport(St);
          else {
            const L = h.getViewSubImage(f, St);
            (Xe = L.viewport),
              Oe === 0 &&
                (e.setRenderTargetTextures(
                  y,
                  L.colorTexture,
                  f.ignoreDepthValues ? void 0 : L.depthStencilTexture,
                ),
                e.setRenderTarget(y));
          }
          let ze = M[Oe];
          ze === void 0 &&
            ((ze = new dn()),
            ze.layers.enable(Oe),
            (ze.viewport = new yt()),
            (M[Oe] = ze)),
            ze.matrix.fromArray(St.transform.matrix),
            ze.matrix.decompose(ze.position, ze.quaternion, ze.scale),
            ze.projectionMatrix.fromArray(St.projectionMatrix),
            ze.projectionMatrixInverse.copy(ze.projectionMatrix).invert(),
            ze.viewport.set(Xe.x, Xe.y, Xe.width, Xe.height),
            Oe === 0 &&
              (_.matrix.copy(ze.matrix),
              _.matrix.decompose(_.position, _.quaternion, _.scale)),
            he === !0 && _.cameras.push(ze);
        }
        const de = r.enabledFeatures;
        if (
          de &&
          de.includes("depth-sensing") &&
          r.depthUsage == "gpu-optimized" &&
          h
        ) {
          const Oe = h.getDepthInformation(fe[0]);
          Oe && Oe.isValid && Oe.texture && g.init(e, Oe, r.renderState);
        }
      }
      for (let fe = 0; fe < E.length; fe++) {
        const he = v[fe],
          de = E[fe];
        he !== null && de !== void 0 && de.update(he, te, c || a);
      }
      H && H(B, te),
        te.detectedPlanes &&
          n.dispatchEvent({ type: "planesdetected", data: te }),
        (x = null);
    }
    const Q = new Th();
    Q.setAnimationLoop(K),
      (this.setAnimationLoop = function (B) {
        H = B;
      }),
      (this.dispose = function () {});
  }
}
const mi = new Pn(),
  z1 = new Tt();
function k1(i, e) {
  function t(d, p) {
    d.matrixAutoUpdate === !0 && d.updateMatrix(), p.value.copy(d.matrix);
  }
  function n(d, p) {
    p.color.getRGB(d.fogColor.value, _h(i)),
      p.isFog
        ? ((d.fogNear.value = p.near), (d.fogFar.value = p.far))
        : p.isFogExp2 && (d.fogDensity.value = p.density);
  }
  function r(d, p, y, E, v) {
    p.isMeshBasicMaterial || p.isMeshLambertMaterial
      ? s(d, p)
      : p.isMeshToonMaterial
        ? (s(d, p), h(d, p))
        : p.isMeshPhongMaterial
          ? (s(d, p), u(d, p))
          : p.isMeshStandardMaterial
            ? (s(d, p), f(d, p), p.isMeshPhysicalMaterial && m(d, p, v))
            : p.isMeshMatcapMaterial
              ? (s(d, p), x(d, p))
              : p.isMeshDepthMaterial
                ? s(d, p)
                : p.isMeshDistanceMaterial
                  ? (s(d, p), g(d, p))
                  : p.isMeshNormalMaterial
                    ? s(d, p)
                    : p.isLineBasicMaterial
                      ? (a(d, p), p.isLineDashedMaterial && o(d, p))
                      : p.isPointsMaterial
                        ? l(d, p, y, E)
                        : p.isSpriteMaterial
                          ? c(d, p)
                          : p.isShadowMaterial
                            ? (d.color.value.copy(p.color),
                              (d.opacity.value = p.opacity))
                            : p.isShaderMaterial && (p.uniformsNeedUpdate = !1);
  }
  function s(d, p) {
    (d.opacity.value = p.opacity),
      p.color && d.diffuse.value.copy(p.color),
      p.emissive &&
        d.emissive.value.copy(p.emissive).multiplyScalar(p.emissiveIntensity),
      p.map && ((d.map.value = p.map), t(p.map, d.mapTransform)),
      p.alphaMap &&
        ((d.alphaMap.value = p.alphaMap), t(p.alphaMap, d.alphaMapTransform)),
      p.bumpMap &&
        ((d.bumpMap.value = p.bumpMap),
        t(p.bumpMap, d.bumpMapTransform),
        (d.bumpScale.value = p.bumpScale),
        p.side === Qt && (d.bumpScale.value *= -1)),
      p.normalMap &&
        ((d.normalMap.value = p.normalMap),
        t(p.normalMap, d.normalMapTransform),
        d.normalScale.value.copy(p.normalScale),
        p.side === Qt && d.normalScale.value.negate()),
      p.displacementMap &&
        ((d.displacementMap.value = p.displacementMap),
        t(p.displacementMap, d.displacementMapTransform),
        (d.displacementScale.value = p.displacementScale),
        (d.displacementBias.value = p.displacementBias)),
      p.emissiveMap &&
        ((d.emissiveMap.value = p.emissiveMap),
        t(p.emissiveMap, d.emissiveMapTransform)),
      p.specularMap &&
        ((d.specularMap.value = p.specularMap),
        t(p.specularMap, d.specularMapTransform)),
      p.alphaTest > 0 && (d.alphaTest.value = p.alphaTest);
    const y = e.get(p),
      E = y.envMap,
      v = y.envMapRotation;
    E &&
      ((d.envMap.value = E),
      mi.copy(v),
      (mi.x *= -1),
      (mi.y *= -1),
      (mi.z *= -1),
      E.isCubeTexture &&
        E.isRenderTargetTexture === !1 &&
        ((mi.y *= -1), (mi.z *= -1)),
      d.envMapRotation.value.setFromMatrix4(z1.makeRotationFromEuler(mi)),
      (d.flipEnvMap.value =
        E.isCubeTexture && E.isRenderTargetTexture === !1 ? -1 : 1),
      (d.reflectivity.value = p.reflectivity),
      (d.ior.value = p.ior),
      (d.refractionRatio.value = p.refractionRatio)),
      p.lightMap &&
        ((d.lightMap.value = p.lightMap),
        (d.lightMapIntensity.value = p.lightMapIntensity),
        t(p.lightMap, d.lightMapTransform)),
      p.aoMap &&
        ((d.aoMap.value = p.aoMap),
        (d.aoMapIntensity.value = p.aoMapIntensity),
        t(p.aoMap, d.aoMapTransform));
  }
  function a(d, p) {
    d.diffuse.value.copy(p.color),
      (d.opacity.value = p.opacity),
      p.map && ((d.map.value = p.map), t(p.map, d.mapTransform));
  }
  function o(d, p) {
    (d.dashSize.value = p.dashSize),
      (d.totalSize.value = p.dashSize + p.gapSize),
      (d.scale.value = p.scale);
  }
  function l(d, p, y, E) {
    d.diffuse.value.copy(p.color),
      (d.opacity.value = p.opacity),
      (d.size.value = p.size * y),
      (d.scale.value = E * 0.5),
      p.map && ((d.map.value = p.map), t(p.map, d.uvTransform)),
      p.alphaMap &&
        ((d.alphaMap.value = p.alphaMap), t(p.alphaMap, d.alphaMapTransform)),
      p.alphaTest > 0 && (d.alphaTest.value = p.alphaTest);
  }
  function c(d, p) {
    d.diffuse.value.copy(p.color),
      (d.opacity.value = p.opacity),
      (d.rotation.value = p.rotation),
      p.map && ((d.map.value = p.map), t(p.map, d.mapTransform)),
      p.alphaMap &&
        ((d.alphaMap.value = p.alphaMap), t(p.alphaMap, d.alphaMapTransform)),
      p.alphaTest > 0 && (d.alphaTest.value = p.alphaTest);
  }
  function u(d, p) {
    d.specular.value.copy(p.specular),
      (d.shininess.value = Math.max(p.shininess, 1e-4));
  }
  function h(d, p) {
    p.gradientMap && (d.gradientMap.value = p.gradientMap);
  }
  function f(d, p) {
    (d.metalness.value = p.metalness),
      p.metalnessMap &&
        ((d.metalnessMap.value = p.metalnessMap),
        t(p.metalnessMap, d.metalnessMapTransform)),
      (d.roughness.value = p.roughness),
      p.roughnessMap &&
        ((d.roughnessMap.value = p.roughnessMap),
        t(p.roughnessMap, d.roughnessMapTransform)),
      p.envMap && (d.envMapIntensity.value = p.envMapIntensity);
  }
  function m(d, p, y) {
    (d.ior.value = p.ior),
      p.sheen > 0 &&
        (d.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen),
        (d.sheenRoughness.value = p.sheenRoughness),
        p.sheenColorMap &&
          ((d.sheenColorMap.value = p.sheenColorMap),
          t(p.sheenColorMap, d.sheenColorMapTransform)),
        p.sheenRoughnessMap &&
          ((d.sheenRoughnessMap.value = p.sheenRoughnessMap),
          t(p.sheenRoughnessMap, d.sheenRoughnessMapTransform))),
      p.clearcoat > 0 &&
        ((d.clearcoat.value = p.clearcoat),
        (d.clearcoatRoughness.value = p.clearcoatRoughness),
        p.clearcoatMap &&
          ((d.clearcoatMap.value = p.clearcoatMap),
          t(p.clearcoatMap, d.clearcoatMapTransform)),
        p.clearcoatRoughnessMap &&
          ((d.clearcoatRoughnessMap.value = p.clearcoatRoughnessMap),
          t(p.clearcoatRoughnessMap, d.clearcoatRoughnessMapTransform)),
        p.clearcoatNormalMap &&
          ((d.clearcoatNormalMap.value = p.clearcoatNormalMap),
          t(p.clearcoatNormalMap, d.clearcoatNormalMapTransform),
          d.clearcoatNormalScale.value.copy(p.clearcoatNormalScale),
          p.side === Qt && d.clearcoatNormalScale.value.negate())),
      p.dispersion > 0 && (d.dispersion.value = p.dispersion),
      p.iridescence > 0 &&
        ((d.iridescence.value = p.iridescence),
        (d.iridescenceIOR.value = p.iridescenceIOR),
        (d.iridescenceThicknessMinimum.value = p.iridescenceThicknessRange[0]),
        (d.iridescenceThicknessMaximum.value = p.iridescenceThicknessRange[1]),
        p.iridescenceMap &&
          ((d.iridescenceMap.value = p.iridescenceMap),
          t(p.iridescenceMap, d.iridescenceMapTransform)),
        p.iridescenceThicknessMap &&
          ((d.iridescenceThicknessMap.value = p.iridescenceThicknessMap),
          t(p.iridescenceThicknessMap, d.iridescenceThicknessMapTransform))),
      p.transmission > 0 &&
        ((d.transmission.value = p.transmission),
        (d.transmissionSamplerMap.value = y.texture),
        d.transmissionSamplerSize.value.set(y.width, y.height),
        p.transmissionMap &&
          ((d.transmissionMap.value = p.transmissionMap),
          t(p.transmissionMap, d.transmissionMapTransform)),
        (d.thickness.value = p.thickness),
        p.thicknessMap &&
          ((d.thicknessMap.value = p.thicknessMap),
          t(p.thicknessMap, d.thicknessMapTransform)),
        (d.attenuationDistance.value = p.attenuationDistance),
        d.attenuationColor.value.copy(p.attenuationColor)),
      p.anisotropy > 0 &&
        (d.anisotropyVector.value.set(
          p.anisotropy * Math.cos(p.anisotropyRotation),
          p.anisotropy * Math.sin(p.anisotropyRotation),
        ),
        p.anisotropyMap &&
          ((d.anisotropyMap.value = p.anisotropyMap),
          t(p.anisotropyMap, d.anisotropyMapTransform))),
      (d.specularIntensity.value = p.specularIntensity),
      d.specularColor.value.copy(p.specularColor),
      p.specularColorMap &&
        ((d.specularColorMap.value = p.specularColorMap),
        t(p.specularColorMap, d.specularColorMapTransform)),
      p.specularIntensityMap &&
        ((d.specularIntensityMap.value = p.specularIntensityMap),
        t(p.specularIntensityMap, d.specularIntensityMapTransform));
  }
  function x(d, p) {
    p.matcap && (d.matcap.value = p.matcap);
  }
  function g(d, p) {
    const y = e.get(p).light;
    d.referencePosition.value.setFromMatrixPosition(y.matrixWorld),
      (d.nearDistance.value = y.shadow.camera.near),
      (d.farDistance.value = y.shadow.camera.far);
  }
  return { refreshFogUniforms: n, refreshMaterialUniforms: r };
}
function H1(i, e, t, n) {
  let r = {},
    s = {},
    a = [];
  const o = i.getParameter(i.MAX_UNIFORM_BUFFER_BINDINGS);
  function l(y, E) {
    const v = E.program;
    n.uniformBlockBinding(y, v);
  }
  function c(y, E) {
    let v = r[y.id];
    v === void 0 &&
      (x(y), (v = u(y)), (r[y.id] = v), y.addEventListener("dispose", d));
    const C = E.program;
    n.updateUBOMapping(y, C);
    const A = e.render.frame;
    s[y.id] !== A && (f(y), (s[y.id] = A));
  }
  function u(y) {
    const E = h();
    y.__bindingPointIndex = E;
    const v = i.createBuffer(),
      C = y.__size,
      A = y.usage;
    return (
      i.bindBuffer(i.UNIFORM_BUFFER, v),
      i.bufferData(i.UNIFORM_BUFFER, C, A),
      i.bindBuffer(i.UNIFORM_BUFFER, null),
      i.bindBufferBase(i.UNIFORM_BUFFER, E, v),
      v
    );
  }
  function h() {
    for (let y = 0; y < o; y++) if (a.indexOf(y) === -1) return a.push(y), y;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.",
      ),
      0
    );
  }
  function f(y) {
    const E = r[y.id],
      v = y.uniforms,
      C = y.__cache;
    i.bindBuffer(i.UNIFORM_BUFFER, E);
    for (let A = 0, S = v.length; A < S; A++) {
      const R = Array.isArray(v[A]) ? v[A] : [v[A]];
      for (let M = 0, _ = R.length; M < _; M++) {
        const T = R[M];
        if (m(T, A, M, C) === !0) {
          const F = T.__offset,
            P = Array.isArray(T.value) ? T.value : [T.value];
          let I = 0;
          for (let X = 0; X < P.length; X++) {
            const V = P[X],
              ie = g(V);
            typeof V == "number" || typeof V == "boolean"
              ? ((T.__data[0] = V),
                i.bufferSubData(i.UNIFORM_BUFFER, F + I, T.__data))
              : V.isMatrix3
                ? ((T.__data[0] = V.elements[0]),
                  (T.__data[1] = V.elements[1]),
                  (T.__data[2] = V.elements[2]),
                  (T.__data[3] = 0),
                  (T.__data[4] = V.elements[3]),
                  (T.__data[5] = V.elements[4]),
                  (T.__data[6] = V.elements[5]),
                  (T.__data[7] = 0),
                  (T.__data[8] = V.elements[6]),
                  (T.__data[9] = V.elements[7]),
                  (T.__data[10] = V.elements[8]),
                  (T.__data[11] = 0))
                : (V.toArray(T.__data, I),
                  (I += ie.storage / Float32Array.BYTES_PER_ELEMENT));
          }
          i.bufferSubData(i.UNIFORM_BUFFER, F, T.__data);
        }
      }
    }
    i.bindBuffer(i.UNIFORM_BUFFER, null);
  }
  function m(y, E, v, C) {
    const A = y.value,
      S = E + "_" + v;
    if (C[S] === void 0)
      return (
        typeof A == "number" || typeof A == "boolean"
          ? (C[S] = A)
          : (C[S] = A.clone()),
        !0
      );
    {
      const R = C[S];
      if (typeof A == "number" || typeof A == "boolean") {
        if (R !== A) return (C[S] = A), !0;
      } else if (R.equals(A) === !1) return R.copy(A), !0;
    }
    return !1;
  }
  function x(y) {
    const E = y.uniforms;
    let v = 0;
    const C = 16;
    for (let S = 0, R = E.length; S < R; S++) {
      const M = Array.isArray(E[S]) ? E[S] : [E[S]];
      for (let _ = 0, T = M.length; _ < T; _++) {
        const F = M[_],
          P = Array.isArray(F.value) ? F.value : [F.value];
        for (let I = 0, X = P.length; I < X; I++) {
          const V = P[I],
            ie = g(V),
            k = v % C,
            ae = k % ie.boundary,
            ce = k + ae;
          (v += ae),
            ce !== 0 && C - ce < ie.storage && (v += C - ce),
            (F.__data = new Float32Array(
              ie.storage / Float32Array.BYTES_PER_ELEMENT,
            )),
            (F.__offset = v),
            (v += ie.storage);
        }
      }
    }
    const A = v % C;
    return A > 0 && (v += C - A), (y.__size = v), (y.__cache = {}), this;
  }
  function g(y) {
    const E = { boundary: 0, storage: 0 };
    return (
      typeof y == "number" || typeof y == "boolean"
        ? ((E.boundary = 4), (E.storage = 4))
        : y.isVector2
          ? ((E.boundary = 8), (E.storage = 8))
          : y.isVector3 || y.isColor
            ? ((E.boundary = 16), (E.storage = 12))
            : y.isVector4
              ? ((E.boundary = 16), (E.storage = 16))
              : y.isMatrix3
                ? ((E.boundary = 48), (E.storage = 48))
                : y.isMatrix4
                  ? ((E.boundary = 64), (E.storage = 64))
                  : y.isTexture
                    ? console.warn(
                        "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.",
                      )
                    : console.warn(
                        "THREE.WebGLRenderer: Unsupported uniform value type.",
                        y,
                      ),
      E
    );
  }
  function d(y) {
    const E = y.target;
    E.removeEventListener("dispose", d);
    const v = a.indexOf(E.__bindingPointIndex);
    a.splice(v, 1), i.deleteBuffer(r[E.id]), delete r[E.id], delete s[E.id];
  }
  function p() {
    for (const y in r) i.deleteBuffer(r[y]);
    (a = []), (r = {}), (s = {});
  }
  return { bind: l, update: c, dispose: p };
}
class SS {
  constructor(e = {}) {
    const {
      canvas: t = vm(),
      context: n = null,
      depth: r = !0,
      stencil: s = !1,
      alpha: a = !1,
      antialias: o = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: u = "default",
      failIfMajorPerformanceCaveat: h = !1,
      reverseDepthBuffer: f = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let m;
    if (n !== null) {
      if (
        typeof WebGLRenderingContext != "undefined" &&
        n instanceof WebGLRenderingContext
      )
        throw new Error(
          "THREE.WebGLRenderer: WebGL 1 is not supported since r163.",
        );
      m = n.getContextAttributes().alpha;
    } else m = a;
    const x = new Uint32Array(4),
      g = new Int32Array(4);
    let d = null,
      p = null;
    const y = [],
      E = [];
    (this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this._outputColorSpace = hn),
      (this.toneMapping = ni),
      (this.toneMappingExposure = 1);
    const v = this;
    let C = !1,
      A = 0,
      S = 0,
      R = null,
      M = -1,
      _ = null;
    const T = new yt(),
      F = new yt();
    let P = null;
    const I = new ut(0);
    let X = 0,
      V = t.width,
      ie = t.height,
      k = 1,
      ae = null,
      ce = null;
    const H = new yt(0, 0, V, ie),
      K = new yt(0, 0, V, ie);
    let Q = !1;
    const B = new Jc();
    let te = !1,
      fe = !1;
    this.transmissionResolutionScale = 1;
    const he = new Tt(),
      de = new Tt(),
      Qe = new W(),
      Oe = new yt(),
      St = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    let Xe = !1;
    function ze() {
      return R === null ? k : 1;
    }
    let L = n;
    function Lt(w, z) {
      return t.getContext(w, z);
    }
    try {
      const w = {
        alpha: !0,
        depth: r,
        stencil: s,
        antialias: o,
        premultipliedAlpha: l,
        preserveDrawingBuffer: c,
        powerPreference: u,
        failIfMajorPerformanceCaveat: h,
      };
      if (
        ("setAttribute" in t &&
          t.setAttribute("data-engine", `three.js r${Wc}`),
        t.addEventListener("webglcontextlost", re, !1),
        t.addEventListener("webglcontextrestored", Se, !1),
        t.addEventListener("webglcontextcreationerror", Ee, !1),
        L === null)
      ) {
        const z = "webgl2";
        if (((L = Lt(z, w)), L === null))
          throw Lt(z)
            ? new Error(
                "Error creating WebGL context with your selected attributes.",
              )
            : new Error("Error creating WebGL context.");
      }
    } catch (w) {
      throw (console.error("THREE.WebGLRenderer: " + w.message), w);
    }
    let We,
      Ke,
      Be,
      ht,
      Fe,
      D,
      b,
      q,
      ne,
      se,
      ee,
      Re,
      pe,
      ve,
      et,
      le,
      Me,
      Le,
      ke,
      be,
      tt,
      Ye,
      dt,
      N;
    function ge() {
      (We = new J_(L)),
        We.init(),
        (Ye = new L1(L, We)),
        (Ke = new q_(L, We, e, Ye)),
        (Be = new F1(L, We)),
        Ke.reverseDepthBuffer && f && Be.buffers.depth.setReversed(!0),
        (ht = new tv(L)),
        (Fe = new v1()),
        (D = new B1(L, We, Be, Fe, Ke, Ye, ht)),
        (b = new $_(v)),
        (q = new Z_(v)),
        (ne = new cx(L)),
        (dt = new W_(L, ne)),
        (se = new Q_(L, ne, ht, dt)),
        (ee = new iv(L, se, ne, ht)),
        (ke = new nv(L, Ke, D)),
        (le = new Y_(Fe)),
        (Re = new _1(v, b, q, We, Ke, dt, le)),
        (pe = new k1(v, Fe)),
        (ve = new y1()),
        (et = new C1(We)),
        (Le = new G_(v, b, q, Be, ee, m, l)),
        (Me = new D1(v, ee, Ke)),
        (N = new H1(L, ht, Ke, Be)),
        (be = new X_(L, We, ht)),
        (tt = new ev(L, We, ht)),
        (ht.programs = Re.programs),
        (v.capabilities = Ke),
        (v.extensions = We),
        (v.properties = Fe),
        (v.renderLists = ve),
        (v.shadowMap = Me),
        (v.state = Be),
        (v.info = ht);
    }
    ge();
    const J = new O1(v, L);
    (this.xr = J),
      (this.getContext = function () {
        return L;
      }),
      (this.getContextAttributes = function () {
        return L.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const w = We.get("WEBGL_lose_context");
        w && w.loseContext();
      }),
      (this.forceContextRestore = function () {
        const w = We.get("WEBGL_lose_context");
        w && w.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return k;
      }),
      (this.setPixelRatio = function (w) {
        w !== void 0 && ((k = w), this.setSize(V, ie, !1));
      }),
      (this.getSize = function (w) {
        return w.set(V, ie);
      }),
      (this.setSize = function (w, z, $ = !0) {
        if (J.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting.",
          );
          return;
        }
        (V = w),
          (ie = z),
          (t.width = Math.floor(w * k)),
          (t.height = Math.floor(z * k)),
          $ === !0 && ((t.style.width = w + "px"), (t.style.height = z + "px")),
          this.setViewport(0, 0, w, z);
      }),
      (this.getDrawingBufferSize = function (w) {
        return w.set(V * k, ie * k).floor();
      }),
      (this.setDrawingBufferSize = function (w, z, $) {
        (V = w),
          (ie = z),
          (k = $),
          (t.width = Math.floor(w * $)),
          (t.height = Math.floor(z * $)),
          this.setViewport(0, 0, w, z);
      }),
      (this.getCurrentViewport = function (w) {
        return w.copy(T);
      }),
      (this.getViewport = function (w) {
        return w.copy(H);
      }),
      (this.setViewport = function (w, z, $, j) {
        w.isVector4 ? H.set(w.x, w.y, w.z, w.w) : H.set(w, z, $, j),
          Be.viewport(T.copy(H).multiplyScalar(k).round());
      }),
      (this.getScissor = function (w) {
        return w.copy(K);
      }),
      (this.setScissor = function (w, z, $, j) {
        w.isVector4 ? K.set(w.x, w.y, w.z, w.w) : K.set(w, z, $, j),
          Be.scissor(F.copy(K).multiplyScalar(k).round());
      }),
      (this.getScissorTest = function () {
        return Q;
      }),
      (this.setScissorTest = function (w) {
        Be.setScissorTest((Q = w));
      }),
      (this.setOpaqueSort = function (w) {
        ae = w;
      }),
      (this.setTransparentSort = function (w) {
        ce = w;
      }),
      (this.getClearColor = function (w) {
        return w.copy(Le.getClearColor());
      }),
      (this.setClearColor = function () {
        Le.setClearColor.apply(Le, arguments);
      }),
      (this.getClearAlpha = function () {
        return Le.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        Le.setClearAlpha.apply(Le, arguments);
      }),
      (this.clear = function (w = !0, z = !0, $ = !0) {
        let j = 0;
        if (w) {
          let G = !1;
          if (R !== null) {
            const ue = R.texture.format;
            G = ue === Zc || ue === Kc || ue === jc;
          }
          if (G) {
            const ue = R.texture.type,
              xe =
                ue === Wn ||
                ue === Ti ||
                ue === zr ||
                ue === fr ||
                ue === Yc ||
                ue === $c,
              Ae = Le.getClearColor(),
              Te = Le.getClearAlpha(),
              _e = Ae.r,
              we = Ae.g,
              Ie = Ae.b;
            xe
              ? ((x[0] = _e),
                (x[1] = we),
                (x[2] = Ie),
                (x[3] = Te),
                L.clearBufferuiv(L.COLOR, 0, x))
              : ((g[0] = _e),
                (g[1] = we),
                (g[2] = Ie),
                (g[3] = Te),
                L.clearBufferiv(L.COLOR, 0, g));
          } else j |= L.COLOR_BUFFER_BIT;
        }
        z && (j |= L.DEPTH_BUFFER_BIT),
          $ &&
            ((j |= L.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          L.clear(j);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        t.removeEventListener("webglcontextlost", re, !1),
          t.removeEventListener("webglcontextrestored", Se, !1),
          t.removeEventListener("webglcontextcreationerror", Ee, !1),
          Le.dispose(),
          ve.dispose(),
          et.dispose(),
          Fe.dispose(),
          b.dispose(),
          q.dispose(),
          ee.dispose(),
          dt.dispose(),
          N.dispose(),
          Re.dispose(),
          J.dispose(),
          J.removeEventListener("sessionstart", U),
          J.removeEventListener("sessionend", O),
          Y.stop();
      });
    function re(w) {
      w.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (C = !0);
    }
    function Se() {
      console.log("THREE.WebGLRenderer: Context Restored."), (C = !1);
      const w = ht.autoReset,
        z = Me.enabled,
        $ = Me.autoUpdate,
        j = Me.needsUpdate,
        G = Me.type;
      ge(),
        (ht.autoReset = w),
        (Me.enabled = z),
        (Me.autoUpdate = $),
        (Me.needsUpdate = j),
        (Me.type = G);
    }
    function Ee(w) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        w.statusMessage,
      );
    }
    function qe(w) {
      const z = w.target;
      z.removeEventListener("dispose", qe), gt(z);
    }
    function gt(w) {
      Dt(w), Fe.remove(w);
    }
    function Dt(w) {
      const z = Fe.get(w).programs;
      z !== void 0 &&
        (z.forEach(function ($) {
          Re.releaseProgram($);
        }),
        w.isShaderMaterial && Re.releaseShaderCache(w));
    }
    this.renderBufferDirect = function (w, z, $, j, G, ue) {
      z === null && (z = St);
      const xe = G.isMesh && G.matrixWorld.determinant() < 0,
        Ae = $e(w, z, $, j, G);
      Be.setMaterial(j, xe);
      let Te = $.index,
        _e = 1;
      if (j.wireframe === !0) {
        if (((Te = se.getWireframeAttribute($)), Te === void 0)) return;
        _e = 2;
      }
      const we = $.drawRange,
        Ie = $.attributes.position;
      let nt = we.start * _e,
        Ve = (we.start + we.count) * _e;
      ue !== null &&
        ((nt = Math.max(nt, ue.start * _e)),
        (Ve = Math.min(Ve, (ue.start + ue.count) * _e))),
        Te !== null
          ? ((nt = Math.max(nt, 0)), (Ve = Math.min(Ve, Te.count)))
          : Ie != null &&
            ((nt = Math.max(nt, 0)), (Ve = Math.min(Ve, Ie.count)));
      const Mt = Ve - nt;
      if (Mt < 0 || Mt === 1 / 0) return;
      dt.setup(G, j, Ae, $, Te);
      let bt,
        lt = be;
      if (
        (Te !== null && ((bt = ne.get(Te)), (lt = tt), lt.setIndex(bt)),
        G.isMesh)
      )
        j.wireframe === !0
          ? (Be.setLineWidth(j.wireframeLinewidth * ze()), lt.setMode(L.LINES))
          : lt.setMode(L.TRIANGLES);
      else if (G.isLine) {
        let Ge = j.linewidth;
        Ge === void 0 && (Ge = 1),
          Be.setLineWidth(Ge * ze()),
          G.isLineSegments
            ? lt.setMode(L.LINES)
            : G.isLineLoop
              ? lt.setMode(L.LINE_LOOP)
              : lt.setMode(L.LINE_STRIP);
      } else
        G.isPoints
          ? lt.setMode(L.POINTS)
          : G.isSprite && lt.setMode(L.TRIANGLES);
      if (G.isBatchedMesh)
        if (G._multiDrawInstances !== null)
          lt.renderMultiDrawInstances(
            G._multiDrawStarts,
            G._multiDrawCounts,
            G._multiDrawCount,
            G._multiDrawInstances,
          );
        else if (We.get("WEBGL_multi_draw"))
          lt.renderMultiDraw(
            G._multiDrawStarts,
            G._multiDrawCounts,
            G._multiDrawCount,
          );
        else {
          const Ge = G._multiDrawStarts,
            Ht = G._multiDrawCounts,
            mt = G._multiDrawCount,
            xn = Te ? ne.get(Te).bytesPerElement : 1,
            Bi = Fe.get(j).currentProgram.getUniforms();
          for (let rn = 0; rn < mt; rn++)
            Bi.setValue(L, "_gl_DrawID", rn), lt.render(Ge[rn] / xn, Ht[rn]);
        }
      else if (G.isInstancedMesh) lt.renderInstances(nt, Mt, G.count);
      else if ($.isInstancedBufferGeometry) {
        const Ge = $._maxInstanceCount !== void 0 ? $._maxInstanceCount : 1 / 0,
          Ht = Math.min($.instanceCount, Ge);
        lt.renderInstances(nt, Mt, Ht);
      } else lt.render(nt, Mt);
    };
    function rt(w, z, $) {
      w.transparent === !0 && w.side === zn && w.forceSinglePass === !1
        ? ((w.side = Qt),
          (w.needsUpdate = !0),
          Pe(w, z, $),
          (w.side = si),
          (w.needsUpdate = !0),
          Pe(w, z, $),
          (w.side = zn))
        : Pe(w, z, $);
    }
    (this.compile = function (w, z, $ = null) {
      $ === null && ($ = w),
        (p = et.get($)),
        p.init(z),
        E.push(p),
        $.traverseVisible(function (G) {
          G.isLight &&
            G.layers.test(z.layers) &&
            (p.pushLight(G), G.castShadow && p.pushShadow(G));
        }),
        w !== $ &&
          w.traverseVisible(function (G) {
            G.isLight &&
              G.layers.test(z.layers) &&
              (p.pushLight(G), G.castShadow && p.pushShadow(G));
          }),
        p.setupLights();
      const j = new Set();
      return (
        w.traverse(function (G) {
          if (!(G.isMesh || G.isPoints || G.isLine || G.isSprite)) return;
          const ue = G.material;
          if (ue)
            if (Array.isArray(ue))
              for (let xe = 0; xe < ue.length; xe++) {
                const Ae = ue[xe];
                rt(Ae, $, G), j.add(Ae);
              }
            else rt(ue, $, G), j.add(ue);
        }),
        E.pop(),
        (p = null),
        j
      );
    }),
      (this.compileAsync = function (w, z, $ = null) {
        const j = this.compile(w, z, $);
        return new Promise((G) => {
          function ue() {
            if (
              (j.forEach(function (xe) {
                Fe.get(xe).currentProgram.isReady() && j.delete(xe);
              }),
              j.size === 0)
            ) {
              G(w);
              return;
            }
            setTimeout(ue, 10);
          }
          We.get("KHR_parallel_shader_compile") !== null
            ? ue()
            : setTimeout(ue, 10);
        });
      });
    let Vt = null;
    function nn(w) {
      Vt && Vt(w);
    }
    function U() {
      Y.stop();
    }
    function O() {
      Y.start();
    }
    const Y = new Th();
    Y.setAnimationLoop(nn),
      typeof self != "undefined" && Y.setContext(self),
      (this.setAnimationLoop = function (w) {
        (Vt = w), J.setAnimationLoop(w), w === null ? Y.stop() : Y.start();
      }),
      J.addEventListener("sessionstart", U),
      J.addEventListener("sessionend", O),
      (this.render = function (w, z) {
        if (z !== void 0 && z.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.",
          );
          return;
        }
        if (C === !0) return;
        if (
          (w.matrixWorldAutoUpdate === !0 && w.updateMatrixWorld(),
          z.parent === null &&
            z.matrixWorldAutoUpdate === !0 &&
            z.updateMatrixWorld(),
          J.enabled === !0 &&
            J.isPresenting === !0 &&
            (J.cameraAutoUpdate === !0 && J.updateCamera(z),
            (z = J.getCamera())),
          w.isScene === !0 && w.onBeforeRender(v, w, z, R),
          (p = et.get(w, E.length)),
          p.init(z),
          E.push(p),
          de.multiplyMatrices(z.projectionMatrix, z.matrixWorldInverse),
          B.setFromProjectionMatrix(de),
          (fe = this.localClippingEnabled),
          (te = le.init(this.clippingPlanes, fe)),
          (d = ve.get(w, y.length)),
          d.init(),
          y.push(d),
          J.enabled === !0 && J.isPresenting === !0)
        ) {
          const ue = v.xr.getDepthSensingMesh();
          ue !== null && oe(ue, z, -1 / 0, v.sortObjects);
        }
        oe(w, z, 0, v.sortObjects),
          d.finish(),
          v.sortObjects === !0 && d.sort(ae, ce),
          (Xe =
            J.enabled === !1 ||
            J.isPresenting === !1 ||
            J.hasDepthSensing() === !1),
          Xe && Le.addToRenderList(d, w),
          this.info.render.frame++,
          te === !0 && le.beginShadows();
        const $ = p.state.shadowsArray;
        Me.render($, w, z),
          te === !0 && le.endShadows(),
          this.info.autoReset === !0 && this.info.reset();
        const j = d.opaque,
          G = d.transmissive;
        if ((p.setupLights(), z.isArrayCamera)) {
          const ue = z.cameras;
          if (G.length > 0)
            for (let xe = 0, Ae = ue.length; xe < Ae; xe++) {
              const Te = ue[xe];
              Ne(j, G, w, Te);
            }
          Xe && Le.render(w);
          for (let xe = 0, Ae = ue.length; xe < Ae; xe++) {
            const Te = ue[xe];
            me(d, w, Te, Te.viewport);
          }
        } else G.length > 0 && Ne(j, G, w, z), Xe && Le.render(w), me(d, w, z);
        R !== null &&
          S === 0 &&
          (D.updateMultisampleRenderTarget(R), D.updateRenderTargetMipmap(R)),
          w.isScene === !0 && w.onAfterRender(v, w, z),
          dt.resetDefaultState(),
          (M = -1),
          (_ = null),
          E.pop(),
          E.length > 0
            ? ((p = E[E.length - 1]),
              te === !0 && le.setGlobalState(v.clippingPlanes, p.state.camera))
            : (p = null),
          y.pop(),
          y.length > 0 ? (d = y[y.length - 1]) : (d = null);
      });
    function oe(w, z, $, j) {
      if (w.visible === !1) return;
      if (w.layers.test(z.layers)) {
        if (w.isGroup) $ = w.renderOrder;
        else if (w.isLOD) w.autoUpdate === !0 && w.update(z);
        else if (w.isLight) p.pushLight(w), w.castShadow && p.pushShadow(w);
        else if (w.isSprite) {
          if (!w.frustumCulled || B.intersectsSprite(w)) {
            j && Oe.setFromMatrixPosition(w.matrixWorld).applyMatrix4(de);
            const xe = ee.update(w),
              Ae = w.material;
            Ae.visible && d.push(w, xe, Ae, $, Oe.z, null);
          }
        } else if (
          (w.isMesh || w.isLine || w.isPoints) &&
          (!w.frustumCulled || B.intersectsObject(w))
        ) {
          const xe = ee.update(w),
            Ae = w.material;
          if (
            (j &&
              (w.boundingSphere !== void 0
                ? (w.boundingSphere === null && w.computeBoundingSphere(),
                  Oe.copy(w.boundingSphere.center))
                : (xe.boundingSphere === null && xe.computeBoundingSphere(),
                  Oe.copy(xe.boundingSphere.center)),
              Oe.applyMatrix4(w.matrixWorld).applyMatrix4(de)),
            Array.isArray(Ae))
          ) {
            const Te = xe.groups;
            for (let _e = 0, we = Te.length; _e < we; _e++) {
              const Ie = Te[_e],
                nt = Ae[Ie.materialIndex];
              nt && nt.visible && d.push(w, xe, nt, $, Oe.z, Ie);
            }
          } else Ae.visible && d.push(w, xe, Ae, $, Oe.z, null);
        }
      }
      const ue = w.children;
      for (let xe = 0, Ae = ue.length; xe < Ae; xe++) oe(ue[xe], z, $, j);
    }
    function me(w, z, $, j) {
      const G = w.opaque,
        ue = w.transmissive,
        xe = w.transparent;
      p.setupLightsView($),
        te === !0 && le.setGlobalState(v.clippingPlanes, $),
        j && Be.viewport(T.copy(j)),
        G.length > 0 && He(G, z, $),
        ue.length > 0 && He(ue, z, $),
        xe.length > 0 && He(xe, z, $),
        Be.buffers.depth.setTest(!0),
        Be.buffers.depth.setMask(!0),
        Be.buffers.color.setMask(!0),
        Be.setPolygonOffset(!1);
    }
    function Ne(w, z, $, j) {
      if (($.isScene === !0 ? $.overrideMaterial : null) !== null) return;
      p.state.transmissionRenderTarget[j.id] === void 0 &&
        (p.state.transmissionRenderTarget[j.id] = new Ci(1, 1, {
          generateMipmaps: !0,
          type:
            We.has("EXT_color_buffer_half_float") ||
            We.has("EXT_color_buffer_float")
              ? Vr
              : Wn,
          minFilter: Mi,
          samples: 4,
          stencilBuffer: s,
          resolveDepthBuffer: !1,
          resolveStencilBuffer: !1,
          colorSpace: pt.workingColorSpace,
        }));
      const ue = p.state.transmissionRenderTarget[j.id],
        xe = j.viewport || T;
      ue.setSize(
        xe.z * v.transmissionResolutionScale,
        xe.w * v.transmissionResolutionScale,
      );
      const Ae = v.getRenderTarget();
      v.setRenderTarget(ue),
        v.getClearColor(I),
        (X = v.getClearAlpha()),
        X < 1 && v.setClearColor(16777215, 0.5),
        v.clear(),
        Xe && Le.render($);
      const Te = v.toneMapping;
      v.toneMapping = ni;
      const _e = j.viewport;
      if (
        (j.viewport !== void 0 && (j.viewport = void 0),
        p.setupLightsView(j),
        te === !0 && le.setGlobalState(v.clippingPlanes, j),
        He(w, $, j),
        D.updateMultisampleRenderTarget(ue),
        D.updateRenderTargetMipmap(ue),
        We.has("WEBGL_multisampled_render_to_texture") === !1)
      ) {
        let we = !1;
        for (let Ie = 0, nt = z.length; Ie < nt; Ie++) {
          const Ve = z[Ie],
            Mt = Ve.object,
            bt = Ve.geometry,
            lt = Ve.material,
            Ge = Ve.group;
          if (lt.side === zn && Mt.layers.test(j.layers)) {
            const Ht = lt.side;
            (lt.side = Qt),
              (lt.needsUpdate = !0),
              De(Mt, $, j, bt, lt, Ge),
              (lt.side = Ht),
              (lt.needsUpdate = !0),
              (we = !0);
          }
        }
        we === !0 &&
          (D.updateMultisampleRenderTarget(ue), D.updateRenderTargetMipmap(ue));
      }
      v.setRenderTarget(Ae),
        v.setClearColor(I, X),
        _e !== void 0 && (j.viewport = _e),
        (v.toneMapping = Te);
    }
    function He(w, z, $) {
      const j = z.isScene === !0 ? z.overrideMaterial : null;
      for (let G = 0, ue = w.length; G < ue; G++) {
        const xe = w[G],
          Ae = xe.object,
          Te = xe.geometry,
          _e = j === null ? xe.material : j,
          we = xe.group;
        Ae.layers.test($.layers) && De(Ae, z, $, Te, _e, we);
      }
    }
    function De(w, z, $, j, G, ue) {
      w.onBeforeRender(v, z, $, j, G, ue),
        w.modelViewMatrix.multiplyMatrices($.matrixWorldInverse, w.matrixWorld),
        w.normalMatrix.getNormalMatrix(w.modelViewMatrix),
        G.onBeforeRender(v, z, $, j, w, ue),
        G.transparent === !0 && G.side === zn && G.forceSinglePass === !1
          ? ((G.side = Qt),
            (G.needsUpdate = !0),
            v.renderBufferDirect($, z, j, G, w, ue),
            (G.side = si),
            (G.needsUpdate = !0),
            v.renderBufferDirect($, z, j, G, w, ue),
            (G.side = zn))
          : v.renderBufferDirect($, z, j, G, w, ue),
        w.onAfterRender(v, z, $, j, G, ue);
    }
    function Pe(w, z, $) {
      z.isScene !== !0 && (z = St);
      const j = Fe.get(w),
        G = p.state.lights,
        ue = p.state.shadowsArray,
        xe = G.state.version,
        Ae = Re.getParameters(w, G.state, ue, z, $),
        Te = Re.getProgramCacheKey(Ae);
      let _e = j.programs;
      (j.environment = w.isMeshStandardMaterial ? z.environment : null),
        (j.fog = z.fog),
        (j.envMap = (w.isMeshStandardMaterial ? q : b).get(
          w.envMap || j.environment,
        )),
        (j.envMapRotation =
          j.environment !== null && w.envMap === null
            ? z.environmentRotation
            : w.envMapRotation),
        _e === void 0 &&
          (w.addEventListener("dispose", qe),
          (_e = new Map()),
          (j.programs = _e));
      let we = _e.get(Te);
      if (we !== void 0) {
        if (j.currentProgram === we && j.lightsStateVersion === xe)
          return Ue(w, Ae), we;
      } else
        (Ae.uniforms = Re.getUniforms(w)),
          w.onBeforeCompile(Ae, v),
          (we = Re.acquireProgram(Ae, Te)),
          _e.set(Te, we),
          (j.uniforms = Ae.uniforms);
      const Ie = j.uniforms;
      return (
        ((!w.isShaderMaterial && !w.isRawShaderMaterial) ||
          w.clipping === !0) &&
          (Ie.clippingPlanes = le.uniform),
        Ue(w, Ae),
        (j.needsLights = Ut(w)),
        (j.lightsStateVersion = xe),
        j.needsLights &&
          ((Ie.ambientLightColor.value = G.state.ambient),
          (Ie.lightProbe.value = G.state.probe),
          (Ie.directionalLights.value = G.state.directional),
          (Ie.directionalLightShadows.value = G.state.directionalShadow),
          (Ie.spotLights.value = G.state.spot),
          (Ie.spotLightShadows.value = G.state.spotShadow),
          (Ie.rectAreaLights.value = G.state.rectArea),
          (Ie.ltc_1.value = G.state.rectAreaLTC1),
          (Ie.ltc_2.value = G.state.rectAreaLTC2),
          (Ie.pointLights.value = G.state.point),
          (Ie.pointLightShadows.value = G.state.pointShadow),
          (Ie.hemisphereLights.value = G.state.hemi),
          (Ie.directionalShadowMap.value = G.state.directionalShadowMap),
          (Ie.directionalShadowMatrix.value = G.state.directionalShadowMatrix),
          (Ie.spotShadowMap.value = G.state.spotShadowMap),
          (Ie.spotLightMatrix.value = G.state.spotLightMatrix),
          (Ie.spotLightMap.value = G.state.spotLightMap),
          (Ie.pointShadowMap.value = G.state.pointShadowMap),
          (Ie.pointShadowMatrix.value = G.state.pointShadowMatrix)),
        (j.currentProgram = we),
        (j.uniformsList = null),
        we
      );
    }
    function Ce(w) {
      if (w.uniformsList === null) {
        const z = w.currentProgram.getUniforms();
        w.uniformsList = ma.seqWithValue(z.seq, w.uniforms);
      }
      return w.uniformsList;
    }
    function Ue(w, z) {
      const $ = Fe.get(w);
      ($.outputColorSpace = z.outputColorSpace),
        ($.batching = z.batching),
        ($.batchingColor = z.batchingColor),
        ($.instancing = z.instancing),
        ($.instancingColor = z.instancingColor),
        ($.instancingMorph = z.instancingMorph),
        ($.skinning = z.skinning),
        ($.morphTargets = z.morphTargets),
        ($.morphNormals = z.morphNormals),
        ($.morphColors = z.morphColors),
        ($.morphTargetsCount = z.morphTargetsCount),
        ($.numClippingPlanes = z.numClippingPlanes),
        ($.numIntersection = z.numClipIntersection),
        ($.vertexAlphas = z.vertexAlphas),
        ($.vertexTangents = z.vertexTangents),
        ($.toneMapping = z.toneMapping);
    }
    function $e(w, z, $, j, G) {
      z.isScene !== !0 && (z = St), D.resetTextureUnits();
      const ue = z.fog,
        xe = j.isMeshStandardMaterial ? z.environment : null,
        Ae =
          R === null
            ? v.outputColorSpace
            : R.isXRRenderTarget === !0
              ? R.texture.colorSpace
              : dr,
        Te = (j.isMeshStandardMaterial ? q : b).get(j.envMap || xe),
        _e =
          j.vertexColors === !0 &&
          !!$.attributes.color &&
          $.attributes.color.itemSize === 4,
        we = !!$.attributes.tangent && (!!j.normalMap || j.anisotropy > 0),
        Ie = !!$.morphAttributes.position,
        nt = !!$.morphAttributes.normal,
        Ve = !!$.morphAttributes.color;
      let Mt = ni;
      j.toneMapped &&
        (R === null || R.isXRRenderTarget === !0) &&
        (Mt = v.toneMapping);
      const bt =
          $.morphAttributes.position ||
          $.morphAttributes.normal ||
          $.morphAttributes.color,
        lt = bt !== void 0 ? bt.length : 0,
        Ge = Fe.get(j),
        Ht = p.state.lights;
      if (te === !0 && (fe === !0 || w !== _)) {
        const $t = w === _ && j.id === M;
        le.setState(j, w, $t);
      }
      let mt = !1;
      j.version === Ge.__version
        ? ((Ge.needsLights && Ge.lightsStateVersion !== Ht.state.version) ||
            Ge.outputColorSpace !== Ae ||
            (G.isBatchedMesh && Ge.batching === !1) ||
            (!G.isBatchedMesh && Ge.batching === !0) ||
            (G.isBatchedMesh &&
              Ge.batchingColor === !0 &&
              G.colorTexture === null) ||
            (G.isBatchedMesh &&
              Ge.batchingColor === !1 &&
              G.colorTexture !== null) ||
            (G.isInstancedMesh && Ge.instancing === !1) ||
            (!G.isInstancedMesh && Ge.instancing === !0) ||
            (G.isSkinnedMesh && Ge.skinning === !1) ||
            (!G.isSkinnedMesh && Ge.skinning === !0) ||
            (G.isInstancedMesh &&
              Ge.instancingColor === !0 &&
              G.instanceColor === null) ||
            (G.isInstancedMesh &&
              Ge.instancingColor === !1 &&
              G.instanceColor !== null) ||
            (G.isInstancedMesh &&
              Ge.instancingMorph === !0 &&
              G.morphTexture === null) ||
            (G.isInstancedMesh &&
              Ge.instancingMorph === !1 &&
              G.morphTexture !== null) ||
            Ge.envMap !== Te ||
            (j.fog === !0 && Ge.fog !== ue) ||
            (Ge.numClippingPlanes !== void 0 &&
              (Ge.numClippingPlanes !== le.numPlanes ||
                Ge.numIntersection !== le.numIntersection)) ||
            Ge.vertexAlphas !== _e ||
            Ge.vertexTangents !== we ||
            Ge.morphTargets !== Ie ||
            Ge.morphNormals !== nt ||
            Ge.morphColors !== Ve ||
            Ge.toneMapping !== Mt ||
            Ge.morphTargetsCount !== lt) &&
          (mt = !0)
        : ((mt = !0), (Ge.__version = j.version));
      let xn = Ge.currentProgram;
      mt === !0 && (xn = Pe(j, z, G));
      let Bi = !1,
        rn = !1,
        yr = !1;
      const wt = xn.getUniforms(),
        ln = Ge.uniforms;
      if (
        (Be.useProgram(xn.program) && ((Bi = !0), (rn = !0), (yr = !0)),
        j.id !== M && ((M = j.id), (rn = !0)),
        Bi || _ !== w)
      ) {
        Be.buffers.depth.getReversed()
          ? (he.copy(w.projectionMatrix),
            ym(he),
            Sm(he),
            wt.setValue(L, "projectionMatrix", he))
          : wt.setValue(L, "projectionMatrix", w.projectionMatrix),
          wt.setValue(L, "viewMatrix", w.matrixWorldInverse);
        const Zt = wt.map.cameraPosition;
        Zt !== void 0 &&
          Zt.setValue(L, Qe.setFromMatrixPosition(w.matrixWorld)),
          Ke.logarithmicDepthBuffer &&
            wt.setValue(
              L,
              "logDepthBufFC",
              2 / (Math.log(w.far + 1) / Math.LN2),
            ),
          (j.isMeshPhongMaterial ||
            j.isMeshToonMaterial ||
            j.isMeshLambertMaterial ||
            j.isMeshBasicMaterial ||
            j.isMeshStandardMaterial ||
            j.isShaderMaterial) &&
            wt.setValue(L, "isOrthographic", w.isOrthographicCamera === !0),
          _ !== w && ((_ = w), (rn = !0), (yr = !0));
      }
      if (G.isSkinnedMesh) {
        wt.setOptional(L, G, "bindMatrix"),
          wt.setOptional(L, G, "bindMatrixInverse");
        const $t = G.skeleton;
        $t &&
          ($t.boneTexture === null && $t.computeBoneTexture(),
          wt.setValue(L, "boneTexture", $t.boneTexture, D));
      }
      G.isBatchedMesh &&
        (wt.setOptional(L, G, "batchingTexture"),
        wt.setValue(L, "batchingTexture", G._matricesTexture, D),
        wt.setOptional(L, G, "batchingIdTexture"),
        wt.setValue(L, "batchingIdTexture", G._indirectTexture, D),
        wt.setOptional(L, G, "batchingColorTexture"),
        G._colorsTexture !== null &&
          wt.setValue(L, "batchingColorTexture", G._colorsTexture, D));
      const un = $.morphAttributes;
      if (
        ((un.position !== void 0 ||
          un.normal !== void 0 ||
          un.color !== void 0) &&
          ke.update(G, $, xn),
        (rn || Ge.receiveShadow !== G.receiveShadow) &&
          ((Ge.receiveShadow = G.receiveShadow),
          wt.setValue(L, "receiveShadow", G.receiveShadow)),
        j.isMeshGouraudMaterial &&
          j.envMap !== null &&
          ((ln.envMap.value = Te),
          (ln.flipEnvMap.value =
            Te.isCubeTexture && Te.isRenderTargetTexture === !1 ? -1 : 1)),
        j.isMeshStandardMaterial &&
          j.envMap === null &&
          z.environment !== null &&
          (ln.envMapIntensity.value = z.environmentIntensity),
        rn &&
          (wt.setValue(L, "toneMappingExposure", v.toneMappingExposure),
          Ge.needsLights && st(ln, yr),
          ue && j.fog === !0 && pe.refreshFogUniforms(ln, ue),
          pe.refreshMaterialUniforms(
            ln,
            j,
            k,
            ie,
            p.state.transmissionRenderTarget[w.id],
          ),
          ma.upload(L, Ce(Ge), ln, D)),
        j.isShaderMaterial &&
          j.uniformsNeedUpdate === !0 &&
          (ma.upload(L, Ce(Ge), ln, D), (j.uniformsNeedUpdate = !1)),
        j.isSpriteMaterial && wt.setValue(L, "center", G.center),
        wt.setValue(L, "modelViewMatrix", G.modelViewMatrix),
        wt.setValue(L, "normalMatrix", G.normalMatrix),
        wt.setValue(L, "modelMatrix", G.matrixWorld),
        j.isShaderMaterial || j.isRawShaderMaterial)
      ) {
        const $t = j.uniformsGroups;
        for (let Zt = 0, Va = $t.length; Zt < Va; Zt++) {
          const ci = $t[Zt];
          N.update(ci, xn), N.bind(ci, xn);
        }
      }
      return xn;
    }
    function st(w, z) {
      (w.ambientLightColor.needsUpdate = z),
        (w.lightProbe.needsUpdate = z),
        (w.directionalLights.needsUpdate = z),
        (w.directionalLightShadows.needsUpdate = z),
        (w.pointLights.needsUpdate = z),
        (w.pointLightShadows.needsUpdate = z),
        (w.spotLights.needsUpdate = z),
        (w.spotLightShadows.needsUpdate = z),
        (w.rectAreaLights.needsUpdate = z),
        (w.hemisphereLights.needsUpdate = z);
    }
    function Ut(w) {
      return (
        w.isMeshLambertMaterial ||
        w.isMeshToonMaterial ||
        w.isMeshPhongMaterial ||
        w.isMeshStandardMaterial ||
        w.isShadowMaterial ||
        (w.isShaderMaterial && w.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return A;
    }),
      (this.getActiveMipmapLevel = function () {
        return S;
      }),
      (this.getRenderTarget = function () {
        return R;
      }),
      (this.setRenderTargetTextures = function (w, z, $) {
        (Fe.get(w.texture).__webglTexture = z),
          (Fe.get(w.depthTexture).__webglTexture = $);
        const j = Fe.get(w);
        (j.__hasExternalTextures = !0),
          (j.__autoAllocateDepthBuffer = $ === void 0),
          j.__autoAllocateDepthBuffer ||
            (We.has("WEBGL_multisampled_render_to_texture") === !0 &&
              (console.warn(
                "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided",
              ),
              (j.__useRenderToTexture = !1)));
      }),
      (this.setRenderTargetFramebuffer = function (w, z) {
        const $ = Fe.get(w);
        ($.__webglFramebuffer = z), ($.__useDefaultFramebuffer = z === void 0);
      });
    const _t = L.createFramebuffer();
    (this.setRenderTarget = function (w, z = 0, $ = 0) {
      (R = w), (A = z), (S = $);
      let j = !0,
        G = null,
        ue = !1,
        xe = !1;
      if (w) {
        const Te = Fe.get(w);
        if (Te.__useDefaultFramebuffer !== void 0)
          Be.bindFramebuffer(L.FRAMEBUFFER, null), (j = !1);
        else if (Te.__webglFramebuffer === void 0) D.setupRenderTarget(w);
        else if (Te.__hasExternalTextures)
          D.rebindTextures(
            w,
            Fe.get(w.texture).__webglTexture,
            Fe.get(w.depthTexture).__webglTexture,
          );
        else if (w.depthBuffer) {
          const Ie = w.depthTexture;
          if (Te.__boundDepthTexture !== Ie) {
            if (
              Ie !== null &&
              Fe.has(Ie) &&
              (w.width !== Ie.image.width || w.height !== Ie.image.height)
            )
              throw new Error(
                "WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.",
              );
            D.setupDepthRenderbuffer(w);
          }
        }
        const _e = w.texture;
        (_e.isData3DTexture ||
          _e.isDataArrayTexture ||
          _e.isCompressedArrayTexture) &&
          (xe = !0);
        const we = Fe.get(w).__webglFramebuffer;
        w.isWebGLCubeRenderTarget
          ? (Array.isArray(we[z]) ? (G = we[z][$]) : (G = we[z]), (ue = !0))
          : w.samples > 0 && D.useMultisampledRTT(w) === !1
            ? (G = Fe.get(w).__webglMultisampledFramebuffer)
            : Array.isArray(we)
              ? (G = we[$])
              : (G = we),
          T.copy(w.viewport),
          F.copy(w.scissor),
          (P = w.scissorTest);
      } else
        T.copy(H).multiplyScalar(k).floor(),
          F.copy(K).multiplyScalar(k).floor(),
          (P = Q);
      if (
        ($ !== 0 && (G = _t),
        Be.bindFramebuffer(L.FRAMEBUFFER, G) && j && Be.drawBuffers(w, G),
        Be.viewport(T),
        Be.scissor(F),
        Be.setScissorTest(P),
        ue)
      ) {
        const Te = Fe.get(w.texture);
        L.framebufferTexture2D(
          L.FRAMEBUFFER,
          L.COLOR_ATTACHMENT0,
          L.TEXTURE_CUBE_MAP_POSITIVE_X + z,
          Te.__webglTexture,
          $,
        );
      } else if (xe) {
        const Te = Fe.get(w.texture),
          _e = z;
        L.framebufferTextureLayer(
          L.FRAMEBUFFER,
          L.COLOR_ATTACHMENT0,
          Te.__webglTexture,
          $,
          _e,
        );
      } else if (w !== null && $ !== 0) {
        const Te = Fe.get(w.texture);
        L.framebufferTexture2D(
          L.FRAMEBUFFER,
          L.COLOR_ATTACHMENT0,
          L.TEXTURE_2D,
          Te.__webglTexture,
          $,
        );
      }
      M = -1;
    }),
      (this.readRenderTargetPixels = function (w, z, $, j, G, ue, xe) {
        if (!(w && w.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.",
          );
          return;
        }
        let Ae = Fe.get(w).__webglFramebuffer;
        if ((w.isWebGLCubeRenderTarget && xe !== void 0 && (Ae = Ae[xe]), Ae)) {
          Be.bindFramebuffer(L.FRAMEBUFFER, Ae);
          try {
            const Te = w.texture,
              _e = Te.format,
              we = Te.type;
            if (!Ke.textureFormatReadable(_e)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.",
              );
              return;
            }
            if (!Ke.textureTypeReadable(we)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.",
              );
              return;
            }
            z >= 0 &&
              z <= w.width - j &&
              $ >= 0 &&
              $ <= w.height - G &&
              L.readPixels(z, $, j, G, Ye.convert(_e), Ye.convert(we), ue);
          } finally {
            const Te = R !== null ? Fe.get(R).__webglFramebuffer : null;
            Be.bindFramebuffer(L.FRAMEBUFFER, Te);
          }
        }
      }),
      (this.readRenderTargetPixelsAsync = async function (
        w,
        z,
        $,
        j,
        G,
        ue,
        xe,
      ) {
        if (!(w && w.isWebGLRenderTarget))
          throw new Error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.",
          );
        let Ae = Fe.get(w).__webglFramebuffer;
        if ((w.isWebGLCubeRenderTarget && xe !== void 0 && (Ae = Ae[xe]), Ae)) {
          const Te = w.texture,
            _e = Te.format,
            we = Te.type;
          if (!Ke.textureFormatReadable(_e))
            throw new Error(
              "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.",
            );
          if (!Ke.textureTypeReadable(we))
            throw new Error(
              "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.",
            );
          if (z >= 0 && z <= w.width - j && $ >= 0 && $ <= w.height - G) {
            Be.bindFramebuffer(L.FRAMEBUFFER, Ae);
            const Ie = L.createBuffer();
            L.bindBuffer(L.PIXEL_PACK_BUFFER, Ie),
              L.bufferData(L.PIXEL_PACK_BUFFER, ue.byteLength, L.STREAM_READ),
              L.readPixels(z, $, j, G, Ye.convert(_e), Ye.convert(we), 0);
            const nt = R !== null ? Fe.get(R).__webglFramebuffer : null;
            Be.bindFramebuffer(L.FRAMEBUFFER, nt);
            const Ve = L.fenceSync(L.SYNC_GPU_COMMANDS_COMPLETE, 0);
            return (
              L.flush(),
              await Em(L, Ve, 4),
              L.bindBuffer(L.PIXEL_PACK_BUFFER, Ie),
              L.getBufferSubData(L.PIXEL_PACK_BUFFER, 0, ue),
              L.deleteBuffer(Ie),
              L.deleteSync(Ve),
              ue
            );
          } else
            throw new Error(
              "THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.",
            );
        }
      }),
      (this.copyFramebufferToTexture = function (w, z = null, $ = 0) {
        w.isTexture !== !0 &&
          (tr(
            "WebGLRenderer: copyFramebufferToTexture function signature has changed.",
          ),
          (z = arguments[0] || null),
          (w = arguments[1]));
        const j = Math.pow(2, -$),
          G = Math.floor(w.image.width * j),
          ue = Math.floor(w.image.height * j),
          xe = z !== null ? z.x : 0,
          Ae = z !== null ? z.y : 0;
        D.setTexture2D(w, 0),
          L.copyTexSubImage2D(L.TEXTURE_2D, $, 0, 0, xe, Ae, G, ue),
          Be.unbindTexture();
      });
    const ft = L.createFramebuffer(),
      Ct = L.createFramebuffer();
    (this.copyTextureToTexture = function (
      w,
      z,
      $ = null,
      j = null,
      G = 0,
      ue = null,
    ) {
      w.isTexture !== !0 &&
        (tr(
          "WebGLRenderer: copyTextureToTexture function signature has changed.",
        ),
        (j = arguments[0] || null),
        (w = arguments[1]),
        (z = arguments[2]),
        (ue = arguments[3] || 0),
        ($ = null)),
        ue === null &&
          (G !== 0
            ? (tr(
                "WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels.",
              ),
              (ue = G),
              (G = 0))
            : (ue = 0));
      let xe, Ae, Te, _e, we, Ie, nt, Ve, Mt;
      const bt = w.isCompressedTexture ? w.mipmaps[ue] : w.image;
      if ($ !== null)
        (xe = $.max.x - $.min.x),
          (Ae = $.max.y - $.min.y),
          (Te = $.isBox3 ? $.max.z - $.min.z : 1),
          (_e = $.min.x),
          (we = $.min.y),
          (Ie = $.isBox3 ? $.min.z : 0);
      else {
        const un = Math.pow(2, -G);
        (xe = Math.floor(bt.width * un)),
          (Ae = Math.floor(bt.height * un)),
          w.isDataArrayTexture
            ? (Te = bt.depth)
            : w.isData3DTexture
              ? (Te = Math.floor(bt.depth * un))
              : (Te = 1),
          (_e = 0),
          (we = 0),
          (Ie = 0);
      }
      j !== null
        ? ((nt = j.x), (Ve = j.y), (Mt = j.z))
        : ((nt = 0), (Ve = 0), (Mt = 0));
      const lt = Ye.convert(z.format),
        Ge = Ye.convert(z.type);
      let Ht;
      z.isData3DTexture
        ? (D.setTexture3D(z, 0), (Ht = L.TEXTURE_3D))
        : z.isDataArrayTexture || z.isCompressedArrayTexture
          ? (D.setTexture2DArray(z, 0), (Ht = L.TEXTURE_2D_ARRAY))
          : (D.setTexture2D(z, 0), (Ht = L.TEXTURE_2D)),
        L.pixelStorei(L.UNPACK_FLIP_Y_WEBGL, z.flipY),
        L.pixelStorei(L.UNPACK_PREMULTIPLY_ALPHA_WEBGL, z.premultiplyAlpha),
        L.pixelStorei(L.UNPACK_ALIGNMENT, z.unpackAlignment);
      const mt = L.getParameter(L.UNPACK_ROW_LENGTH),
        xn = L.getParameter(L.UNPACK_IMAGE_HEIGHT),
        Bi = L.getParameter(L.UNPACK_SKIP_PIXELS),
        rn = L.getParameter(L.UNPACK_SKIP_ROWS),
        yr = L.getParameter(L.UNPACK_SKIP_IMAGES);
      L.pixelStorei(L.UNPACK_ROW_LENGTH, bt.width),
        L.pixelStorei(L.UNPACK_IMAGE_HEIGHT, bt.height),
        L.pixelStorei(L.UNPACK_SKIP_PIXELS, _e),
        L.pixelStorei(L.UNPACK_SKIP_ROWS, we),
        L.pixelStorei(L.UNPACK_SKIP_IMAGES, Ie);
      const wt = w.isDataArrayTexture || w.isData3DTexture,
        ln = z.isDataArrayTexture || z.isData3DTexture;
      if (w.isDepthTexture) {
        const un = Fe.get(w),
          $t = Fe.get(z),
          Zt = Fe.get(un.__renderTarget),
          Va = Fe.get($t.__renderTarget);
        Be.bindFramebuffer(L.READ_FRAMEBUFFER, Zt.__webglFramebuffer),
          Be.bindFramebuffer(L.DRAW_FRAMEBUFFER, Va.__webglFramebuffer);
        for (let ci = 0; ci < Te; ci++)
          wt &&
            (L.framebufferTextureLayer(
              L.READ_FRAMEBUFFER,
              L.COLOR_ATTACHMENT0,
              Fe.get(w).__webglTexture,
              G,
              Ie + ci,
            ),
            L.framebufferTextureLayer(
              L.DRAW_FRAMEBUFFER,
              L.COLOR_ATTACHMENT0,
              Fe.get(z).__webglTexture,
              ue,
              Mt + ci,
            )),
            L.blitFramebuffer(
              _e,
              we,
              xe,
              Ae,
              nt,
              Ve,
              xe,
              Ae,
              L.DEPTH_BUFFER_BIT,
              L.NEAREST,
            );
        Be.bindFramebuffer(L.READ_FRAMEBUFFER, null),
          Be.bindFramebuffer(L.DRAW_FRAMEBUFFER, null);
      } else if (G !== 0 || w.isRenderTargetTexture || Fe.has(w)) {
        const un = Fe.get(w),
          $t = Fe.get(z);
        Be.bindFramebuffer(L.READ_FRAMEBUFFER, ft),
          Be.bindFramebuffer(L.DRAW_FRAMEBUFFER, Ct);
        for (let Zt = 0; Zt < Te; Zt++)
          wt
            ? L.framebufferTextureLayer(
                L.READ_FRAMEBUFFER,
                L.COLOR_ATTACHMENT0,
                un.__webglTexture,
                G,
                Ie + Zt,
              )
            : L.framebufferTexture2D(
                L.READ_FRAMEBUFFER,
                L.COLOR_ATTACHMENT0,
                L.TEXTURE_2D,
                un.__webglTexture,
                G,
              ),
            ln
              ? L.framebufferTextureLayer(
                  L.DRAW_FRAMEBUFFER,
                  L.COLOR_ATTACHMENT0,
                  $t.__webglTexture,
                  ue,
                  Mt + Zt,
                )
              : L.framebufferTexture2D(
                  L.DRAW_FRAMEBUFFER,
                  L.COLOR_ATTACHMENT0,
                  L.TEXTURE_2D,
                  $t.__webglTexture,
                  ue,
                ),
            G !== 0
              ? L.blitFramebuffer(
                  _e,
                  we,
                  xe,
                  Ae,
                  nt,
                  Ve,
                  xe,
                  Ae,
                  L.COLOR_BUFFER_BIT,
                  L.NEAREST,
                )
              : ln
                ? L.copyTexSubImage3D(Ht, ue, nt, Ve, Mt + Zt, _e, we, xe, Ae)
                : L.copyTexSubImage2D(Ht, ue, nt, Ve, _e, we, xe, Ae);
        Be.bindFramebuffer(L.READ_FRAMEBUFFER, null),
          Be.bindFramebuffer(L.DRAW_FRAMEBUFFER, null);
      } else
        ln
          ? w.isDataTexture || w.isData3DTexture
            ? L.texSubImage3D(Ht, ue, nt, Ve, Mt, xe, Ae, Te, lt, Ge, bt.data)
            : z.isCompressedArrayTexture
              ? L.compressedTexSubImage3D(
                  Ht,
                  ue,
                  nt,
                  Ve,
                  Mt,
                  xe,
                  Ae,
                  Te,
                  lt,
                  bt.data,
                )
              : L.texSubImage3D(Ht, ue, nt, Ve, Mt, xe, Ae, Te, lt, Ge, bt)
          : w.isDataTexture
            ? L.texSubImage2D(L.TEXTURE_2D, ue, nt, Ve, xe, Ae, lt, Ge, bt.data)
            : w.isCompressedTexture
              ? L.compressedTexSubImage2D(
                  L.TEXTURE_2D,
                  ue,
                  nt,
                  Ve,
                  bt.width,
                  bt.height,
                  lt,
                  bt.data,
                )
              : L.texSubImage2D(L.TEXTURE_2D, ue, nt, Ve, xe, Ae, lt, Ge, bt);
      L.pixelStorei(L.UNPACK_ROW_LENGTH, mt),
        L.pixelStorei(L.UNPACK_IMAGE_HEIGHT, xn),
        L.pixelStorei(L.UNPACK_SKIP_PIXELS, Bi),
        L.pixelStorei(L.UNPACK_SKIP_ROWS, rn),
        L.pixelStorei(L.UNPACK_SKIP_IMAGES, yr),
        ue === 0 && z.generateMipmaps && L.generateMipmap(Ht),
        Be.unbindTexture();
    }),
      (this.copyTextureToTexture3D = function (
        w,
        z,
        $ = null,
        j = null,
        G = 0,
      ) {
        return (
          w.isTexture !== !0 &&
            (tr(
              "WebGLRenderer: copyTextureToTexture3D function signature has changed.",
            ),
            ($ = arguments[0] || null),
            (j = arguments[1] || null),
            (w = arguments[2]),
            (z = arguments[3]),
            (G = arguments[4] || 0)),
          tr(
            'WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.',
          ),
          this.copyTextureToTexture(w, z, $, j, G)
        );
      }),
      (this.initRenderTarget = function (w) {
        Fe.get(w).__webglFramebuffer === void 0 && D.setupRenderTarget(w);
      }),
      (this.initTexture = function (w) {
        w.isCubeTexture
          ? D.setTextureCube(w, 0)
          : w.isData3DTexture
            ? D.setTexture3D(w, 0)
            : w.isDataArrayTexture || w.isCompressedArrayTexture
              ? D.setTexture2DArray(w, 0)
              : D.setTexture2D(w, 0),
          Be.unbindTexture();
      }),
      (this.resetState = function () {
        (A = 0), (S = 0), (R = null), Be.reset(), dt.reset();
      }),
      typeof __THREE_DEVTOOLS__ != "undefined" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this }),
        );
  }
  get coordinateSystem() {
    return Hn;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    (t.drawingBufferColorspace = pt._getDrawingBufferColorSpace(e)),
      (t.unpackColorSpace = pt._getUnpackColorSpace());
  }
}
const Fn = Object.create(null);
Fn.open = "0";
Fn.close = "1";
Fn.ping = "2";
Fn.pong = "3";
Fn.message = "4";
Fn.upgrade = "5";
Fn.noop = "6";
const xa = Object.create(null);
Object.keys(Fn).forEach((i) => {
  xa[Fn[i]] = i;
});
const Rc = { type: "error", data: "parser error" },
  Ph =
    typeof Blob == "function" ||
    (typeof Blob != "undefined" &&
      Object.prototype.toString.call(Blob) === "[object BlobConstructor]"),
  Fh = typeof ArrayBuffer == "function",
  Bh = (i) =>
    typeof ArrayBuffer.isView == "function"
      ? ArrayBuffer.isView(i)
      : i && i.buffer instanceof ArrayBuffer,
  nl = ({ type: i, data: e }, t, n) =>
    Ph && e instanceof Blob
      ? t
        ? n(e)
        : gf(e, n)
      : Fh && (e instanceof ArrayBuffer || Bh(e))
        ? t
          ? n(e)
          : gf(new Blob([e]), n)
        : n(Fn[i] + (e || "")),
  gf = (i, e) => {
    const t = new FileReader();
    return (
      (t.onload = function () {
        const n = t.result.split(",")[1];
        e("b" + (n || ""));
      }),
      t.readAsDataURL(i)
    );
  };
function _f(i) {
  return i instanceof Uint8Array
    ? i
    : i instanceof ArrayBuffer
      ? new Uint8Array(i)
      : new Uint8Array(i.buffer, i.byteOffset, i.byteLength);
}
let Ro;
function V1(i, e) {
  if (Ph && i.data instanceof Blob)
    return i.data.arrayBuffer().then(_f).then(e);
  if (Fh && (i.data instanceof ArrayBuffer || Bh(i.data))) return e(_f(i.data));
  nl(i, !1, (t) => {
    Ro || (Ro = new TextEncoder()), e(Ro.encode(t));
  });
}
const vf = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  Ir = typeof Uint8Array == "undefined" ? [] : new Uint8Array(256);
for (let i = 0; i < vf.length; i++) Ir[vf.charCodeAt(i)] = i;
const G1 = (i) => {
    let e = i.length * 0.75,
      t = i.length,
      n,
      r = 0,
      s,
      a,
      o,
      l;
    i[i.length - 1] === "=" && (e--, i[i.length - 2] === "=" && e--);
    const c = new ArrayBuffer(e),
      u = new Uint8Array(c);
    for (n = 0; n < t; n += 4)
      (s = Ir[i.charCodeAt(n)]),
        (a = Ir[i.charCodeAt(n + 1)]),
        (o = Ir[i.charCodeAt(n + 2)]),
        (l = Ir[i.charCodeAt(n + 3)]),
        (u[r++] = (s << 2) | (a >> 4)),
        (u[r++] = ((a & 15) << 4) | (o >> 2)),
        (u[r++] = ((o & 3) << 6) | (l & 63));
    return c;
  },
  W1 = typeof ArrayBuffer == "function",
  il = (i, e) => {
    if (typeof i != "string") return { type: "message", data: Lh(i, e) };
    const t = i.charAt(0);
    return t === "b"
      ? { type: "message", data: X1(i.substring(1), e) }
      : xa[t]
        ? i.length > 1
          ? { type: xa[t], data: i.substring(1) }
          : { type: xa[t] }
        : Rc;
  },
  X1 = (i, e) => {
    if (W1) {
      const t = G1(i);
      return Lh(t, e);
    } else return { base64: !0, data: i };
  },
  Lh = (i, e) => {
    switch (e) {
      case "blob":
        return i instanceof Blob ? i : new Blob([i]);
      case "arraybuffer":
      default:
        return i instanceof ArrayBuffer ? i : i.buffer;
    }
  },
  Uh = "",
  q1 = (i, e) => {
    const t = i.length,
      n = new Array(t);
    let r = 0;
    i.forEach((s, a) => {
      nl(s, !1, (o) => {
        (n[a] = o), ++r === t && e(n.join(Uh));
      });
    });
  },
  Y1 = (i, e) => {
    const t = i.split(Uh),
      n = [];
    for (let r = 0; r < t.length; r++) {
      const s = il(t[r], e);
      if ((n.push(s), s.type === "error")) break;
    }
    return n;
  };
function $1() {
  return new TransformStream({
    transform(i, e) {
      V1(i, (t) => {
        const n = t.length;
        let r;
        if (n < 126)
          (r = new Uint8Array(1)), new DataView(r.buffer).setUint8(0, n);
        else if (n < 65536) {
          r = new Uint8Array(3);
          const s = new DataView(r.buffer);
          s.setUint8(0, 126), s.setUint16(1, n);
        } else {
          r = new Uint8Array(9);
          const s = new DataView(r.buffer);
          s.setUint8(0, 127), s.setBigUint64(1, BigInt(n));
        }
        i.data && typeof i.data != "string" && (r[0] |= 128),
          e.enqueue(r),
          e.enqueue(t);
      });
    },
  });
}
let Do;
function As(i) {
  return i.reduce((e, t) => e + t.length, 0);
}
function bs(i, e) {
  if (i[0].length === e) return i.shift();
  const t = new Uint8Array(e);
  let n = 0;
  for (let r = 0; r < e; r++)
    (t[r] = i[0][n++]), n === i[0].length && (i.shift(), (n = 0));
  return i.length && n < i[0].length && (i[0] = i[0].slice(n)), t;
}
function j1(i, e) {
  Do || (Do = new TextDecoder());
  const t = [];
  let n = 0,
    r = -1,
    s = !1;
  return new TransformStream({
    transform(a, o) {
      for (t.push(a); ; ) {
        if (n === 0) {
          if (As(t) < 1) break;
          const l = bs(t, 1);
          (s = (l[0] & 128) === 128),
            (r = l[0] & 127),
            r < 126 ? (n = 3) : r === 126 ? (n = 1) : (n = 2);
        } else if (n === 1) {
          if (As(t) < 2) break;
          const l = bs(t, 2);
          (r = new DataView(l.buffer, l.byteOffset, l.length).getUint16(0)),
            (n = 3);
        } else if (n === 2) {
          if (As(t) < 8) break;
          const l = bs(t, 8),
            c = new DataView(l.buffer, l.byteOffset, l.length),
            u = c.getUint32(0);
          if (u > Math.pow(2, 21) - 1) {
            o.enqueue(Rc);
            break;
          }
          (r = u * Math.pow(2, 32) + c.getUint32(4)), (n = 3);
        } else {
          if (As(t) < r) break;
          const l = bs(t, r);
          o.enqueue(il(s ? l : Do.decode(l), e)), (n = 0);
        }
        if (r === 0 || r > i) {
          o.enqueue(Rc);
          break;
        }
      }
    },
  });
}
const Ih = 4;
function Ft(i) {
  if (i) return K1(i);
}
function K1(i) {
  for (var e in Ft.prototype) i[e] = Ft.prototype[e];
  return i;
}
Ft.prototype.on = Ft.prototype.addEventListener = function (i, e) {
  return (
    (this._callbacks = this._callbacks || {}),
    (this._callbacks["$" + i] = this._callbacks["$" + i] || []).push(e),
    this
  );
};
Ft.prototype.once = function (i, e) {
  function t() {
    this.off(i, t), e.apply(this, arguments);
  }
  return (t.fn = e), this.on(i, t), this;
};
Ft.prototype.off =
  Ft.prototype.removeListener =
  Ft.prototype.removeAllListeners =
  Ft.prototype.removeEventListener =
    function (i, e) {
      if (((this._callbacks = this._callbacks || {}), arguments.length == 0))
        return (this._callbacks = {}), this;
      var t = this._callbacks["$" + i];
      if (!t) return this;
      if (arguments.length == 1) return delete this._callbacks["$" + i], this;
      for (var n, r = 0; r < t.length; r++)
        if (((n = t[r]), n === e || n.fn === e)) {
          t.splice(r, 1);
          break;
        }
      return t.length === 0 && delete this._callbacks["$" + i], this;
    };
Ft.prototype.emit = function (i) {
  this._callbacks = this._callbacks || {};
  for (
    var e = new Array(arguments.length - 1),
      t = this._callbacks["$" + i],
      n = 1;
    n < arguments.length;
    n++
  )
    e[n - 1] = arguments[n];
  if (t) {
    t = t.slice(0);
    for (var n = 0, r = t.length; n < r; ++n) t[n].apply(this, e);
  }
  return this;
};
Ft.prototype.emitReserved = Ft.prototype.emit;
Ft.prototype.listeners = function (i) {
  return (
    (this._callbacks = this._callbacks || {}), this._callbacks["$" + i] || []
  );
};
Ft.prototype.hasListeners = function (i) {
  return !!this.listeners(i).length;
};
const Ua =
    typeof Promise == "function" && typeof Promise.resolve == "function"
      ? (e) => Promise.resolve().then(e)
      : (e, t) => t(e, 0),
  pn =
    typeof self != "undefined"
      ? self
      : typeof window != "undefined"
        ? window
        : Function("return this")(),
  Z1 = "arraybuffer";
function Nh(i, ...e) {
  return e.reduce((t, n) => (i.hasOwnProperty(n) && (t[n] = i[n]), t), {});
}
const J1 = pn.setTimeout,
  Q1 = pn.clearTimeout;
function Ia(i, e) {
  e.useNativeTimers
    ? ((i.setTimeoutFn = J1.bind(pn)), (i.clearTimeoutFn = Q1.bind(pn)))
    : ((i.setTimeoutFn = pn.setTimeout.bind(pn)),
      (i.clearTimeoutFn = pn.clearTimeout.bind(pn)));
}
const eE = 1.33;
function tE(i) {
  return typeof i == "string"
    ? nE(i)
    : Math.ceil((i.byteLength || i.size) * eE);
}
function nE(i) {
  let e = 0,
    t = 0;
  for (let n = 0, r = i.length; n < r; n++)
    (e = i.charCodeAt(n)),
      e < 128
        ? (t += 1)
        : e < 2048
          ? (t += 2)
          : e < 55296 || e >= 57344
            ? (t += 3)
            : (n++, (t += 4));
  return t;
}
function Oh() {
  return (
    Date.now().toString(36).substring(3) +
    Math.random().toString(36).substring(2, 5)
  );
}
function iE(i) {
  let e = "";
  for (let t in i)
    i.hasOwnProperty(t) &&
      (e.length && (e += "&"),
      (e += encodeURIComponent(t) + "=" + encodeURIComponent(i[t])));
  return e;
}
function rE(i) {
  let e = {},
    t = i.split("&");
  for (let n = 0, r = t.length; n < r; n++) {
    let s = t[n].split("=");
    e[decodeURIComponent(s[0])] = decodeURIComponent(s[1]);
  }
  return e;
}
class sE extends Error {
  constructor(e, t, n) {
    super(e),
      (this.description = t),
      (this.context = n),
      (this.type = "TransportError");
  }
}
class rl extends Ft {
  constructor(e) {
    super(),
      (this.writable = !1),
      Ia(this, e),
      (this.opts = e),
      (this.query = e.query),
      (this.socket = e.socket),
      (this.supportsBinary = !e.forceBase64);
  }
  onError(e, t, n) {
    return super.emitReserved("error", new sE(e, t, n)), this;
  }
  open() {
    return (this.readyState = "opening"), this.doOpen(), this;
  }
  close() {
    return (
      (this.readyState === "opening" || this.readyState === "open") &&
        (this.doClose(), this.onClose()),
      this
    );
  }
  send(e) {
    this.readyState === "open" && this.write(e);
  }
  onOpen() {
    (this.readyState = "open"),
      (this.writable = !0),
      super.emitReserved("open");
  }
  onData(e) {
    const t = il(e, this.socket.binaryType);
    this.onPacket(t);
  }
  onPacket(e) {
    super.emitReserved("packet", e);
  }
  onClose(e) {
    (this.readyState = "closed"), super.emitReserved("close", e);
  }
  pause(e) {}
  createUri(e, t = {}) {
    return (
      e +
      "://" +
      this._hostname() +
      this._port() +
      this.opts.path +
      this._query(t)
    );
  }
  _hostname() {
    const e = this.opts.hostname;
    return e.indexOf(":") === -1 ? e : "[" + e + "]";
  }
  _port() {
    return this.opts.port &&
      ((this.opts.secure && +(this.opts.port !== 443)) ||
        (!this.opts.secure && Number(this.opts.port) !== 80))
      ? ":" + this.opts.port
      : "";
  }
  _query(e) {
    const t = iE(e);
    return t.length ? "?" + t : "";
  }
}
class aE extends rl {
  constructor() {
    super(...arguments), (this._polling = !1);
  }
  get name() {
    return "polling";
  }
  doOpen() {
    this._poll();
  }
  pause(e) {
    this.readyState = "pausing";
    const t = () => {
      (this.readyState = "paused"), e();
    };
    if (this._polling || !this.writable) {
      let n = 0;
      this._polling &&
        (n++,
        this.once("pollComplete", function () {
          --n || t();
        })),
        this.writable ||
          (n++,
          this.once("drain", function () {
            --n || t();
          }));
    } else t();
  }
  _poll() {
    (this._polling = !0), this.doPoll(), this.emitReserved("poll");
  }
  onData(e) {
    const t = (n) => {
      if (
        (this.readyState === "opening" && n.type === "open" && this.onOpen(),
        n.type === "close")
      )
        return (
          this.onClose({ description: "transport closed by the server" }), !1
        );
      this.onPacket(n);
    };
    Y1(e, this.socket.binaryType).forEach(t),
      this.readyState !== "closed" &&
        ((this._polling = !1),
        this.emitReserved("pollComplete"),
        this.readyState === "open" && this._poll());
  }
  doClose() {
    const e = () => {
      this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? e() : this.once("open", e);
  }
  write(e) {
    (this.writable = !1),
      q1(e, (t) => {
        this.doWrite(t, () => {
          (this.writable = !0), this.emitReserved("drain");
        });
      });
  }
  uri() {
    const e = this.opts.secure ? "https" : "http",
      t = this.query || {};
    return (
      this.opts.timestampRequests !== !1 &&
        (t[this.opts.timestampParam] = Oh()),
      !this.supportsBinary && !t.sid && (t.b64 = 1),
      this.createUri(e, t)
    );
  }
}
let zh = !1;
try {
  zh =
    typeof XMLHttpRequest != "undefined" &&
    "withCredentials" in new XMLHttpRequest();
} catch (i) {}
const oE = zh;
function cE() {}
class lE extends aE {
  constructor(e) {
    if ((super(e), typeof location != "undefined")) {
      const t = location.protocol === "https:";
      let n = location.port;
      n || (n = t ? "443" : "80"),
        (this.xd =
          (typeof location != "undefined" &&
            e.hostname !== location.hostname) ||
          n !== e.port);
    }
  }
  doWrite(e, t) {
    const n = this.request({ method: "POST", data: e });
    n.on("success", t),
      n.on("error", (r, s) => {
        this.onError("xhr post error", r, s);
      });
  }
  doPoll() {
    const e = this.request();
    e.on("data", this.onData.bind(this)),
      e.on("error", (t, n) => {
        this.onError("xhr poll error", t, n);
      }),
      (this.pollXhr = e);
  }
}
let ar = class ga extends Ft {
  constructor(e, t, n) {
    super(),
      (this.createRequest = e),
      Ia(this, n),
      (this._opts = n),
      (this._method = n.method || "GET"),
      (this._uri = t),
      (this._data = n.data !== void 0 ? n.data : null),
      this._create();
  }
  _create() {
    var e;
    const t = Nh(
      this._opts,
      "agent",
      "pfx",
      "key",
      "passphrase",
      "cert",
      "ca",
      "ciphers",
      "rejectUnauthorized",
      "autoUnref",
    );
    t.xdomain = !!this._opts.xd;
    const n = (this._xhr = this.createRequest(t));
    try {
      n.open(this._method, this._uri, !0);
      try {
        if (this._opts.extraHeaders) {
          n.setDisableHeaderCheck && n.setDisableHeaderCheck(!0);
          for (let r in this._opts.extraHeaders)
            this._opts.extraHeaders.hasOwnProperty(r) &&
              n.setRequestHeader(r, this._opts.extraHeaders[r]);
        }
      } catch (r) {}
      if (this._method === "POST")
        try {
          n.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (r) {}
      try {
        n.setRequestHeader("Accept", "*/*");
      } catch (r) {}
      (e = this._opts.cookieJar) === null || e === void 0 || e.addCookies(n),
        "withCredentials" in n &&
          (n.withCredentials = this._opts.withCredentials),
        this._opts.requestTimeout && (n.timeout = this._opts.requestTimeout),
        (n.onreadystatechange = () => {
          var r;
          n.readyState === 3 &&
            ((r = this._opts.cookieJar) === null ||
              r === void 0 ||
              r.parseCookies(n.getResponseHeader("set-cookie"))),
            n.readyState === 4 &&
              (n.status === 200 || n.status === 1223
                ? this._onLoad()
                : this.setTimeoutFn(() => {
                    this._onError(typeof n.status == "number" ? n.status : 0);
                  }, 0));
        }),
        n.send(this._data);
    } catch (r) {
      this.setTimeoutFn(() => {
        this._onError(r);
      }, 0);
      return;
    }
    typeof document != "undefined" &&
      ((this._index = ga.requestsCount++), (ga.requests[this._index] = this));
  }
  _onError(e) {
    this.emitReserved("error", e, this._xhr), this._cleanup(!0);
  }
  _cleanup(e) {
    if (!(typeof this._xhr == "undefined" || this._xhr === null)) {
      if (((this._xhr.onreadystatechange = cE), e))
        try {
          this._xhr.abort();
        } catch (t) {}
      typeof document != "undefined" && delete ga.requests[this._index],
        (this._xhr = null);
    }
  }
  _onLoad() {
    const e = this._xhr.responseText;
    e !== null &&
      (this.emitReserved("data", e),
      this.emitReserved("success"),
      this._cleanup());
  }
  abort() {
    this._cleanup();
  }
};
ar.requestsCount = 0;
ar.requests = {};
if (typeof document != "undefined") {
  if (typeof attachEvent == "function") attachEvent("onunload", Ef);
  else if (typeof addEventListener == "function") {
    const i = "onpagehide" in pn ? "pagehide" : "unload";
    addEventListener(i, Ef, !1);
  }
}
function Ef() {
  for (let i in ar.requests)
    ar.requests.hasOwnProperty(i) && ar.requests[i].abort();
}
const uE = (function () {
  const i = kh({ xdomain: !1 });
  return i && i.responseType !== null;
})();
class fE extends lE {
  constructor(e) {
    super(e);
    const t = e && e.forceBase64;
    this.supportsBinary = uE && !t;
  }
  request(e = {}) {
    return (
      Object.assign(e, { xd: this.xd }, this.opts), new ar(kh, this.uri(), e)
    );
  }
}
function kh(i) {
  const e = i.xdomain;
  try {
    if (typeof XMLHttpRequest != "undefined" && (!e || oE))
      return new XMLHttpRequest();
  } catch (t) {}
  if (!e)
    try {
      return new pn[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (t) {}
}
const Hh =
  typeof navigator != "undefined" &&
  typeof navigator.product == "string" &&
  navigator.product.toLowerCase() === "reactnative";
class hE extends rl {
  get name() {
    return "websocket";
  }
  doOpen() {
    const e = this.uri(),
      t = this.opts.protocols,
      n = Hh
        ? {}
        : Nh(
            this.opts,
            "agent",
            "perMessageDeflate",
            "pfx",
            "key",
            "passphrase",
            "cert",
            "ca",
            "ciphers",
            "rejectUnauthorized",
            "localAddress",
            "protocolVersion",
            "origin",
            "maxPayload",
            "family",
            "checkServerIdentity",
          );
    this.opts.extraHeaders && (n.headers = this.opts.extraHeaders);
    try {
      this.ws = this.createSocket(e, t, n);
    } catch (r) {
      return this.emitReserved("error", r);
    }
    (this.ws.binaryType = this.socket.binaryType), this.addEventListeners();
  }
  addEventListeners() {
    (this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }),
      (this.ws.onclose = (e) =>
        this.onClose({
          description: "websocket connection closed",
          context: e,
        })),
      (this.ws.onmessage = (e) => this.onData(e.data)),
      (this.ws.onerror = (e) => this.onError("websocket error", e));
  }
  write(e) {
    this.writable = !1;
    for (let t = 0; t < e.length; t++) {
      const n = e[t],
        r = t === e.length - 1;
      nl(n, this.supportsBinary, (s) => {
        try {
          this.doWrite(n, s);
        } catch (a) {}
        r &&
          Ua(() => {
            (this.writable = !0), this.emitReserved("drain");
          }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws != "undefined" &&
      ((this.ws.onerror = () => {}), this.ws.close(), (this.ws = null));
  }
  uri() {
    const e = this.opts.secure ? "wss" : "ws",
      t = this.query || {};
    return (
      this.opts.timestampRequests && (t[this.opts.timestampParam] = Oh()),
      this.supportsBinary || (t.b64 = 1),
      this.createUri(e, t)
    );
  }
}
const Po = pn.WebSocket || pn.MozWebSocket;
class dE extends hE {
  createSocket(e, t, n) {
    return Hh ? new Po(e, t, n) : t ? new Po(e, t) : new Po(e);
  }
  doWrite(e, t) {
    this.ws.send(t);
  }
}
class pE extends rl {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(
        this.createUri("https"),
        this.opts.transportOptions[this.name],
      );
    } catch (e) {
      return this.emitReserved("error", e);
    }
    this._transport.closed
      .then(() => {
        this.onClose();
      })
      .catch((e) => {
        this.onError("webtransport error", e);
      }),
      this._transport.ready.then(() => {
        this._transport.createBidirectionalStream().then((e) => {
          const t = j1(Number.MAX_SAFE_INTEGER, this.socket.binaryType),
            n = e.readable.pipeThrough(t).getReader(),
            r = $1();
          r.readable.pipeTo(e.writable),
            (this._writer = r.writable.getWriter());
          const s = () => {
            n.read()
              .then(({ done: o, value: l }) => {
                o || (this.onPacket(l), s());
              })
              .catch((o) => {});
          };
          s();
          const a = { type: "open" };
          this.query.sid && (a.data = `{"sid":"${this.query.sid}"}`),
            this._writer.write(a).then(() => this.onOpen());
        });
      });
  }
  write(e) {
    this.writable = !1;
    for (let t = 0; t < e.length; t++) {
      const n = e[t],
        r = t === e.length - 1;
      this._writer.write(n).then(() => {
        r &&
          Ua(() => {
            (this.writable = !0), this.emitReserved("drain");
          }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    var e;
    (e = this._transport) === null || e === void 0 || e.close();
  }
}
const mE = { websocket: dE, webtransport: pE, polling: fE },
  xE =
    /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
  gE = [
    "source",
    "protocol",
    "authority",
    "userInfo",
    "user",
    "password",
    "host",
    "port",
    "relative",
    "path",
    "directory",
    "file",
    "query",
    "anchor",
  ];
function Dc(i) {
  if (i.length > 8e3) throw "URI too long";
  const e = i,
    t = i.indexOf("["),
    n = i.indexOf("]");
  t != -1 &&
    n != -1 &&
    (i =
      i.substring(0, t) +
      i.substring(t, n).replace(/:/g, ";") +
      i.substring(n, i.length));
  let r = xE.exec(i || ""),
    s = {},
    a = 14;
  for (; a--; ) s[gE[a]] = r[a] || "";
  return (
    t != -1 &&
      n != -1 &&
      ((s.source = e),
      (s.host = s.host.substring(1, s.host.length - 1).replace(/;/g, ":")),
      (s.authority = s.authority
        .replace("[", "")
        .replace("]", "")
        .replace(/;/g, ":")),
      (s.ipv6uri = !0)),
    (s.pathNames = _E(s, s.path)),
    (s.queryKey = vE(s, s.query)),
    s
  );
}
function _E(i, e) {
  const t = /\/{2,9}/g,
    n = e.replace(t, "/").split("/");
  return (
    (e.slice(0, 1) == "/" || e.length === 0) && n.splice(0, 1),
    e.slice(-1) == "/" && n.splice(n.length - 1, 1),
    n
  );
}
function vE(i, e) {
  const t = {};
  return (
    e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function (n, r, s) {
      r && (t[r] = s);
    }),
    t
  );
}
const Pc =
    typeof addEventListener == "function" &&
    typeof removeEventListener == "function",
  _a = [];
Pc &&
  addEventListener(
    "offline",
    () => {
      _a.forEach((i) => i());
    },
    !1,
  );
class ri extends Ft {
  constructor(e, t) {
    if (
      (super(),
      (this.binaryType = Z1),
      (this.writeBuffer = []),
      (this._prevBufferLen = 0),
      (this._pingInterval = -1),
      (this._pingTimeout = -1),
      (this._maxPayload = -1),
      (this._pingTimeoutTime = 1 / 0),
      e && typeof e == "object" && ((t = e), (e = null)),
      e)
    ) {
      const n = Dc(e);
      (t.hostname = n.host),
        (t.secure = n.protocol === "https" || n.protocol === "wss"),
        (t.port = n.port),
        n.query && (t.query = n.query);
    } else t.host && (t.hostname = Dc(t.host).host);
    Ia(this, t),
      (this.secure =
        t.secure != null
          ? t.secure
          : typeof location != "undefined" && location.protocol === "https:"),
      t.hostname && !t.port && (t.port = this.secure ? "443" : "80"),
      (this.hostname =
        t.hostname ||
        (typeof location != "undefined" ? location.hostname : "localhost")),
      (this.port =
        t.port ||
        (typeof location != "undefined" && location.port
          ? location.port
          : this.secure
            ? "443"
            : "80")),
      (this.transports = []),
      (this._transportsByName = {}),
      t.transports.forEach((n) => {
        const r = n.prototype.name;
        this.transports.push(r), (this._transportsByName[r] = n);
      }),
      (this.opts = Object.assign(
        {
          path: "/engine.io",
          agent: !1,
          withCredentials: !1,
          upgrade: !0,
          timestampParam: "t",
          rememberUpgrade: !1,
          addTrailingSlash: !0,
          rejectUnauthorized: !0,
          perMessageDeflate: { threshold: 1024 },
          transportOptions: {},
          closeOnBeforeunload: !1,
        },
        t,
      )),
      (this.opts.path =
        this.opts.path.replace(/\/$/, "") +
        (this.opts.addTrailingSlash ? "/" : "")),
      typeof this.opts.query == "string" &&
        (this.opts.query = rE(this.opts.query)),
      Pc &&
        (this.opts.closeOnBeforeunload &&
          ((this._beforeunloadEventListener = () => {
            this.transport &&
              (this.transport.removeAllListeners(), this.transport.close());
          }),
          addEventListener(
            "beforeunload",
            this._beforeunloadEventListener,
            !1,
          )),
        this.hostname !== "localhost" &&
          ((this._offlineEventListener = () => {
            this._onClose("transport close", {
              description: "network connection lost",
            });
          }),
          _a.push(this._offlineEventListener))),
      this.opts.withCredentials && (this._cookieJar = void 0),
      this._open();
  }
  createTransport(e) {
    const t = Object.assign({}, this.opts.query);
    (t.EIO = Ih), (t.transport = e), this.id && (t.sid = this.id);
    const n = Object.assign(
      {},
      this.opts,
      {
        query: t,
        socket: this,
        hostname: this.hostname,
        secure: this.secure,
        port: this.port,
      },
      this.opts.transportOptions[e],
    );
    return new this._transportsByName[e](n);
  }
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const e =
      this.opts.rememberUpgrade &&
      ri.priorWebsocketSuccess &&
      this.transports.indexOf("websocket") !== -1
        ? "websocket"
        : this.transports[0];
    this.readyState = "opening";
    const t = this.createTransport(e);
    t.open(), this.setTransport(t);
  }
  setTransport(e) {
    this.transport && this.transport.removeAllListeners(),
      (this.transport = e),
      e
        .on("drain", this._onDrain.bind(this))
        .on("packet", this._onPacket.bind(this))
        .on("error", this._onError.bind(this))
        .on("close", (t) => this._onClose("transport close", t));
  }
  onOpen() {
    (this.readyState = "open"),
      (ri.priorWebsocketSuccess = this.transport.name === "websocket"),
      this.emitReserved("open"),
      this.flush();
  }
  _onPacket(e) {
    if (
      this.readyState === "opening" ||
      this.readyState === "open" ||
      this.readyState === "closing"
    )
      switch (
        (this.emitReserved("packet", e), this.emitReserved("heartbeat"), e.type)
      ) {
        case "open":
          this.onHandshake(JSON.parse(e.data));
          break;
        case "ping":
          this._sendPacket("pong"),
            this.emitReserved("ping"),
            this.emitReserved("pong"),
            this._resetPingTimeout();
          break;
        case "error":
          const t = new Error("server error");
          (t.code = e.data), this._onError(t);
          break;
        case "message":
          this.emitReserved("data", e.data),
            this.emitReserved("message", e.data);
          break;
      }
  }
  onHandshake(e) {
    this.emitReserved("handshake", e),
      (this.id = e.sid),
      (this.transport.query.sid = e.sid),
      (this._pingInterval = e.pingInterval),
      (this._pingTimeout = e.pingTimeout),
      (this._maxPayload = e.maxPayload),
      this.onOpen(),
      this.readyState !== "closed" && this._resetPingTimeout();
  }
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const e = this._pingInterval + this._pingTimeout;
    (this._pingTimeoutTime = Date.now() + e),
      (this._pingTimeoutTimer = this.setTimeoutFn(() => {
        this._onClose("ping timeout");
      }, e)),
      this.opts.autoUnref && this._pingTimeoutTimer.unref();
  }
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen),
      (this._prevBufferLen = 0),
      this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  flush() {
    if (
      this.readyState !== "closed" &&
      this.transport.writable &&
      !this.upgrading &&
      this.writeBuffer.length
    ) {
      const e = this._getWritablePackets();
      this.transport.send(e),
        (this._prevBufferLen = e.length),
        this.emitReserved("flush");
    }
  }
  _getWritablePackets() {
    if (
      !(
        this._maxPayload &&
        this.transport.name === "polling" &&
        this.writeBuffer.length > 1
      )
    )
      return this.writeBuffer;
    let t = 1;
    for (let n = 0; n < this.writeBuffer.length; n++) {
      const r = this.writeBuffer[n].data;
      if ((r && (t += tE(r)), n > 0 && t > this._maxPayload))
        return this.writeBuffer.slice(0, n);
      t += 2;
    }
    return this.writeBuffer;
  }
  _hasPingExpired() {
    if (!this._pingTimeoutTime) return !0;
    const e = Date.now() > this._pingTimeoutTime;
    return (
      e &&
        ((this._pingTimeoutTime = 0),
        Ua(() => {
          this._onClose("ping timeout");
        }, this.setTimeoutFn)),
      e
    );
  }
  write(e, t, n) {
    return this._sendPacket("message", e, t, n), this;
  }
  send(e, t, n) {
    return this._sendPacket("message", e, t, n), this;
  }
  _sendPacket(e, t, n, r) {
    if (
      (typeof t == "function" && ((r = t), (t = void 0)),
      typeof n == "function" && ((r = n), (n = null)),
      this.readyState === "closing" || this.readyState === "closed")
    )
      return;
    (n = n || {}), (n.compress = n.compress !== !1);
    const s = { type: e, data: t, options: n };
    this.emitReserved("packetCreate", s),
      this.writeBuffer.push(s),
      r && this.once("flush", r),
      this.flush();
  }
  close() {
    const e = () => {
        this._onClose("forced close"), this.transport.close();
      },
      t = () => {
        this.off("upgrade", t), this.off("upgradeError", t), e();
      },
      n = () => {
        this.once("upgrade", t), this.once("upgradeError", t);
      };
    return (
      (this.readyState === "opening" || this.readyState === "open") &&
        ((this.readyState = "closing"),
        this.writeBuffer.length
          ? this.once("drain", () => {
              this.upgrading ? n() : e();
            })
          : this.upgrading
            ? n()
            : e()),
      this
    );
  }
  _onError(e) {
    if (
      ((ri.priorWebsocketSuccess = !1),
      this.opts.tryAllTransports &&
        this.transports.length > 1 &&
        this.readyState === "opening")
    )
      return this.transports.shift(), this._open();
    this.emitReserved("error", e), this._onClose("transport error", e);
  }
  _onClose(e, t) {
    if (
      this.readyState === "opening" ||
      this.readyState === "open" ||
      this.readyState === "closing"
    ) {
      if (
        (this.clearTimeoutFn(this._pingTimeoutTimer),
        this.transport.removeAllListeners("close"),
        this.transport.close(),
        this.transport.removeAllListeners(),
        Pc &&
          (this._beforeunloadEventListener &&
            removeEventListener(
              "beforeunload",
              this._beforeunloadEventListener,
              !1,
            ),
          this._offlineEventListener))
      ) {
        const n = _a.indexOf(this._offlineEventListener);
        n !== -1 && _a.splice(n, 1);
      }
      (this.readyState = "closed"),
        (this.id = null),
        this.emitReserved("close", e, t),
        (this.writeBuffer = []),
        (this._prevBufferLen = 0);
    }
  }
}
ri.protocol = Ih;
class EE extends ri {
  constructor() {
    super(...arguments), (this._upgrades = []);
  }
  onOpen() {
    if ((super.onOpen(), this.readyState === "open" && this.opts.upgrade))
      for (let e = 0; e < this._upgrades.length; e++)
        this._probe(this._upgrades[e]);
  }
  _probe(e) {
    let t = this.createTransport(e),
      n = !1;
    ri.priorWebsocketSuccess = !1;
    const r = () => {
      n ||
        (t.send([{ type: "ping", data: "probe" }]),
        t.once("packet", (h) => {
          if (!n)
            if (h.type === "pong" && h.data === "probe") {
              if (
                ((this.upgrading = !0), this.emitReserved("upgrading", t), !t)
              )
                return;
              (ri.priorWebsocketSuccess = t.name === "websocket"),
                this.transport.pause(() => {
                  n ||
                    (this.readyState !== "closed" &&
                      (u(),
                      this.setTransport(t),
                      t.send([{ type: "upgrade" }]),
                      this.emitReserved("upgrade", t),
                      (t = null),
                      (this.upgrading = !1),
                      this.flush()));
                });
            } else {
              const f = new Error("probe error");
              (f.transport = t.name), this.emitReserved("upgradeError", f);
            }
        }));
    };
    function s() {
      n || ((n = !0), u(), t.close(), (t = null));
    }
    const a = (h) => {
      const f = new Error("probe error: " + h);
      (f.transport = t.name), s(), this.emitReserved("upgradeError", f);
    };
    function o() {
      a("transport closed");
    }
    function l() {
      a("socket closed");
    }
    function c(h) {
      t && h.name !== t.name && s();
    }
    const u = () => {
      t.removeListener("open", r),
        t.removeListener("error", a),
        t.removeListener("close", o),
        this.off("close", l),
        this.off("upgrading", c);
    };
    t.once("open", r),
      t.once("error", a),
      t.once("close", o),
      this.once("close", l),
      this.once("upgrading", c),
      this._upgrades.indexOf("webtransport") !== -1 && e !== "webtransport"
        ? this.setTimeoutFn(() => {
            n || t.open();
          }, 200)
        : t.open();
  }
  onHandshake(e) {
    (this._upgrades = this._filterUpgrades(e.upgrades)), super.onHandshake(e);
  }
  _filterUpgrades(e) {
    const t = [];
    for (let n = 0; n < e.length; n++)
      ~this.transports.indexOf(e[n]) && t.push(e[n]);
    return t;
  }
}
let yE = class extends EE {
  constructor(e, t = {}) {
    const n = typeof e == "object" ? e : t;
    (!n.transports || (n.transports && typeof n.transports[0] == "string")) &&
      (n.transports = (n.transports || ["polling", "websocket", "webtransport"])
        .map((r) => mE[r])
        .filter((r) => !!r)),
      super(e, n);
  }
};
function SE(i, e = "", t) {
  let n = i;
  (t = t || (typeof location != "undefined" && location)),
    i == null && (i = t.protocol + "//" + t.host),
    typeof i == "string" &&
      (i.charAt(0) === "/" &&
        (i.charAt(1) === "/" ? (i = t.protocol + i) : (i = t.host + i)),
      /^(https?|wss?):\/\//.test(i) ||
        (typeof t != "undefined"
          ? (i = t.protocol + "//" + i)
          : (i = "https://" + i)),
      (n = Dc(i))),
    n.port ||
      (/^(http|ws)$/.test(n.protocol)
        ? (n.port = "80")
        : /^(http|ws)s$/.test(n.protocol) && (n.port = "443")),
    (n.path = n.path || "/");
  const s = n.host.indexOf(":") !== -1 ? "[" + n.host + "]" : n.host;
  return (
    (n.id = n.protocol + "://" + s + ":" + n.port + e),
    (n.href =
      n.protocol + "://" + s + (t && t.port === n.port ? "" : ":" + n.port)),
    n
  );
}
const ME = typeof ArrayBuffer == "function",
  AE = (i) =>
    typeof ArrayBuffer.isView == "function"
      ? ArrayBuffer.isView(i)
      : i.buffer instanceof ArrayBuffer,
  Vh = Object.prototype.toString,
  bE =
    typeof Blob == "function" ||
    (typeof Blob != "undefined" &&
      Vh.call(Blob) === "[object BlobConstructor]"),
  TE =
    typeof File == "function" ||
    (typeof File != "undefined" &&
      Vh.call(File) === "[object FileConstructor]");
function sl(i) {
  return (
    (ME && (i instanceof ArrayBuffer || AE(i))) ||
    (bE && i instanceof Blob) ||
    (TE && i instanceof File)
  );
}
function va(i, e) {
  if (!i || typeof i != "object") return !1;
  if (Array.isArray(i)) {
    for (let t = 0, n = i.length; t < n; t++) if (va(i[t])) return !0;
    return !1;
  }
  if (sl(i)) return !0;
  if (i.toJSON && typeof i.toJSON == "function" && arguments.length === 1)
    return va(i.toJSON(), !0);
  for (const t in i)
    if (Object.prototype.hasOwnProperty.call(i, t) && va(i[t])) return !0;
  return !1;
}
function CE(i) {
  const e = [],
    t = i.data,
    n = i;
  return (
    (n.data = Fc(t, e)), (n.attachments = e.length), { packet: n, buffers: e }
  );
}
function Fc(i, e) {
  if (!i) return i;
  if (sl(i)) {
    const t = { _placeholder: !0, num: e.length };
    return e.push(i), t;
  } else if (Array.isArray(i)) {
    const t = new Array(i.length);
    for (let n = 0; n < i.length; n++) t[n] = Fc(i[n], e);
    return t;
  } else if (typeof i == "object" && !(i instanceof Date)) {
    const t = {};
    for (const n in i)
      Object.prototype.hasOwnProperty.call(i, n) && (t[n] = Fc(i[n], e));
    return t;
  }
  return i;
}
function wE(i, e) {
  return (i.data = Bc(i.data, e)), delete i.attachments, i;
}
function Bc(i, e) {
  if (!i) return i;
  if (i && i._placeholder === !0) {
    if (typeof i.num == "number" && i.num >= 0 && i.num < e.length)
      return e[i.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(i))
    for (let t = 0; t < i.length; t++) i[t] = Bc(i[t], e);
  else if (typeof i == "object")
    for (const t in i)
      Object.prototype.hasOwnProperty.call(i, t) && (i[t] = Bc(i[t], e));
  return i;
}
const RE = [
    "connect",
    "connect_error",
    "disconnect",
    "disconnecting",
    "newListener",
    "removeListener",
  ],
  DE = 5;
var at;
(function (i) {
  (i[(i.CONNECT = 0)] = "CONNECT"),
    (i[(i.DISCONNECT = 1)] = "DISCONNECT"),
    (i[(i.EVENT = 2)] = "EVENT"),
    (i[(i.ACK = 3)] = "ACK"),
    (i[(i.CONNECT_ERROR = 4)] = "CONNECT_ERROR"),
    (i[(i.BINARY_EVENT = 5)] = "BINARY_EVENT"),
    (i[(i.BINARY_ACK = 6)] = "BINARY_ACK");
})(at || (at = {}));
class PE {
  constructor(e) {
    this.replacer = e;
  }
  encode(e) {
    return (e.type === at.EVENT || e.type === at.ACK) && va(e)
      ? this.encodeAsBinary({
          type: e.type === at.EVENT ? at.BINARY_EVENT : at.BINARY_ACK,
          nsp: e.nsp,
          data: e.data,
          id: e.id,
        })
      : [this.encodeAsString(e)];
  }
  encodeAsString(e) {
    let t = "" + e.type;
    return (
      (e.type === at.BINARY_EVENT || e.type === at.BINARY_ACK) &&
        (t += e.attachments + "-"),
      e.nsp && e.nsp !== "/" && (t += e.nsp + ","),
      e.id != null && (t += e.id),
      e.data != null && (t += JSON.stringify(e.data, this.replacer)),
      t
    );
  }
  encodeAsBinary(e) {
    const t = CE(e),
      n = this.encodeAsString(t.packet),
      r = t.buffers;
    return r.unshift(n), r;
  }
}
function yf(i) {
  return Object.prototype.toString.call(i) === "[object Object]";
}
class al extends Ft {
  constructor(e) {
    super(), (this.reviver = e);
  }
  add(e) {
    let t;
    if (typeof e == "string") {
      if (this.reconstructor)
        throw new Error("got plaintext data when reconstructing a packet");
      t = this.decodeString(e);
      const n = t.type === at.BINARY_EVENT;
      n || t.type === at.BINARY_ACK
        ? ((t.type = n ? at.EVENT : at.ACK),
          (this.reconstructor = new FE(t)),
          t.attachments === 0 && super.emitReserved("decoded", t))
        : super.emitReserved("decoded", t);
    } else if (sl(e) || e.base64)
      if (this.reconstructor)
        (t = this.reconstructor.takeBinaryData(e)),
          t && ((this.reconstructor = null), super.emitReserved("decoded", t));
      else throw new Error("got binary data when not reconstructing a packet");
    else throw new Error("Unknown type: " + e);
  }
  decodeString(e) {
    let t = 0;
    const n = { type: Number(e.charAt(0)) };
    if (at[n.type] === void 0) throw new Error("unknown packet type " + n.type);
    if (n.type === at.BINARY_EVENT || n.type === at.BINARY_ACK) {
      const s = t + 1;
      for (; e.charAt(++t) !== "-" && t != e.length; );
      const a = e.substring(s, t);
      if (a != Number(a) || e.charAt(t) !== "-")
        throw new Error("Illegal attachments");
      n.attachments = Number(a);
    }
    if (e.charAt(t + 1) === "/") {
      const s = t + 1;
      for (; ++t && !(e.charAt(t) === "," || t === e.length); );
      n.nsp = e.substring(s, t);
    } else n.nsp = "/";
    const r = e.charAt(t + 1);
    if (r !== "" && Number(r) == r) {
      const s = t + 1;
      for (; ++t; ) {
        const a = e.charAt(t);
        if (a == null || Number(a) != a) {
          --t;
          break;
        }
        if (t === e.length) break;
      }
      n.id = Number(e.substring(s, t + 1));
    }
    if (e.charAt(++t)) {
      const s = this.tryParse(e.substr(t));
      if (al.isPayloadValid(n.type, s)) n.data = s;
      else throw new Error("invalid payload");
    }
    return n;
  }
  tryParse(e) {
    try {
      return JSON.parse(e, this.reviver);
    } catch (t) {
      return !1;
    }
  }
  static isPayloadValid(e, t) {
    switch (e) {
      case at.CONNECT:
        return yf(t);
      case at.DISCONNECT:
        return t === void 0;
      case at.CONNECT_ERROR:
        return typeof t == "string" || yf(t);
      case at.EVENT:
      case at.BINARY_EVENT:
        return (
          Array.isArray(t) &&
          (typeof t[0] == "number" ||
            (typeof t[0] == "string" && RE.indexOf(t[0]) === -1))
        );
      case at.ACK:
      case at.BINARY_ACK:
        return Array.isArray(t);
    }
  }
  destroy() {
    this.reconstructor &&
      (this.reconstructor.finishedReconstruction(),
      (this.reconstructor = null));
  }
}
class FE {
  constructor(e) {
    (this.packet = e), (this.buffers = []), (this.reconPack = e);
  }
  takeBinaryData(e) {
    if (
      (this.buffers.push(e), this.buffers.length === this.reconPack.attachments)
    ) {
      const t = wE(this.reconPack, this.buffers);
      return this.finishedReconstruction(), t;
    }
    return null;
  }
  finishedReconstruction() {
    (this.reconPack = null), (this.buffers = []);
  }
}
const BE = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      Decoder: al,
      Encoder: PE,
      get PacketType() {
        return at;
      },
      protocol: DE,
    },
    Symbol.toStringTag,
    { value: "Module" },
  ),
);
function yn(i, e, t) {
  return (
    i.on(e, t),
    function () {
      i.off(e, t);
    }
  );
}
const LE = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  newListener: 1,
  removeListener: 1,
});
class Gh extends Ft {
  constructor(e, t, n) {
    super(),
      (this.connected = !1),
      (this.recovered = !1),
      (this.receiveBuffer = []),
      (this.sendBuffer = []),
      (this._queue = []),
      (this._queueSeq = 0),
      (this.ids = 0),
      (this.acks = {}),
      (this.flags = {}),
      (this.io = e),
      (this.nsp = t),
      n && n.auth && (this.auth = n.auth),
      (this._opts = Object.assign({}, n)),
      this.io._autoConnect && this.open();
  }
  get disconnected() {
    return !this.connected;
  }
  subEvents() {
    if (this.subs) return;
    const e = this.io;
    this.subs = [
      yn(e, "open", this.onopen.bind(this)),
      yn(e, "packet", this.onpacket.bind(this)),
      yn(e, "error", this.onerror.bind(this)),
      yn(e, "close", this.onclose.bind(this)),
    ];
  }
  get active() {
    return !!this.subs;
  }
  connect() {
    return this.connected
      ? this
      : (this.subEvents(),
        this.io._reconnecting || this.io.open(),
        this.io._readyState === "open" && this.onopen(),
        this);
  }
  open() {
    return this.connect();
  }
  send(...e) {
    return e.unshift("message"), this.emit.apply(this, e), this;
  }
  emit(e, ...t) {
    var n, r, s;
    if (LE.hasOwnProperty(e))
      throw new Error('"' + e.toString() + '" is a reserved event name');
    if (
      (t.unshift(e),
      this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
    )
      return this._addToQueue(t), this;
    const a = { type: at.EVENT, data: t };
    if (
      ((a.options = {}),
      (a.options.compress = this.flags.compress !== !1),
      typeof t[t.length - 1] == "function")
    ) {
      const u = this.ids++,
        h = t.pop();
      this._registerAckCallback(u, h), (a.id = u);
    }
    const o =
        (r =
          (n = this.io.engine) === null || n === void 0
            ? void 0
            : n.transport) === null || r === void 0
          ? void 0
          : r.writable,
      l =
        this.connected &&
        !(
          !((s = this.io.engine) === null || s === void 0) &&
          s._hasPingExpired()
        );
    return (
      (this.flags.volatile && !o) ||
        (l
          ? (this.notifyOutgoingListeners(a), this.packet(a))
          : this.sendBuffer.push(a)),
      (this.flags = {}),
      this
    );
  }
  _registerAckCallback(e, t) {
    var n;
    const r =
      (n = this.flags.timeout) !== null && n !== void 0
        ? n
        : this._opts.ackTimeout;
    if (r === void 0) {
      this.acks[e] = t;
      return;
    }
    const s = this.io.setTimeoutFn(() => {
        delete this.acks[e];
        for (let o = 0; o < this.sendBuffer.length; o++)
          this.sendBuffer[o].id === e && this.sendBuffer.splice(o, 1);
        t.call(this, new Error("operation has timed out"));
      }, r),
      a = (...o) => {
        this.io.clearTimeoutFn(s), t.apply(this, o);
      };
    (a.withError = !0), (this.acks[e] = a);
  }
  emitWithAck(e, ...t) {
    return new Promise((n, r) => {
      const s = (a, o) => (a ? r(a) : n(o));
      (s.withError = !0), t.push(s), this.emit(e, ...t);
    });
  }
  _addToQueue(e) {
    let t;
    typeof e[e.length - 1] == "function" && (t = e.pop());
    const n = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: !1,
      args: e,
      flags: Object.assign({ fromQueue: !0 }, this.flags),
    };
    e.push((r, ...s) =>
      n !== this._queue[0]
        ? void 0
        : (r !== null
            ? n.tryCount > this._opts.retries &&
              (this._queue.shift(), t && t(r))
            : (this._queue.shift(), t && t(null, ...s)),
          (n.pending = !1),
          this._drainQueue()),
    ),
      this._queue.push(n),
      this._drainQueue();
  }
  _drainQueue(e = !1) {
    if (!this.connected || this._queue.length === 0) return;
    const t = this._queue[0];
    (t.pending && !e) ||
      ((t.pending = !0),
      t.tryCount++,
      (this.flags = t.flags),
      this.emit.apply(this, t.args));
  }
  packet(e) {
    (e.nsp = this.nsp), this.io._packet(e);
  }
  onopen() {
    typeof this.auth == "function"
      ? this.auth((e) => {
          this._sendConnectPacket(e);
        })
      : this._sendConnectPacket(this.auth);
  }
  _sendConnectPacket(e) {
    this.packet({
      type: at.CONNECT,
      data: this._pid
        ? Object.assign({ pid: this._pid, offset: this._lastOffset }, e)
        : e,
    });
  }
  onerror(e) {
    this.connected || this.emitReserved("connect_error", e);
  }
  onclose(e, t) {
    (this.connected = !1),
      delete this.id,
      this.emitReserved("disconnect", e, t),
      this._clearAcks();
  }
  _clearAcks() {
    Object.keys(this.acks).forEach((e) => {
      if (!this.sendBuffer.some((n) => String(n.id) === e)) {
        const n = this.acks[e];
        delete this.acks[e],
          n.withError &&
            n.call(this, new Error("socket has been disconnected"));
      }
    });
  }
  onpacket(e) {
    if (e.nsp === this.nsp)
      switch (e.type) {
        case at.CONNECT:
          e.data && e.data.sid
            ? this.onconnect(e.data.sid, e.data.pid)
            : this.emitReserved(
                "connect_error",
                new Error(
                  "It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)",
                ),
              );
          break;
        case at.EVENT:
        case at.BINARY_EVENT:
          this.onevent(e);
          break;
        case at.ACK:
        case at.BINARY_ACK:
          this.onack(e);
          break;
        case at.DISCONNECT:
          this.ondisconnect();
          break;
        case at.CONNECT_ERROR:
          this.destroy();
          const n = new Error(e.data.message);
          (n.data = e.data.data), this.emitReserved("connect_error", n);
          break;
      }
  }
  onevent(e) {
    const t = e.data || [];
    e.id != null && t.push(this.ack(e.id)),
      this.connected
        ? this.emitEvent(t)
        : this.receiveBuffer.push(Object.freeze(t));
  }
  emitEvent(e) {
    if (this._anyListeners && this._anyListeners.length) {
      const t = this._anyListeners.slice();
      for (const n of t) n.apply(this, e);
    }
    super.emit.apply(this, e),
      this._pid &&
        e.length &&
        typeof e[e.length - 1] == "string" &&
        (this._lastOffset = e[e.length - 1]);
  }
  ack(e) {
    const t = this;
    let n = !1;
    return function (...r) {
      n || ((n = !0), t.packet({ type: at.ACK, id: e, data: r }));
    };
  }
  onack(e) {
    const t = this.acks[e.id];
    typeof t == "function" &&
      (delete this.acks[e.id],
      t.withError && e.data.unshift(null),
      t.apply(this, e.data));
  }
  onconnect(e, t) {
    (this.id = e),
      (this.recovered = t && this._pid === t),
      (this._pid = t),
      (this.connected = !0),
      this.emitBuffered(),
      this.emitReserved("connect"),
      this._drainQueue(!0);
  }
  emitBuffered() {
    this.receiveBuffer.forEach((e) => this.emitEvent(e)),
      (this.receiveBuffer = []),
      this.sendBuffer.forEach((e) => {
        this.notifyOutgoingListeners(e), this.packet(e);
      }),
      (this.sendBuffer = []);
  }
  ondisconnect() {
    this.destroy(), this.onclose("io server disconnect");
  }
  destroy() {
    this.subs && (this.subs.forEach((e) => e()), (this.subs = void 0)),
      this.io._destroy(this);
  }
  disconnect() {
    return (
      this.connected && this.packet({ type: at.DISCONNECT }),
      this.destroy(),
      this.connected && this.onclose("io client disconnect"),
      this
    );
  }
  close() {
    return this.disconnect();
  }
  compress(e) {
    return (this.flags.compress = e), this;
  }
  get volatile() {
    return (this.flags.volatile = !0), this;
  }
  timeout(e) {
    return (this.flags.timeout = e), this;
  }
  onAny(e) {
    return (
      (this._anyListeners = this._anyListeners || []),
      this._anyListeners.push(e),
      this
    );
  }
  prependAny(e) {
    return (
      (this._anyListeners = this._anyListeners || []),
      this._anyListeners.unshift(e),
      this
    );
  }
  offAny(e) {
    if (!this._anyListeners) return this;
    if (e) {
      const t = this._anyListeners;
      for (let n = 0; n < t.length; n++)
        if (e === t[n]) return t.splice(n, 1), this;
    } else this._anyListeners = [];
    return this;
  }
  listenersAny() {
    return this._anyListeners || [];
  }
  onAnyOutgoing(e) {
    return (
      (this._anyOutgoingListeners = this._anyOutgoingListeners || []),
      this._anyOutgoingListeners.push(e),
      this
    );
  }
  prependAnyOutgoing(e) {
    return (
      (this._anyOutgoingListeners = this._anyOutgoingListeners || []),
      this._anyOutgoingListeners.unshift(e),
      this
    );
  }
  offAnyOutgoing(e) {
    if (!this._anyOutgoingListeners) return this;
    if (e) {
      const t = this._anyOutgoingListeners;
      for (let n = 0; n < t.length; n++)
        if (e === t[n]) return t.splice(n, 1), this;
    } else this._anyOutgoingListeners = [];
    return this;
  }
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  notifyOutgoingListeners(e) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const t = this._anyOutgoingListeners.slice();
      for (const n of t) n.apply(this, e.data);
    }
  }
}
function _r(i) {
  (i = i || {}),
    (this.ms = i.min || 100),
    (this.max = i.max || 1e4),
    (this.factor = i.factor || 2),
    (this.jitter = i.jitter > 0 && i.jitter <= 1 ? i.jitter : 0),
    (this.attempts = 0);
}
_r.prototype.duration = function () {
  var i = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var e = Math.random(),
      t = Math.floor(e * this.jitter * i);
    i = (Math.floor(e * 10) & 1) == 0 ? i - t : i + t;
  }
  return Math.min(i, this.max) | 0;
};
_r.prototype.reset = function () {
  this.attempts = 0;
};
_r.prototype.setMin = function (i) {
  this.ms = i;
};
_r.prototype.setMax = function (i) {
  this.max = i;
};
_r.prototype.setJitter = function (i) {
  this.jitter = i;
};
class Lc extends Ft {
  constructor(e, t) {
    var n;
    super(),
      (this.nsps = {}),
      (this.subs = []),
      e && typeof e == "object" && ((t = e), (e = void 0)),
      (t = t || {}),
      (t.path = t.path || "/socket.io"),
      (this.opts = t),
      Ia(this, t),
      this.reconnection(t.reconnection !== !1),
      this.reconnectionAttempts(t.reconnectionAttempts || 1 / 0),
      this.reconnectionDelay(t.reconnectionDelay || 1e3),
      this.reconnectionDelayMax(t.reconnectionDelayMax || 5e3),
      this.randomizationFactor(
        (n = t.randomizationFactor) !== null && n !== void 0 ? n : 0.5,
      ),
      (this.backoff = new _r({
        min: this.reconnectionDelay(),
        max: this.reconnectionDelayMax(),
        jitter: this.randomizationFactor(),
      })),
      this.timeout(t.timeout == null ? 2e4 : t.timeout),
      (this._readyState = "closed"),
      (this.uri = e);
    const r = t.parser || BE;
    (this.encoder = new r.Encoder()),
      (this.decoder = new r.Decoder()),
      (this._autoConnect = t.autoConnect !== !1),
      this._autoConnect && this.open();
  }
  reconnection(e) {
    return arguments.length
      ? ((this._reconnection = !!e), e || (this.skipReconnect = !0), this)
      : this._reconnection;
  }
  reconnectionAttempts(e) {
    return e === void 0
      ? this._reconnectionAttempts
      : ((this._reconnectionAttempts = e), this);
  }
  reconnectionDelay(e) {
    var t;
    return e === void 0
      ? this._reconnectionDelay
      : ((this._reconnectionDelay = e),
        (t = this.backoff) === null || t === void 0 || t.setMin(e),
        this);
  }
  randomizationFactor(e) {
    var t;
    return e === void 0
      ? this._randomizationFactor
      : ((this._randomizationFactor = e),
        (t = this.backoff) === null || t === void 0 || t.setJitter(e),
        this);
  }
  reconnectionDelayMax(e) {
    var t;
    return e === void 0
      ? this._reconnectionDelayMax
      : ((this._reconnectionDelayMax = e),
        (t = this.backoff) === null || t === void 0 || t.setMax(e),
        this);
  }
  timeout(e) {
    return arguments.length ? ((this._timeout = e), this) : this._timeout;
  }
  maybeReconnectOnOpen() {
    !this._reconnecting &&
      this._reconnection &&
      this.backoff.attempts === 0 &&
      this.reconnect();
  }
  open(e) {
    if (~this._readyState.indexOf("open")) return this;
    this.engine = new yE(this.uri, this.opts);
    const t = this.engine,
      n = this;
    (this._readyState = "opening"), (this.skipReconnect = !1);
    const r = yn(t, "open", function () {
        n.onopen(), e && e();
      }),
      s = (o) => {
        this.cleanup(),
          (this._readyState = "closed"),
          this.emitReserved("error", o),
          e ? e(o) : this.maybeReconnectOnOpen();
      },
      a = yn(t, "error", s);
    if (this._timeout !== !1) {
      const o = this._timeout,
        l = this.setTimeoutFn(() => {
          r(), s(new Error("timeout")), t.close();
        }, o);
      this.opts.autoUnref && l.unref(),
        this.subs.push(() => {
          this.clearTimeoutFn(l);
        });
    }
    return this.subs.push(r), this.subs.push(a), this;
  }
  connect(e) {
    return this.open(e);
  }
  onopen() {
    this.cleanup(), (this._readyState = "open"), this.emitReserved("open");
    const e = this.engine;
    this.subs.push(
      yn(e, "ping", this.onping.bind(this)),
      yn(e, "data", this.ondata.bind(this)),
      yn(e, "error", this.onerror.bind(this)),
      yn(e, "close", this.onclose.bind(this)),
      yn(this.decoder, "decoded", this.ondecoded.bind(this)),
    );
  }
  onping() {
    this.emitReserved("ping");
  }
  ondata(e) {
    try {
      this.decoder.add(e);
    } catch (t) {
      this.onclose("parse error", t);
    }
  }
  ondecoded(e) {
    Ua(() => {
      this.emitReserved("packet", e);
    }, this.setTimeoutFn);
  }
  onerror(e) {
    this.emitReserved("error", e);
  }
  socket(e, t) {
    let n = this.nsps[e];
    return (
      n
        ? this._autoConnect && !n.active && n.connect()
        : ((n = new Gh(this, e, t)), (this.nsps[e] = n)),
      n
    );
  }
  _destroy(e) {
    const t = Object.keys(this.nsps);
    for (const n of t) if (this.nsps[n].active) return;
    this._close();
  }
  _packet(e) {
    const t = this.encoder.encode(e);
    for (let n = 0; n < t.length; n++) this.engine.write(t[n], e.options);
  }
  cleanup() {
    this.subs.forEach((e) => e()),
      (this.subs.length = 0),
      this.decoder.destroy();
  }
  _close() {
    (this.skipReconnect = !0),
      (this._reconnecting = !1),
      this.onclose("forced close");
  }
  disconnect() {
    return this._close();
  }
  onclose(e, t) {
    var n;
    this.cleanup(),
      (n = this.engine) === null || n === void 0 || n.close(),
      this.backoff.reset(),
      (this._readyState = "closed"),
      this.emitReserved("close", e, t),
      this._reconnection && !this.skipReconnect && this.reconnect();
  }
  reconnect() {
    if (this._reconnecting || this.skipReconnect) return this;
    const e = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(),
        this.emitReserved("reconnect_failed"),
        (this._reconnecting = !1);
    else {
      const t = this.backoff.duration();
      this._reconnecting = !0;
      const n = this.setTimeoutFn(() => {
        e.skipReconnect ||
          (this.emitReserved("reconnect_attempt", e.backoff.attempts),
          !e.skipReconnect &&
            e.open((r) => {
              r
                ? ((e._reconnecting = !1),
                  e.reconnect(),
                  this.emitReserved("reconnect_error", r))
                : e.onreconnect();
            }));
      }, t);
      this.opts.autoUnref && n.unref(),
        this.subs.push(() => {
          this.clearTimeoutFn(n);
        });
    }
  }
  onreconnect() {
    const e = this.backoff.attempts;
    (this._reconnecting = !1),
      this.backoff.reset(),
      this.emitReserved("reconnect", e);
  }
}
const Fr = {};
function Fo(i, e) {
  typeof i == "object" && ((e = i), (i = void 0)), (e = e || {});
  const t = SE(i, e.path || "/socket.io"),
    n = t.source,
    r = t.id,
    s = t.path,
    a = Fr[r] && s in Fr[r].nsps,
    o = e.forceNew || e["force new connection"] || e.multiplex === !1 || a;
  let l;
  return (
    o ? (l = new Lc(n, e)) : (Fr[r] || (Fr[r] = new Lc(n, e)), (l = Fr[r])),
    t.query && !e.query && (e.query = t.queryKey),
    l.socket(t.path, e)
  );
}
Object.assign(Fo, { Manager: Lc, Socket: Gh, io: Fo, connect: Fo });
function Wh(i, e) {
  return function () {
    return i.apply(e, arguments);
  };
}
const { toString: UE } = Object.prototype,
  { getPrototypeOf: ol } = Object,
  { iterator: Na, toStringTag: Xh } = Symbol,
  Oa = ((i) => (e) => {
    const t = UE.call(e);
    return i[t] || (i[t] = t.slice(8, -1).toLowerCase());
  })(Object.create(null)),
  Tn = (i) => ((i = i.toLowerCase()), (e) => Oa(e) === i),
  za = (i) => (e) => typeof e === i,
  { isArray: vr } = Array,
  mr = za("undefined");
function qr(i) {
  return (
    i !== null &&
    !mr(i) &&
    i.constructor !== null &&
    !mr(i.constructor) &&
    en(i.constructor.isBuffer) &&
    i.constructor.isBuffer(i)
  );
}
const qh = Tn("ArrayBuffer");
function IE(i) {
  let e;
  return (
    typeof ArrayBuffer != "undefined" && ArrayBuffer.isView
      ? (e = ArrayBuffer.isView(i))
      : (e = i && i.buffer && qh(i.buffer)),
    e
  );
}
const NE = za("string"),
  en = za("function"),
  Yh = za("number"),
  Yr = (i) => i !== null && typeof i == "object",
  OE = (i) => i === !0 || i === !1,
  Ea = (i) => {
    if (Oa(i) !== "object") return !1;
    const e = ol(i);
    return (
      (e === null ||
        e === Object.prototype ||
        Object.getPrototypeOf(e) === null) &&
      !(Xh in i) &&
      !(Na in i)
    );
  },
  zE = (i) => {
    if (!Yr(i) || qr(i)) return !1;
    try {
      return (
        Object.keys(i).length === 0 &&
        Object.getPrototypeOf(i) === Object.prototype
      );
    } catch (e) {
      return !1;
    }
  },
  kE = Tn("Date"),
  HE = Tn("File"),
  VE = Tn("Blob"),
  GE = Tn("FileList"),
  WE = (i) => Yr(i) && en(i.pipe),
  XE = (i) => {
    let e;
    return (
      i &&
      ((typeof FormData == "function" && i instanceof FormData) ||
        (en(i.append) &&
          ((e = Oa(i)) === "formdata" ||
            (e === "object" &&
              en(i.toString) &&
              i.toString() === "[object FormData]"))))
    );
  },
  qE = Tn("URLSearchParams"),
  [YE, $E, jE, KE] = ["ReadableStream", "Request", "Response", "Headers"].map(
    Tn,
  ),
  ZE = (i) =>
    i.trim ? i.trim() : i.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function $r(i, e, { allOwnKeys: t = !1 } = {}) {
  if (i === null || typeof i == "undefined") return;
  let n, r;
  if ((typeof i != "object" && (i = [i]), vr(i)))
    for (n = 0, r = i.length; n < r; n++) e.call(null, i[n], n, i);
  else {
    if (qr(i)) return;
    const s = t ? Object.getOwnPropertyNames(i) : Object.keys(i),
      a = s.length;
    let o;
    for (n = 0; n < a; n++) (o = s[n]), e.call(null, i[o], o, i);
  }
}
function $h(i, e) {
  if (qr(i)) return null;
  e = e.toLowerCase();
  const t = Object.keys(i);
  let n = t.length,
    r;
  for (; n-- > 0; ) if (((r = t[n]), e === r.toLowerCase())) return r;
  return null;
}
const Ai =
    typeof globalThis != "undefined"
      ? globalThis
      : typeof self != "undefined"
        ? self
        : typeof window != "undefined"
          ? window
          : global,
  jh = (i) => !mr(i) && i !== Ai;
function Uc() {
  const { caseless: i, skipUndefined: e } = (jh(this) && this) || {},
    t = {},
    n = (r, s) => {
      const a = (i && $h(t, s)) || s;
      Ea(t[a]) && Ea(r)
        ? (t[a] = Uc(t[a], r))
        : Ea(r)
          ? (t[a] = Uc({}, r))
          : vr(r)
            ? (t[a] = r.slice())
            : (!e || !mr(r)) && (t[a] = r);
    };
  for (let r = 0, s = arguments.length; r < s; r++)
    arguments[r] && $r(arguments[r], n);
  return t;
}
const JE = (i, e, t, { allOwnKeys: n } = {}) => (
    $r(
      e,
      (r, s) => {
        t && en(r) ? (i[s] = Wh(r, t)) : (i[s] = r);
      },
      { allOwnKeys: n },
    ),
    i
  ),
  QE = (i) => (i.charCodeAt(0) === 65279 && (i = i.slice(1)), i),
  ey = (i, e, t, n) => {
    (i.prototype = Object.create(e.prototype, n)),
      (i.prototype.constructor = i),
      Object.defineProperty(i, "super", { value: e.prototype }),
      t && Object.assign(i.prototype, t);
  },
  ty = (i, e, t, n) => {
    let r, s, a;
    const o = {};
    if (((e = e || {}), i == null)) return e;
    do {
      for (r = Object.getOwnPropertyNames(i), s = r.length; s-- > 0; )
        (a = r[s]), (!n || n(a, i, e)) && !o[a] && ((e[a] = i[a]), (o[a] = !0));
      i = t !== !1 && ol(i);
    } while (i && (!t || t(i, e)) && i !== Object.prototype);
    return e;
  },
  ny = (i, e, t) => {
    (i = String(i)),
      (t === void 0 || t > i.length) && (t = i.length),
      (t -= e.length);
    const n = i.indexOf(e, t);
    return n !== -1 && n === t;
  },
  iy = (i) => {
    if (!i) return null;
    if (vr(i)) return i;
    let e = i.length;
    if (!Yh(e)) return null;
    const t = new Array(e);
    for (; e-- > 0; ) t[e] = i[e];
    return t;
  },
  ry = (
    (i) => (e) =>
      i && e instanceof i
  )(typeof Uint8Array != "undefined" && ol(Uint8Array)),
  sy = (i, e) => {
    const n = (i && i[Na]).call(i);
    let r;
    for (; (r = n.next()) && !r.done; ) {
      const s = r.value;
      e.call(i, s[0], s[1]);
    }
  },
  ay = (i, e) => {
    let t;
    const n = [];
    for (; (t = i.exec(e)) !== null; ) n.push(t);
    return n;
  },
  oy = Tn("HTMLFormElement"),
  cy = (i) =>
    i.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (t, n, r) {
      return n.toUpperCase() + r;
    }),
  Sf = (
    ({ hasOwnProperty: i }) =>
    (e, t) =>
      i.call(e, t)
  )(Object.prototype),
  ly = Tn("RegExp"),
  Kh = (i, e) => {
    const t = Object.getOwnPropertyDescriptors(i),
      n = {};
    $r(t, (r, s) => {
      let a;
      (a = e(r, s, i)) !== !1 && (n[s] = a || r);
    }),
      Object.defineProperties(i, n);
  },
  uy = (i) => {
    Kh(i, (e, t) => {
      if (en(i) && ["arguments", "caller", "callee"].indexOf(t) !== -1)
        return !1;
      const n = i[t];
      if (en(n)) {
        if (((e.enumerable = !1), "writable" in e)) {
          e.writable = !1;
          return;
        }
        e.set ||
          (e.set = () => {
            throw Error("Can not rewrite read-only method '" + t + "'");
          });
      }
    });
  },
  fy = (i, e) => {
    const t = {},
      n = (r) => {
        r.forEach((s) => {
          t[s] = !0;
        });
      };
    return vr(i) ? n(i) : n(String(i).split(e)), t;
  },
  hy = () => {},
  dy = (i, e) => (i != null && Number.isFinite((i = +i)) ? i : e);
function py(i) {
  return !!(i && en(i.append) && i[Xh] === "FormData" && i[Na]);
}
const my = (i) => {
    const e = new Array(10),
      t = (n, r) => {
        if (Yr(n)) {
          if (e.indexOf(n) >= 0) return;
          if (qr(n)) return n;
          if (!("toJSON" in n)) {
            e[r] = n;
            const s = vr(n) ? [] : {};
            return (
              $r(n, (a, o) => {
                const l = t(a, r + 1);
                !mr(l) && (s[o] = l);
              }),
              (e[r] = void 0),
              s
            );
          }
        }
        return n;
      };
    return t(i, 0);
  },
  xy = Tn("AsyncFunction"),
  gy = (i) => i && (Yr(i) || en(i)) && en(i.then) && en(i.catch),
  Zh = ((i, e) =>
    i
      ? setImmediate
      : e
        ? ((t, n) => (
            Ai.addEventListener(
              "message",
              ({ source: r, data: s }) => {
                r === Ai && s === t && n.length && n.shift()();
              },
              !1,
            ),
            (r) => {
              n.push(r), Ai.postMessage(t, "*");
            }
          ))(`axios@${Math.random()}`, [])
        : (t) => setTimeout(t))(
    typeof setImmediate == "function",
    en(Ai.postMessage),
  ),
  _y =
    typeof queueMicrotask != "undefined"
      ? queueMicrotask.bind(Ai)
      : (typeof process != "undefined" && process.nextTick) || Zh,
  vy = (i) => i != null && en(i[Na]),
  Z = {
    isArray: vr,
    isArrayBuffer: qh,
    isBuffer: qr,
    isFormData: XE,
    isArrayBufferView: IE,
    isString: NE,
    isNumber: Yh,
    isBoolean: OE,
    isObject: Yr,
    isPlainObject: Ea,
    isEmptyObject: zE,
    isReadableStream: YE,
    isRequest: $E,
    isResponse: jE,
    isHeaders: KE,
    isUndefined: mr,
    isDate: kE,
    isFile: HE,
    isBlob: VE,
    isRegExp: ly,
    isFunction: en,
    isStream: WE,
    isURLSearchParams: qE,
    isTypedArray: ry,
    isFileList: GE,
    forEach: $r,
    merge: Uc,
    extend: JE,
    trim: ZE,
    stripBOM: QE,
    inherits: ey,
    toFlatObject: ty,
    kindOf: Oa,
    kindOfTest: Tn,
    endsWith: ny,
    toArray: iy,
    forEachEntry: sy,
    matchAll: ay,
    isHTMLForm: oy,
    hasOwnProperty: Sf,
    hasOwnProp: Sf,
    reduceDescriptors: Kh,
    freezeMethods: uy,
    toObjectSet: fy,
    toCamelCase: cy,
    noop: hy,
    toFiniteNumber: dy,
    findKey: $h,
    global: Ai,
    isContextDefined: jh,
    isSpecCompliantForm: py,
    toJSONObject: my,
    isAsyncFn: xy,
    isThenable: gy,
    setImmediate: Zh,
    asap: _y,
    isIterable: vy,
  };
function je(i, e, t, n, r) {
  Error.call(this),
    Error.captureStackTrace
      ? Error.captureStackTrace(this, this.constructor)
      : (this.stack = new Error().stack),
    (this.message = i),
    (this.name = "AxiosError"),
    e && (this.code = e),
    t && (this.config = t),
    n && (this.request = n),
    r && ((this.response = r), (this.status = r.status ? r.status : null));
}
Z.inherits(je, Error, {
  toJSON: function () {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: Z.toJSONObject(this.config),
      code: this.code,
      status: this.status,
    };
  },
});
const Jh = je.prototype,
  Qh = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL",
].forEach((i) => {
  Qh[i] = { value: i };
});
Object.defineProperties(je, Qh);
Object.defineProperty(Jh, "isAxiosError", { value: !0 });
je.from = (i, e, t, n, r, s) => {
  const a = Object.create(Jh);
  Z.toFlatObject(
    i,
    a,
    function (u) {
      return u !== Error.prototype;
    },
    (c) => c !== "isAxiosError",
  );
  const o = i && i.message ? i.message : "Error",
    l = e == null && i ? i.code : e;
  return (
    je.call(a, o, l, t, n, r),
    i &&
      a.cause == null &&
      Object.defineProperty(a, "cause", { value: i, configurable: !0 }),
    (a.name = (i && i.name) || "Error"),
    s && Object.assign(a, s),
    a
  );
};
const Ey = null;
function Ic(i) {
  return Z.isPlainObject(i) || Z.isArray(i);
}
function ed(i) {
  return Z.endsWith(i, "[]") ? i.slice(0, -2) : i;
}
function Mf(i, e, t) {
  return i
    ? i
        .concat(e)
        .map(function (r, s) {
          return (r = ed(r)), !t && s ? "[" + r + "]" : r;
        })
        .join(t ? "." : "")
    : e;
}
function yy(i) {
  return Z.isArray(i) && !i.some(Ic);
}
const Sy = Z.toFlatObject(Z, {}, null, function (e) {
  return /^is[A-Z]/.test(e);
});
function ka(i, e, t) {
  if (!Z.isObject(i)) throw new TypeError("target must be an object");
  (e = e || new FormData()),
    (t = Z.toFlatObject(
      t,
      { metaTokens: !0, dots: !1, indexes: !1 },
      !1,
      function (g, d) {
        return !Z.isUndefined(d[g]);
      },
    ));
  const n = t.metaTokens,
    r = t.visitor || u,
    s = t.dots,
    a = t.indexes,
    l =
      (t.Blob || (typeof Blob != "undefined" && Blob)) &&
      Z.isSpecCompliantForm(e);
  if (!Z.isFunction(r)) throw new TypeError("visitor must be a function");
  function c(x) {
    if (x === null) return "";
    if (Z.isDate(x)) return x.toISOString();
    if (Z.isBoolean(x)) return x.toString();
    if (!l && Z.isBlob(x))
      throw new je("Blob is not supported. Use a Buffer instead.");
    return Z.isArrayBuffer(x) || Z.isTypedArray(x)
      ? l && typeof Blob == "function"
        ? new Blob([x])
        : Buffer.from(x)
      : x;
  }
  function u(x, g, d) {
    let p = x;
    if (x && !d && typeof x == "object") {
      if (Z.endsWith(g, "{}"))
        (g = n ? g : g.slice(0, -2)), (x = JSON.stringify(x));
      else if (
        (Z.isArray(x) && yy(x)) ||
        ((Z.isFileList(x) || Z.endsWith(g, "[]")) && (p = Z.toArray(x)))
      )
        return (
          (g = ed(g)),
          p.forEach(function (E, v) {
            !(Z.isUndefined(E) || E === null) &&
              e.append(
                a === !0 ? Mf([g], v, s) : a === null ? g : g + "[]",
                c(E),
              );
          }),
          !1
        );
    }
    return Ic(x) ? !0 : (e.append(Mf(d, g, s), c(x)), !1);
  }
  const h = [],
    f = Object.assign(Sy, {
      defaultVisitor: u,
      convertValue: c,
      isVisitable: Ic,
    });
  function m(x, g) {
    if (!Z.isUndefined(x)) {
      if (h.indexOf(x) !== -1)
        throw Error("Circular reference detected in " + g.join("."));
      h.push(x),
        Z.forEach(x, function (p, y) {
          (!(Z.isUndefined(p) || p === null) &&
            r.call(e, p, Z.isString(y) ? y.trim() : y, g, f)) === !0 &&
            m(p, g ? g.concat(y) : [y]);
        }),
        h.pop();
    }
  }
  if (!Z.isObject(i)) throw new TypeError("data must be an object");
  return m(i), e;
}
function Af(i) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0",
  };
  return encodeURIComponent(i).replace(/[!'()~]|%20|%00/g, function (n) {
    return e[n];
  });
}
function cl(i, e) {
  (this._pairs = []), i && ka(i, this, e);
}
const td = cl.prototype;
td.append = function (e, t) {
  this._pairs.push([e, t]);
};
td.toString = function (e) {
  const t = e
    ? function (n) {
        return e.call(this, n, Af);
      }
    : Af;
  return this._pairs
    .map(function (r) {
      return t(r[0]) + "=" + t(r[1]);
    }, "")
    .join("&");
};
function My(i) {
  return encodeURIComponent(i)
    .replace(/%3A/gi, ":")
    .replace(/%24/g, "$")
    .replace(/%2C/gi, ",")
    .replace(/%20/g, "+");
}
function nd(i, e, t) {
  if (!e) return i;
  const n = (t && t.encode) || My;
  Z.isFunction(t) && (t = { serialize: t });
  const r = t && t.serialize;
  let s;
  if (
    (r
      ? (s = r(e, t))
      : (s = Z.isURLSearchParams(e) ? e.toString() : new cl(e, t).toString(n)),
    s)
  ) {
    const a = i.indexOf("#");
    a !== -1 && (i = i.slice(0, a)),
      (i += (i.indexOf("?") === -1 ? "?" : "&") + s);
  }
  return i;
}
class bf {
  constructor() {
    this.handlers = [];
  }
  use(e, t, n) {
    return (
      this.handlers.push({
        fulfilled: e,
        rejected: t,
        synchronous: n ? n.synchronous : !1,
        runWhen: n ? n.runWhen : null,
      }),
      this.handlers.length - 1
    );
  }
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  clear() {
    this.handlers && (this.handlers = []);
  }
  forEach(e) {
    Z.forEach(this.handlers, function (n) {
      n !== null && e(n);
    });
  }
}
const id = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1,
  },
  Ay = typeof URLSearchParams != "undefined" ? URLSearchParams : cl,
  by = typeof FormData != "undefined" ? FormData : null,
  Ty = typeof Blob != "undefined" ? Blob : null,
  Cy = {
    isBrowser: !0,
    classes: { URLSearchParams: Ay, FormData: by, Blob: Ty },
    protocols: ["http", "https", "file", "blob", "url", "data"],
  },
  ll = typeof window != "undefined" && typeof document != "undefined",
  Nc = (typeof navigator == "object" && navigator) || void 0,
  wy =
    ll &&
    (!Nc || ["ReactNative", "NativeScript", "NS"].indexOf(Nc.product) < 0),
  Ry =
    typeof WorkerGlobalScope != "undefined" &&
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts == "function",
  Dy = (ll && window.location.href) || "http://localhost",
  Py = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        hasBrowserEnv: ll,
        hasStandardBrowserEnv: wy,
        hasStandardBrowserWebWorkerEnv: Ry,
        navigator: Nc,
        origin: Dy,
      },
      Symbol.toStringTag,
      { value: "Module" },
    ),
  ),
  Xt = Xn(Xn({}, Py), Cy);
function Fy(i, e) {
  return ka(
    i,
    new Xt.classes.URLSearchParams(),
    Xn(
      {
        visitor: function (t, n, r, s) {
          return Xt.isNode && Z.isBuffer(t)
            ? (this.append(n, t.toString("base64")), !1)
            : s.defaultVisitor.apply(this, arguments);
        },
      },
      e,
    ),
  );
}
function By(i) {
  return Z.matchAll(/\w+|\[(\w*)]/g, i).map((e) =>
    e[0] === "[]" ? "" : e[1] || e[0],
  );
}
function Ly(i) {
  const e = {},
    t = Object.keys(i);
  let n;
  const r = t.length;
  let s;
  for (n = 0; n < r; n++) (s = t[n]), (e[s] = i[s]);
  return e;
}
function rd(i) {
  function e(t, n, r, s) {
    let a = t[s++];
    if (a === "__proto__") return !0;
    const o = Number.isFinite(+a),
      l = s >= t.length;
    return (
      (a = !a && Z.isArray(r) ? r.length : a),
      l
        ? (Z.hasOwnProp(r, a) ? (r[a] = [r[a], n]) : (r[a] = n), !o)
        : ((!r[a] || !Z.isObject(r[a])) && (r[a] = []),
          e(t, n, r[a], s) && Z.isArray(r[a]) && (r[a] = Ly(r[a])),
          !o)
    );
  }
  if (Z.isFormData(i) && Z.isFunction(i.entries)) {
    const t = {};
    return (
      Z.forEachEntry(i, (n, r) => {
        e(By(n), r, t, 0);
      }),
      t
    );
  }
  return null;
}
function Uy(i, e, t) {
  if (Z.isString(i))
    try {
      return (e || JSON.parse)(i), Z.trim(i);
    } catch (n) {
      if (n.name !== "SyntaxError") throw n;
    }
  return (t || JSON.stringify)(i);
}
const jr = {
  transitional: id,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [
    function (e, t) {
      const n = t.getContentType() || "",
        r = n.indexOf("application/json") > -1,
        s = Z.isObject(e);
      if ((s && Z.isHTMLForm(e) && (e = new FormData(e)), Z.isFormData(e)))
        return r ? JSON.stringify(rd(e)) : e;
      if (
        Z.isArrayBuffer(e) ||
        Z.isBuffer(e) ||
        Z.isStream(e) ||
        Z.isFile(e) ||
        Z.isBlob(e) ||
        Z.isReadableStream(e)
      )
        return e;
      if (Z.isArrayBufferView(e)) return e.buffer;
      if (Z.isURLSearchParams(e))
        return (
          t.setContentType(
            "application/x-www-form-urlencoded;charset=utf-8",
            !1,
          ),
          e.toString()
        );
      let o;
      if (s) {
        if (n.indexOf("application/x-www-form-urlencoded") > -1)
          return Fy(e, this.formSerializer).toString();
        if ((o = Z.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
          const l = this.env && this.env.FormData;
          return ka(
            o ? { "files[]": e } : e,
            l && new l(),
            this.formSerializer,
          );
        }
      }
      return s || r ? (t.setContentType("application/json", !1), Uy(e)) : e;
    },
  ],
  transformResponse: [
    function (e) {
      const t = this.transitional || jr.transitional,
        n = t && t.forcedJSONParsing,
        r = this.responseType === "json";
      if (Z.isResponse(e) || Z.isReadableStream(e)) return e;
      if (e && Z.isString(e) && ((n && !this.responseType) || r)) {
        const a = !(t && t.silentJSONParsing) && r;
        try {
          return JSON.parse(e, this.parseReviver);
        } catch (o) {
          if (a)
            throw o.name === "SyntaxError"
              ? je.from(o, je.ERR_BAD_RESPONSE, this, null, this.response)
              : o;
        }
      }
      return e;
    },
  ],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: { FormData: Xt.classes.FormData, Blob: Xt.classes.Blob },
  validateStatus: function (e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0,
    },
  },
};
Z.forEach(["delete", "get", "head", "post", "put", "patch"], (i) => {
  jr.headers[i] = {};
});
const Iy = Z.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent",
  ]),
  Ny = (i) => {
    const e = {};
    let t, n, r;
    return (
      i &&
        i
          .split(
            `
`,
          )
          .forEach(function (a) {
            (r = a.indexOf(":")),
              (t = a.substring(0, r).trim().toLowerCase()),
              (n = a.substring(r + 1).trim()),
              !(!t || (e[t] && Iy[t])) &&
                (t === "set-cookie"
                  ? e[t]
                    ? e[t].push(n)
                    : (e[t] = [n])
                  : (e[t] = e[t] ? e[t] + ", " + n : n));
          }),
      e
    );
  },
  Tf = Symbol("internals");
function Br(i) {
  return i && String(i).trim().toLowerCase();
}
function ya(i) {
  return i === !1 || i == null ? i : Z.isArray(i) ? i.map(ya) : String(i);
}
function Oy(i) {
  const e = Object.create(null),
    t = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n;
  for (; (n = t.exec(i)); ) e[n[1]] = n[2];
  return e;
}
const zy = (i) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(i.trim());
function Bo(i, e, t, n, r) {
  if (Z.isFunction(n)) return n.call(this, e, t);
  if ((r && (e = t), !!Z.isString(e))) {
    if (Z.isString(n)) return e.indexOf(n) !== -1;
    if (Z.isRegExp(n)) return n.test(e);
  }
}
function ky(i) {
  return i
    .trim()
    .toLowerCase()
    .replace(/([a-z\d])(\w*)/g, (e, t, n) => t.toUpperCase() + n);
}
function Hy(i, e) {
  const t = Z.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(i, n + t, {
      value: function (r, s, a) {
        return this[n].call(this, e, r, s, a);
      },
      configurable: !0,
    });
  });
}
let tn = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, t, n) {
    const r = this;
    function s(o, l, c) {
      const u = Br(l);
      if (!u) throw new Error("header name must be a non-empty string");
      const h = Z.findKey(r, u);
      (!h || r[h] === void 0 || c === !0 || (c === void 0 && r[h] !== !1)) &&
        (r[h || l] = ya(o));
    }
    const a = (o, l) => Z.forEach(o, (c, u) => s(c, u, l));
    if (Z.isPlainObject(e) || e instanceof this.constructor) a(e, t);
    else if (Z.isString(e) && (e = e.trim()) && !zy(e)) a(Ny(e), t);
    else if (Z.isObject(e) && Z.isIterable(e)) {
      let o = {},
        l,
        c;
      for (const u of e) {
        if (!Z.isArray(u))
          throw TypeError("Object iterator must return a key-value pair");
        o[(c = u[0])] = (l = o[c])
          ? Z.isArray(l)
            ? [...l, u[1]]
            : [l, u[1]]
          : u[1];
      }
      a(o, t);
    } else e != null && s(t, e, n);
    return this;
  }
  get(e, t) {
    if (((e = Br(e)), e)) {
      const n = Z.findKey(this, e);
      if (n) {
        const r = this[n];
        if (!t) return r;
        if (t === !0) return Oy(r);
        if (Z.isFunction(t)) return t.call(this, r, n);
        if (Z.isRegExp(t)) return t.exec(r);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, t) {
    if (((e = Br(e)), e)) {
      const n = Z.findKey(this, e);
      return !!(n && this[n] !== void 0 && (!t || Bo(this, this[n], n, t)));
    }
    return !1;
  }
  delete(e, t) {
    const n = this;
    let r = !1;
    function s(a) {
      if (((a = Br(a)), a)) {
        const o = Z.findKey(n, a);
        o && (!t || Bo(n, n[o], o, t)) && (delete n[o], (r = !0));
      }
    }
    return Z.isArray(e) ? e.forEach(s) : s(e), r;
  }
  clear(e) {
    const t = Object.keys(this);
    let n = t.length,
      r = !1;
    for (; n--; ) {
      const s = t[n];
      (!e || Bo(this, this[s], s, e, !0)) && (delete this[s], (r = !0));
    }
    return r;
  }
  normalize(e) {
    const t = this,
      n = {};
    return (
      Z.forEach(this, (r, s) => {
        const a = Z.findKey(n, s);
        if (a) {
          (t[a] = ya(r)), delete t[s];
          return;
        }
        const o = e ? ky(s) : String(s).trim();
        o !== s && delete t[s], (t[o] = ya(r)), (n[o] = !0);
      }),
      this
    );
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const t = Object.create(null);
    return (
      Z.forEach(this, (n, r) => {
        n != null && n !== !1 && (t[r] = e && Z.isArray(n) ? n.join(", ") : n);
      }),
      t
    );
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, t]) => e + ": " + t).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...t) {
    const n = new this(e);
    return t.forEach((r) => n.set(r)), n;
  }
  static accessor(e) {
    const n = (this[Tf] = this[Tf] = { accessors: {} }).accessors,
      r = this.prototype;
    function s(a) {
      const o = Br(a);
      n[o] || (Hy(r, a), (n[o] = !0));
    }
    return Z.isArray(e) ? e.forEach(s) : s(e), this;
  }
};
tn.accessor([
  "Content-Type",
  "Content-Length",
  "Accept",
  "Accept-Encoding",
  "User-Agent",
  "Authorization",
]);
Z.reduceDescriptors(tn.prototype, ({ value: i }, e) => {
  let t = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => i,
    set(n) {
      this[t] = n;
    },
  };
});
Z.freezeMethods(tn);
function Lo(i, e) {
  const t = this || jr,
    n = e || t,
    r = tn.from(n.headers);
  let s = n.data;
  return (
    Z.forEach(i, function (o) {
      s = o.call(t, s, r.normalize(), e ? e.status : void 0);
    }),
    r.normalize(),
    s
  );
}
function sd(i) {
  return !!(i && i.__CANCEL__);
}
function Er(i, e, t) {
  je.call(this, i == null ? "canceled" : i, je.ERR_CANCELED, e, t),
    (this.name = "CanceledError");
}
Z.inherits(Er, je, { __CANCEL__: !0 });
function ad(i, e, t) {
  const n = t.config.validateStatus;
  !t.status || !n || n(t.status)
    ? i(t)
    : e(
        new je(
          "Request failed with status code " + t.status,
          [je.ERR_BAD_REQUEST, je.ERR_BAD_RESPONSE][
            Math.floor(t.status / 100) - 4
          ],
          t.config,
          t.request,
          t,
        ),
      );
}
function Vy(i) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(i);
  return (e && e[1]) || "";
}
function Gy(i, e) {
  i = i || 10;
  const t = new Array(i),
    n = new Array(i);
  let r = 0,
    s = 0,
    a;
  return (
    (e = e !== void 0 ? e : 1e3),
    function (l) {
      const c = Date.now(),
        u = n[s];
      a || (a = c), (t[r] = l), (n[r] = c);
      let h = s,
        f = 0;
      for (; h !== r; ) (f += t[h++]), (h = h % i);
      if (((r = (r + 1) % i), r === s && (s = (s + 1) % i), c - a < e)) return;
      const m = u && c - u;
      return m ? Math.round((f * 1e3) / m) : void 0;
    }
  );
}
function Wy(i, e) {
  let t = 0,
    n = 1e3 / e,
    r,
    s;
  const a = (c, u = Date.now()) => {
    (t = u), (r = null), s && (clearTimeout(s), (s = null)), i(...c);
  };
  return [
    (...c) => {
      const u = Date.now(),
        h = u - t;
      h >= n
        ? a(c, u)
        : ((r = c),
          s ||
            (s = setTimeout(() => {
              (s = null), a(r);
            }, n - h)));
    },
    () => r && a(r),
  ];
}
const wa = (i, e, t = 3) => {
    let n = 0;
    const r = Gy(50, 250);
    return Wy((s) => {
      const a = s.loaded,
        o = s.lengthComputable ? s.total : void 0,
        l = a - n,
        c = r(l),
        u = a <= o;
      n = a;
      const h = {
        loaded: a,
        total: o,
        progress: o ? a / o : void 0,
        bytes: l,
        rate: c || void 0,
        estimated: c && o && u ? (o - a) / c : void 0,
        event: s,
        lengthComputable: o != null,
        [e ? "download" : "upload"]: !0,
      };
      i(h);
    }, t);
  },
  Cf = (i, e) => {
    const t = i != null;
    return [(n) => e[0]({ lengthComputable: t, total: i, loaded: n }), e[1]];
  },
  wf =
    (i) =>
    (...e) =>
      Z.asap(() => i(...e)),
  Xy = Xt.hasStandardBrowserEnv
    ? ((i, e) => (t) => (
        (t = new URL(t, Xt.origin)),
        i.protocol === t.protocol &&
          i.host === t.host &&
          (e || i.port === t.port)
      ))(
        new URL(Xt.origin),
        Xt.navigator && /(msie|trident)/i.test(Xt.navigator.userAgent),
      )
    : () => !0,
  qy = Xt.hasStandardBrowserEnv
    ? {
        write(i, e, t, n, r, s, a) {
          if (typeof document == "undefined") return;
          const o = [`${i}=${encodeURIComponent(e)}`];
          Z.isNumber(t) && o.push(`expires=${new Date(t).toUTCString()}`),
            Z.isString(n) && o.push(`path=${n}`),
            Z.isString(r) && o.push(`domain=${r}`),
            s === !0 && o.push("secure"),
            Z.isString(a) && o.push(`SameSite=${a}`),
            (document.cookie = o.join("; "));
        },
        read(i) {
          if (typeof document == "undefined") return null;
          const e = document.cookie.match(
            new RegExp("(?:^|; )" + i + "=([^;]*)"),
          );
          return e ? decodeURIComponent(e[1]) : null;
        },
        remove(i) {
          this.write(i, "", Date.now() - 864e5, "/");
        },
      }
    : {
        write() {},
        read() {
          return null;
        },
        remove() {},
      };
function Yy(i) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(i);
}
function $y(i, e) {
  return e ? i.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : i;
}
function od(i, e, t) {
  let n = !Yy(e);
  return i && (n || t == !1) ? $y(i, e) : e;
}
const Rf = (i) => (i instanceof tn ? Xn({}, i) : i);
function wi(i, e) {
  e = e || {};
  const t = {};
  function n(c, u, h, f) {
    return Z.isPlainObject(c) && Z.isPlainObject(u)
      ? Z.merge.call({ caseless: f }, c, u)
      : Z.isPlainObject(u)
        ? Z.merge({}, u)
        : Z.isArray(u)
          ? u.slice()
          : u;
  }
  function r(c, u, h, f) {
    if (Z.isUndefined(u)) {
      if (!Z.isUndefined(c)) return n(void 0, c, h, f);
    } else return n(c, u, h, f);
  }
  function s(c, u) {
    if (!Z.isUndefined(u)) return n(void 0, u);
  }
  function a(c, u) {
    if (Z.isUndefined(u)) {
      if (!Z.isUndefined(c)) return n(void 0, c);
    } else return n(void 0, u);
  }
  function o(c, u, h) {
    if (h in e) return n(c, u);
    if (h in i) return n(void 0, c);
  }
  const l = {
    url: s,
    method: s,
    data: s,
    baseURL: a,
    transformRequest: a,
    transformResponse: a,
    paramsSerializer: a,
    timeout: a,
    timeoutMessage: a,
    withCredentials: a,
    withXSRFToken: a,
    adapter: a,
    responseType: a,
    xsrfCookieName: a,
    xsrfHeaderName: a,
    onUploadProgress: a,
    onDownloadProgress: a,
    decompress: a,
    maxContentLength: a,
    maxBodyLength: a,
    beforeRedirect: a,
    transport: a,
    httpAgent: a,
    httpsAgent: a,
    cancelToken: a,
    socketPath: a,
    responseEncoding: a,
    validateStatus: o,
    headers: (c, u, h) => r(Rf(c), Rf(u), h, !0),
  };
  return (
    Z.forEach(Object.keys(Xn(Xn({}, i), e)), function (u) {
      const h = l[u] || r,
        f = h(i[u], e[u], u);
      (Z.isUndefined(f) && h !== o) || (t[u] = f);
    }),
    t
  );
}
const cd = (i) => {
    const e = wi({}, i);
    let {
      data: t,
      withXSRFToken: n,
      xsrfHeaderName: r,
      xsrfCookieName: s,
      headers: a,
      auth: o,
    } = e;
    if (
      ((e.headers = a = tn.from(a)),
      (e.url = nd(
        od(e.baseURL, e.url, e.allowAbsoluteUrls),
        i.params,
        i.paramsSerializer,
      )),
      o &&
        a.set(
          "Authorization",
          "Basic " +
            btoa(
              (o.username || "") +
                ":" +
                (o.password ? unescape(encodeURIComponent(o.password)) : ""),
            ),
        ),
      Z.isFormData(t))
    ) {
      if (Xt.hasStandardBrowserEnv || Xt.hasStandardBrowserWebWorkerEnv)
        a.setContentType(void 0);
      else if (Z.isFunction(t.getHeaders)) {
        const l = t.getHeaders(),
          c = ["content-type", "content-length"];
        Object.entries(l).forEach(([u, h]) => {
          c.includes(u.toLowerCase()) && a.set(u, h);
        });
      }
    }
    if (
      Xt.hasStandardBrowserEnv &&
      (n && Z.isFunction(n) && (n = n(e)), n || (n !== !1 && Xy(e.url)))
    ) {
      const l = r && s && qy.read(s);
      l && a.set(r, l);
    }
    return e;
  },
  jy = typeof XMLHttpRequest != "undefined",
  Ky =
    jy &&
    function (i) {
      return new Promise(function (t, n) {
        const r = cd(i);
        let s = r.data;
        const a = tn.from(r.headers).normalize();
        let { responseType: o, onUploadProgress: l, onDownloadProgress: c } = r,
          u,
          h,
          f,
          m,
          x;
        function g() {
          m && m(),
            x && x(),
            r.cancelToken && r.cancelToken.unsubscribe(u),
            r.signal && r.signal.removeEventListener("abort", u);
        }
        let d = new XMLHttpRequest();
        d.open(r.method.toUpperCase(), r.url, !0), (d.timeout = r.timeout);
        function p() {
          if (!d) return;
          const E = tn.from(
              "getAllResponseHeaders" in d && d.getAllResponseHeaders(),
            ),
            C = {
              data:
                !o || o === "text" || o === "json"
                  ? d.responseText
                  : d.response,
              status: d.status,
              statusText: d.statusText,
              headers: E,
              config: i,
              request: d,
            };
          ad(
            function (S) {
              t(S), g();
            },
            function (S) {
              n(S), g();
            },
            C,
          ),
            (d = null);
        }
        "onloadend" in d
          ? (d.onloadend = p)
          : (d.onreadystatechange = function () {
              !d ||
                d.readyState !== 4 ||
                (d.status === 0 &&
                  !(d.responseURL && d.responseURL.indexOf("file:") === 0)) ||
                setTimeout(p);
            }),
          (d.onabort = function () {
            d &&
              (n(new je("Request aborted", je.ECONNABORTED, i, d)), (d = null));
          }),
          (d.onerror = function (v) {
            const C = v && v.message ? v.message : "Network Error",
              A = new je(C, je.ERR_NETWORK, i, d);
            (A.event = v || null), n(A), (d = null);
          }),
          (d.ontimeout = function () {
            let v = r.timeout
              ? "timeout of " + r.timeout + "ms exceeded"
              : "timeout exceeded";
            const C = r.transitional || id;
            r.timeoutErrorMessage && (v = r.timeoutErrorMessage),
              n(
                new je(
                  v,
                  C.clarifyTimeoutError ? je.ETIMEDOUT : je.ECONNABORTED,
                  i,
                  d,
                ),
              ),
              (d = null);
          }),
          s === void 0 && a.setContentType(null),
          "setRequestHeader" in d &&
            Z.forEach(a.toJSON(), function (v, C) {
              d.setRequestHeader(C, v);
            }),
          Z.isUndefined(r.withCredentials) ||
            (d.withCredentials = !!r.withCredentials),
          o && o !== "json" && (d.responseType = r.responseType),
          c && (([f, x] = wa(c, !0)), d.addEventListener("progress", f)),
          l &&
            d.upload &&
            (([h, m] = wa(l)),
            d.upload.addEventListener("progress", h),
            d.upload.addEventListener("loadend", m)),
          (r.cancelToken || r.signal) &&
            ((u = (E) => {
              d &&
                (n(!E || E.type ? new Er(null, i, d) : E),
                d.abort(),
                (d = null));
            }),
            r.cancelToken && r.cancelToken.subscribe(u),
            r.signal &&
              (r.signal.aborted ? u() : r.signal.addEventListener("abort", u)));
        const y = Vy(r.url);
        if (y && Xt.protocols.indexOf(y) === -1) {
          n(new je("Unsupported protocol " + y + ":", je.ERR_BAD_REQUEST, i));
          return;
        }
        d.send(s || null);
      });
    },
  Zy = (i, e) => {
    const { length: t } = (i = i ? i.filter(Boolean) : []);
    if (e || t) {
      let n = new AbortController(),
        r;
      const s = function (c) {
        if (!r) {
          (r = !0), o();
          const u = c instanceof Error ? c : this.reason;
          n.abort(
            u instanceof je ? u : new Er(u instanceof Error ? u.message : u),
          );
        }
      };
      let a =
        e &&
        setTimeout(() => {
          (a = null), s(new je(`timeout ${e} of ms exceeded`, je.ETIMEDOUT));
        }, e);
      const o = () => {
        i &&
          (a && clearTimeout(a),
          (a = null),
          i.forEach((c) => {
            c.unsubscribe
              ? c.unsubscribe(s)
              : c.removeEventListener("abort", s);
          }),
          (i = null));
      };
      i.forEach((c) => c.addEventListener("abort", s));
      const { signal: l } = n;
      return (l.unsubscribe = () => Z.asap(o)), l;
    }
  },
  Jy = function* (i, e) {
    let t = i.byteLength;
    if (t < e) {
      yield i;
      return;
    }
    let n = 0,
      r;
    for (; n < t; ) (r = n + e), yield i.slice(n, r), (n = r);
  },
  Qy = function (i, e) {
    return Ga(this, null, function* () {
      try {
        for (
          var t = pl(eS(i)), n, r, s;
          (n = !(r = yield new li(t.next())).done);
          n = !1
        ) {
          const a = r.value;
          yield* Wa(Jy(a, e));
        }
      } catch (r) {
        s = [r];
      } finally {
        try {
          n && (r = t.return) && (yield new li(r.call(t)));
        } finally {
          if (s) throw s[0];
        }
      }
    });
  },
  eS = function (i) {
    return Ga(this, null, function* () {
      if (i[Symbol.asyncIterator]) {
        yield* Wa(i);
        return;
      }
      const e = i.getReader();
      try {
        for (;;) {
          const { done: t, value: n } = yield new li(e.read());
          if (t) break;
          yield n;
        }
      } finally {
        yield new li(e.cancel());
      }
    });
  },
  Df = (i, e, t, n) => {
    const r = Qy(i, e);
    let s = 0,
      a,
      o = (l) => {
        a || ((a = !0), n && n(l));
      };
    return new ReadableStream(
      {
        async pull(l) {
          try {
            const { done: c, value: u } = await r.next();
            if (c) {
              o(), l.close();
              return;
            }
            let h = u.byteLength;
            if (t) {
              let f = (s += h);
              t(f);
            }
            l.enqueue(new Uint8Array(u));
          } catch (c) {
            throw (o(c), c);
          }
        },
        cancel(l) {
          return o(l), r.return();
        },
      },
      { highWaterMark: 2 },
    );
  },
  Pf = 64 * 1024,
  { isFunction: Ts } = Z,
  tS = (({ Request: i, Response: e }) => ({ Request: i, Response: e }))(
    Z.global,
  ),
  { ReadableStream: Ff, TextEncoder: Bf } = Z.global,
  Lf = (i, ...e) => {
    try {
      return !!i(...e);
    } catch (t) {
      return !1;
    }
  },
  nS = (i) => {
    i = Z.merge.call({ skipUndefined: !0 }, tS, i);
    const { fetch: e, Request: t, Response: n } = i,
      r = e ? Ts(e) : typeof fetch == "function",
      s = Ts(t),
      a = Ts(n);
    if (!r) return !1;
    const o = r && Ts(Ff),
      l =
        r &&
        (typeof Bf == "function"
          ? (
              (x) => (g) =>
                x.encode(g)
            )(new Bf())
          : async (x) => new Uint8Array(await new t(x).arrayBuffer())),
      c =
        s &&
        o &&
        Lf(() => {
          let x = !1;
          const g = new t(Xt.origin, {
            body: new Ff(),
            method: "POST",
            get duplex() {
              return (x = !0), "half";
            },
          }).headers.has("Content-Type");
          return x && !g;
        }),
      u = a && o && Lf(() => Z.isReadableStream(new n("").body)),
      h = { stream: u && ((x) => x.body) };
    r &&
      ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((x) => {
        !h[x] &&
          (h[x] = (g, d) => {
            let p = g && g[x];
            if (p) return p.call(g);
            throw new je(
              `Response type '${x}' is not supported`,
              je.ERR_NOT_SUPPORT,
              d,
            );
          });
      });
    const f = async (x) => {
        if (x == null) return 0;
        if (Z.isBlob(x)) return x.size;
        if (Z.isSpecCompliantForm(x))
          return (
            await new t(Xt.origin, { method: "POST", body: x }).arrayBuffer()
          ).byteLength;
        if (Z.isArrayBufferView(x) || Z.isArrayBuffer(x)) return x.byteLength;
        if ((Z.isURLSearchParams(x) && (x = x + ""), Z.isString(x)))
          return (await l(x)).byteLength;
      },
      m = async (x, g) => {
        const d = Z.toFiniteNumber(x.getContentLength());
        return d == null ? f(g) : d;
      };
    return async (x) => {
      let {
          url: g,
          method: d,
          data: p,
          signal: y,
          cancelToken: E,
          timeout: v,
          onDownloadProgress: C,
          onUploadProgress: A,
          responseType: S,
          headers: R,
          withCredentials: M = "same-origin",
          fetchOptions: _,
        } = cd(x),
        T = e || fetch;
      S = S ? (S + "").toLowerCase() : "text";
      let F = Zy([y, E && E.toAbortSignal()], v),
        P = null;
      const I =
        F &&
        F.unsubscribe &&
        (() => {
          F.unsubscribe();
        });
      let X;
      try {
        if (
          A &&
          c &&
          d !== "get" &&
          d !== "head" &&
          (X = await m(R, p)) !== 0
        ) {
          let H = new t(g, { method: "POST", body: p, duplex: "half" }),
            K;
          if (
            (Z.isFormData(p) &&
              (K = H.headers.get("content-type")) &&
              R.setContentType(K),
            H.body)
          ) {
            const [Q, B] = Cf(X, wa(wf(A)));
            p = Df(H.body, Pf, Q, B);
          }
        }
        Z.isString(M) || (M = M ? "include" : "omit");
        const V = s && "credentials" in t.prototype,
          ie = dl(Xn({}, _), {
            signal: F,
            method: d.toUpperCase(),
            headers: R.normalize().toJSON(),
            body: p,
            duplex: "half",
            credentials: V ? M : void 0,
          });
        P = s && new t(g, ie);
        let k = await (s ? T(P, _) : T(g, ie));
        const ae = u && (S === "stream" || S === "response");
        if (u && (C || (ae && I))) {
          const H = {};
          ["status", "statusText", "headers"].forEach((te) => {
            H[te] = k[te];
          });
          const K = Z.toFiniteNumber(k.headers.get("content-length")),
            [Q, B] = (C && Cf(K, wa(wf(C), !0))) || [];
          k = new n(
            Df(k.body, Pf, Q, () => {
              B && B(), I && I();
            }),
            H,
          );
        }
        S = S || "text";
        let ce = await h[Z.findKey(h, S) || "text"](k, x);
        return (
          !ae && I && I(),
          await new Promise((H, K) => {
            ad(H, K, {
              data: ce,
              headers: tn.from(k.headers),
              status: k.status,
              statusText: k.statusText,
              config: x,
              request: P,
            });
          })
        );
      } catch (V) {
        throw (
          (I && I(),
          V && V.name === "TypeError" && /Load failed|fetch/i.test(V.message)
            ? Object.assign(new je("Network Error", je.ERR_NETWORK, x, P), {
                cause: V.cause || V,
              })
            : je.from(V, V && V.code, x, P))
        );
      }
    };
  },
  iS = new Map(),
  ld = (i) => {
    let e = (i && i.env) || {};
    const { fetch: t, Request: n, Response: r } = e,
      s = [n, r, t];
    let a = s.length,
      o = a,
      l,
      c,
      u = iS;
    for (; o--; )
      (l = s[o]),
        (c = u.get(l)),
        c === void 0 && u.set(l, (c = o ? new Map() : nS(e))),
        (u = c);
    return c;
  };
ld();
const ul = { http: Ey, xhr: Ky, fetch: { get: ld } };
Z.forEach(ul, (i, e) => {
  if (i) {
    try {
      Object.defineProperty(i, "name", { value: e });
    } catch (t) {}
    Object.defineProperty(i, "adapterName", { value: e });
  }
});
const Uf = (i) => `- ${i}`,
  rS = (i) => Z.isFunction(i) || i === null || i === !1;
function sS(i, e) {
  i = Z.isArray(i) ? i : [i];
  const { length: t } = i;
  let n, r;
  const s = {};
  for (let a = 0; a < t; a++) {
    n = i[a];
    let o;
    if (
      ((r = n),
      !rS(n) && ((r = ul[(o = String(n)).toLowerCase()]), r === void 0))
    )
      throw new je(`Unknown adapter '${o}'`);
    if (r && (Z.isFunction(r) || (r = r.get(e)))) break;
    s[o || "#" + a] = r;
  }
  if (!r) {
    const a = Object.entries(s).map(
      ([l, c]) =>
        `adapter ${l} ` +
        (c === !1
          ? "is not supported by the environment"
          : "is not available in the build"),
    );
    let o = t
      ? a.length > 1
        ? `since :
` +
          a.map(Uf).join(`
`)
        : " " + Uf(a[0])
      : "as no adapter specified";
    throw new je(
      "There is no suitable adapter to dispatch the request " + o,
      "ERR_NOT_SUPPORT",
    );
  }
  return r;
}
const ud = { getAdapter: sS, adapters: ul };
function Uo(i) {
  if (
    (i.cancelToken && i.cancelToken.throwIfRequested(),
    i.signal && i.signal.aborted)
  )
    throw new Er(null, i);
}
function If(i) {
  return (
    Uo(i),
    (i.headers = tn.from(i.headers)),
    (i.data = Lo.call(i, i.transformRequest)),
    ["post", "put", "patch"].indexOf(i.method) !== -1 &&
      i.headers.setContentType("application/x-www-form-urlencoded", !1),
    ud
      .getAdapter(
        i.adapter || jr.adapter,
        i,
      )(i)
      .then(
        function (n) {
          return (
            Uo(i),
            (n.data = Lo.call(i, i.transformResponse, n)),
            (n.headers = tn.from(n.headers)),
            n
          );
        },
        function (n) {
          return (
            sd(n) ||
              (Uo(i),
              n &&
                n.response &&
                ((n.response.data = Lo.call(
                  i,
                  i.transformResponse,
                  n.response,
                )),
                (n.response.headers = tn.from(n.response.headers)))),
            Promise.reject(n)
          );
        },
      )
  );
}
const fd = "1.13.0",
  Ha = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(
  (i, e) => {
    Ha[i] = function (n) {
      return typeof n === i || "a" + (e < 1 ? "n " : " ") + i;
    };
  },
);
const Nf = {};
Ha.transitional = function (e, t, n) {
  function r(s, a) {
    return (
      "[Axios v" +
      fd +
      "] Transitional option '" +
      s +
      "'" +
      a +
      (n ? ". " + n : "")
    );
  }
  return (s, a, o) => {
    if (e === !1)
      throw new je(
        r(a, " has been removed" + (t ? " in " + t : "")),
        je.ERR_DEPRECATED,
      );
    return (
      t &&
        !Nf[a] &&
        ((Nf[a] = !0),
        console.warn(
          r(
            a,
            " has been deprecated since v" +
              t +
              " and will be removed in the near future",
          ),
        )),
      e ? e(s, a, o) : !0
    );
  };
};
Ha.spelling = function (e) {
  return (t, n) => (console.warn(`${n} is likely a misspelling of ${e}`), !0);
};
function aS(i, e, t) {
  if (typeof i != "object")
    throw new je("options must be an object", je.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(i);
  let r = n.length;
  for (; r-- > 0; ) {
    const s = n[r],
      a = e[s];
    if (a) {
      const o = i[s],
        l = o === void 0 || a(o, s, i);
      if (l !== !0)
        throw new je("option " + s + " must be " + l, je.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (t !== !0) throw new je("Unknown option " + s, je.ERR_BAD_OPTION);
  }
}
const Sa = { assertOptions: aS, validators: Ha },
  Cn = Sa.validators;
let bi = class {
  constructor(e) {
    (this.defaults = e || {}),
      (this.interceptors = { request: new bf(), response: new bf() });
  }
  async request(e, t) {
    try {
      return await this._request(e, t);
    } catch (n) {
      if (n instanceof Error) {
        let r = {};
        Error.captureStackTrace
          ? Error.captureStackTrace(r)
          : (r = new Error());
        const s = r.stack ? r.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack
            ? s &&
              !String(n.stack).endsWith(s.replace(/^.+\n.+\n/, "")) &&
              (n.stack +=
                `
` + s)
            : (n.stack = s);
        } catch (a) {}
      }
      throw n;
    }
  }
  _request(e, t) {
    typeof e == "string" ? ((t = t || {}), (t.url = e)) : (t = e || {}),
      (t = wi(this.defaults, t));
    const { transitional: n, paramsSerializer: r, headers: s } = t;
    n !== void 0 &&
      Sa.assertOptions(
        n,
        {
          silentJSONParsing: Cn.transitional(Cn.boolean),
          forcedJSONParsing: Cn.transitional(Cn.boolean),
          clarifyTimeoutError: Cn.transitional(Cn.boolean),
        },
        !1,
      ),
      r != null &&
        (Z.isFunction(r)
          ? (t.paramsSerializer = { serialize: r })
          : Sa.assertOptions(
              r,
              { encode: Cn.function, serialize: Cn.function },
              !0,
            )),
      t.allowAbsoluteUrls !== void 0 ||
        (this.defaults.allowAbsoluteUrls !== void 0
          ? (t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls)
          : (t.allowAbsoluteUrls = !0)),
      Sa.assertOptions(
        t,
        {
          baseUrl: Cn.spelling("baseURL"),
          withXsrfToken: Cn.spelling("withXSRFToken"),
        },
        !0,
      ),
      (t.method = (t.method || this.defaults.method || "get").toLowerCase());
    let a = s && Z.merge(s.common, s[t.method]);
    s &&
      Z.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (x) => {
          delete s[x];
        },
      ),
      (t.headers = tn.concat(a, s));
    const o = [];
    let l = !0;
    this.interceptors.request.forEach(function (g) {
      (typeof g.runWhen == "function" && g.runWhen(t) === !1) ||
        ((l = l && g.synchronous), o.unshift(g.fulfilled, g.rejected));
    });
    const c = [];
    this.interceptors.response.forEach(function (g) {
      c.push(g.fulfilled, g.rejected);
    });
    let u,
      h = 0,
      f;
    if (!l) {
      const x = [If.bind(this), void 0];
      for (
        x.unshift(...o), x.push(...c), f = x.length, u = Promise.resolve(t);
        h < f;

      )
        u = u.then(x[h++], x[h++]);
      return u;
    }
    f = o.length;
    let m = t;
    for (; h < f; ) {
      const x = o[h++],
        g = o[h++];
      try {
        m = x(m);
      } catch (d) {
        g.call(this, d);
        break;
      }
    }
    try {
      u = If.call(this, m);
    } catch (x) {
      return Promise.reject(x);
    }
    for (h = 0, f = c.length; h < f; ) u = u.then(c[h++], c[h++]);
    return u;
  }
  getUri(e) {
    e = wi(this.defaults, e);
    const t = od(e.baseURL, e.url, e.allowAbsoluteUrls);
    return nd(t, e.params, e.paramsSerializer);
  }
};
Z.forEach(["delete", "get", "head", "options"], function (e) {
  bi.prototype[e] = function (t, n) {
    return this.request(
      wi(n || {}, { method: e, url: t, data: (n || {}).data }),
    );
  };
});
Z.forEach(["post", "put", "patch"], function (e) {
  function t(n) {
    return function (s, a, o) {
      return this.request(
        wi(o || {}, {
          method: e,
          headers: n ? { "Content-Type": "multipart/form-data" } : {},
          url: s,
          data: a,
        }),
      );
    };
  }
  (bi.prototype[e] = t()), (bi.prototype[e + "Form"] = t(!0));
});
let oS = class hd {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let t;
    this.promise = new Promise(function (s) {
      t = s;
    });
    const n = this;
    this.promise.then((r) => {
      if (!n._listeners) return;
      let s = n._listeners.length;
      for (; s-- > 0; ) n._listeners[s](r);
      n._listeners = null;
    }),
      (this.promise.then = (r) => {
        let s;
        const a = new Promise((o) => {
          n.subscribe(o), (s = o);
        }).then(r);
        return (
          (a.cancel = function () {
            n.unsubscribe(s);
          }),
          a
        );
      }),
      e(function (s, a, o) {
        n.reason || ((n.reason = new Er(s, a, o)), t(n.reason));
      });
  }
  throwIfRequested() {
    if (this.reason) throw this.reason;
  }
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : (this._listeners = [e]);
  }
  unsubscribe(e) {
    if (!this._listeners) return;
    const t = this._listeners.indexOf(e);
    t !== -1 && this._listeners.splice(t, 1);
  }
  toAbortSignal() {
    const e = new AbortController(),
      t = (n) => {
        e.abort(n);
      };
    return (
      this.subscribe(t),
      (e.signal.unsubscribe = () => this.unsubscribe(t)),
      e.signal
    );
  }
  static source() {
    let e;
    return {
      token: new hd(function (r) {
        e = r;
      }),
      cancel: e,
    };
  }
};
function cS(i) {
  return function (t) {
    return i.apply(null, t);
  };
}
function lS(i) {
  return Z.isObject(i) && i.isAxiosError === !0;
}
const Oc = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
  WebServerIsDown: 521,
  ConnectionTimedOut: 522,
  OriginIsUnreachable: 523,
  TimeoutOccurred: 524,
  SslHandshakeFailed: 525,
  InvalidSslCertificate: 526,
};
Object.entries(Oc).forEach(([i, e]) => {
  Oc[e] = i;
});
function dd(i) {
  const e = new bi(i),
    t = Wh(bi.prototype.request, e);
  return (
    Z.extend(t, bi.prototype, e, { allOwnKeys: !0 }),
    Z.extend(t, e, null, { allOwnKeys: !0 }),
    (t.create = function (r) {
      return dd(wi(i, r));
    }),
    t
  );
}
const Bt = dd(jr);
Bt.Axios = bi;
Bt.CanceledError = Er;
Bt.CancelToken = oS;
Bt.isCancel = sd;
Bt.VERSION = fd;
Bt.toFormData = ka;
Bt.AxiosError = je;
Bt.Cancel = Bt.CanceledError;
Bt.all = function (e) {
  return Promise.all(e);
};
Bt.spread = cS;
Bt.isAxiosError = lS;
Bt.mergeConfig = wi;
Bt.AxiosHeaders = tn;
Bt.formToJSON = (i) => rd(Z.isHTMLForm(i) ? new FormData(i) : i);
Bt.getAdapter = ud.getAdapter;
Bt.HttpStatusCode = Oc;
Bt.default = Bt;
const {
  Axios: TS,
  AxiosError: CS,
  CanceledError: wS,
  isCancel: RS,
  CancelToken: DS,
  VERSION: PS,
  all: FS,
  Cancel: BS,
  isAxiosError: LS,
  spread: US,
  toFormData: IS,
  AxiosHeaders: NS,
  HttpStatusCode: OS,
  formToJSON: zS,
  getAdapter: kS,
  mergeConfig: HS,
} = Bt;
export {
  It as A,
  bn as B,
  dS as C,
  yS as D,
  Io as E,
  Fo as F,
  ps as G,
  Bt as H,
  mh as M,
  dn as P,
  pS as S,
  vS as T,
  SS as W,
  Aa as a,
  Hd as b,
  hS as c,
  fS as d,
  An as e,
  Zm as f,
  Ed as g,
  xS as h,
  At as i,
  Nr as j,
  $m as k,
  ut as l,
  er as m,
  mS as n,
  mu as o,
  Ri as p,
  Ah as q,
  Vd as r,
  Ra as s,
  Vn as t,
  gS as u,
  _S as v,
  Mh as w,
  Xr as x,
  Ba as y,
  ES as z,
};
